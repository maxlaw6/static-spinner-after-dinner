<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"/>
    <title>Spinner after Dinner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet"/>
    <style>
        /* General Body and Layout Styles */
        html, body {
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
        }
        body {
            font-family: 'Inter', sans-serif;
            user-select: none;
            -webkit-user-select: none; /* Safari */
            touch-action: none;
            background-color: #1f2937; /* bg-gray-800 */
        }

        /* Game World and Board Styles */
        #world {
            position: relative;
            overflow: hidden;
            cursor: grab;
            width: 100%;
            height: 100%;
            background-color: #00693E; /* Felt Green */
            background-image: radial-gradient(rgba(255, 255, 255, 0.05) 10%, transparent 0);
            background-size: 5px 5px;
            border-radius: 20px; /* Rounded corners for the table */
            touch-action: none; /* Critical for smooth touch controls on iPad */
        }
        #world.panning {
            cursor: grabbing;
        }
        #game-board {
            position: absolute;
            width: 2500px;
            height: 2500px;
            transform-origin: top left;
            will-change: transform; /* Performance hint for the browser */
        }
        #starting-area {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            /* Adjusted to perfectly frame the starting domino */
            width: 44px;
            height: 84px;
            border: 2px dashed rgba(255, 255, 255, 0.4);
            border-radius: 8px;
        }

        /* Domino Styles */
        .domino {
            width: 80px;
            height: 40px;
            border: 1px solid #1a1a1a;
            background-color: #f7f7f7;
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-radius: 6px;
            cursor: grab;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2), inset 0 0 2px rgba(0,0,0,0.2);
            transform-origin: center center;
            color: #1a1a1a;
            transition: box-shadow 0.2s ease, transform 0.25s ease, top 0.3s ease, left 0.3s ease;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on iOS */
        }
        .domino.domino-back {
            background-color: #f7f7f7;
            border: 1px solid #a0aec0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            position: relative;
        }
        .domino.domino-back::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 10%;
            height: 80%;
            width: 2px;
            background-color: rgba(0,0,0,0.1);
            transform: translateX(-50%);
        }
        .domino.dragging {
            cursor: grabbing;
            transition: none !important;
            z-index: 3000 !important;
            position: fixed !important;
            top: 0; /* Position is now handled by transform */
            left: 0; /* Position is now handled by transform */
            opacity: 0.95;
            pointer-events: none;
            transform-origin: top left; /* Match transform logic */
        }
        
        /* Mini Domino Styles for Opponent Hands */
        .mini-domino {
            width: 40px;
            height: 20px;
            border-radius: 3px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            cursor: default !important;
        }
        .mini-domino.domino-back::after {
            width: 1px;
        }

        /* Pip and Spinner Styles */
        .pip-container {
            width: 50%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            align-items: center;
            justify-items: center;
            padding: 4px;
            pointer-events: none;
        }
        .divider {
            width: 2px;
            height: 80%;
            background-color: #1a1a1a;
            pointer-events: none;
        }
        .pip {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
            backface-visibility: hidden;
            transform: translateZ(0);
        }
        .pip-color-0 { background-color: #cbd5e0; }
        .pip-color-1 { background-color: #EADCA6; }
        .pip-color-2 { background-color: #8B0000; }
        .pip-color-3 { background-color: #800000; }
        .pip-color-4 { background-color: #00BFFF; }
        .pip-color-5 { background-color: #006400; }
        .pip-color-6 { background-color: #000000; }
        .pip-color-7 { background-color: #A0522D; }
        .pip-color-8 { background-color: #9370DB; }
        .pip-color-9 { background-color: #808080; }
        
        .spinner-icon {
            width: 24px;
            height: 24px;
            grid-column: 1 / -1;
            grid-row: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            line-height: 1.1;
        }
        .spinner-icon svg {
            width: 100%;
            height: 100%;
        }


        /* UI Components */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #boneyard-pile {
            border: 2px dashed #a0aec0;
            height: 60px;
            width: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            position: relative;
            border-radius: 8px;
            background-color: rgba(0,0,0,0.2);
        }
        #boneyard-pile:hover {
            background-color: rgba(255,255,255,0.1);
        }
        #boneyard-stack {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .boneyard-domino-display {
            width: 80px;
            height: 40px;
            border: 1px solid #a0aec0;
            background-color: #f7f7f7;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #boneyard-count {
            position: absolute;
            z-index: 10;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.6);
            padding: 2px 10px;
            border-radius: 12px;
            text-shadow: 0 0 5px #000;
        }
        #boneyard-message {
            position: absolute;
            z-index: 11;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 3px #000;
            pointer-events: none;
        }
        @keyframes flash-border {
            0%, 100% { border-color: #a0aec0; box-shadow: none; }
            50% { border-color: #FFD700; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        }
        .flashing-border {
            animation: flash-border 1.5s infinite;
        }
        #boneyard-pile.can-draw {
            animation: flash-border 1.5s infinite;
        }
        #minimap-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            z-index: 2000;
        }
        #minimap-viewport {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }
        .minimap-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: white;
            border-radius: 50%;
            pointer-events: auto;
            cursor: pointer;
            border: 1px solid white;
            box-shadow: 0 0 5px rgba(255,255,255,0.6);
        }
        .player-hand-section {
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            transition: all 0.3s ease;
            background-color: rgba(0,0,0,0.3);
        }
        .player-hand-content {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center; /* Centered the pips */
        }
        #setup-screen, #round-end-screen, #loading-screen, #game-over-screen, #message-modal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }
        /* IPAD FIX */
        #setup-screen > div {
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        .hidden {
            display: none !important;
        }
        #final-score-display, #round-end-content, #message-modal-content {
            background-color: rgba(31, 41, 55, 0.9); /* bg-gray-800 */
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .winner {
            color: #FFD700;
            font-weight: bold;
        }

        /* --- LAYOUT STYLES --- */
        #game-container {
            height: 100%;
            width: 100%;
        }
        #game-layout {
            display: grid;
            grid-template-columns: 250px 1fr; /* Left column for hands, right for board */
            grid-template-rows: auto 1fr; /* Top for info, bottom for main content */
            height: 100%; /* Changed from 100vh to fix iOS cutoff */
            width: 100%;
            /* Add padding that respects the safe area on iOS devices */
            padding-left: calc(1rem + env(safe-area-inset-left));
            padding-right: calc(1rem + env(safe-area-inset-right));
            padding-top: calc(1rem + env(safe-area-inset-top));
            padding-bottom: calc(1rem + env(safe-area-inset-bottom));
            gap: 1rem;
            box-sizing: border-box;
        }
        #game-info { 
            grid-column: 1 / -1; /* Span both columns */
            grid-row: 1 / 2; 
        }
        #left-panel {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-height: 0;
        }
        #player-hands-container {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #boneyard-container {
            flex-shrink: 0;
        }
        #main-game-area {
            grid-column: 2 / 3;
            grid-row: 2 / 3;
            position: relative;
            display: grid;
            place-items: center;
            min-height: 0;
        }
        #main-game-area > * {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
        }
        #world-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #boneyard-buttons {
            flex-direction: row; /* Align buttons horizontally */
        }
        
        #game-log {
            background-color: rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 8px;
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #d1d5db; /* gray-300 */
            min-width: 150px; /* Prevent it from collapsing */
        }

        @media (max-width: 1024px) { /* Adjust breakpoint for vertical layout */
            #game-layout {
                grid-template-columns: 1fr; /* Single column */
                grid-template-rows: auto auto 1fr; /* Info, Player Area, Board */
            }
            #game-info { grid-row: 1 / 2; }
            #left-panel {
                grid-column: 1 / -1;
                grid-row: 2 / 3;
                flex-direction: row;
                overflow-x: auto;
                padding-bottom: 1rem;
            }
            #player-hands-container {
                flex-direction: row;
                flex-grow: 0;
            }
            .player-hand-section {
                flex-shrink: 0;
                width: 180px;
            }
            #boneyard-container {
                flex-shrink: 0;
            }
            #main-game-area {
                grid-column: 1 / -1;
                grid-row: 3 / 4;
            }
        }
    </style>
</head>
<body class="text-white">

<!-- Message Modal -->
<div id="message-modal" class="hidden">
    <div id="message-modal-content" class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm">
        <p id="message-text" class="text-lg mb-4"></p>
        <button id="message-ok-button" class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-2 px-3 rounded transition-colors">OK</button>
    </div>
</div>

<!-- Loading Screen -->
<div id="loading-screen" class="flex items-center justify-center">
    <div class="text-center">
        <h1 class="text-3xl font-bold">Connecting to Game Service...</h1>
        <p id="auth-status">Initializing...</p>
    </div>
</div>

<!-- Setup / Lobby Screen -->
<div class="hidden" id="setup-screen">
    <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-white w-full max-w-md">
        <h1 class="text-3xl font-bold text-center mb-6">Spinner after Dinner</h1>
        <div id="lobby-view">
            <div class="mb-4">
                <label class="block mb-2" for="player-name">Your Name:</label>
                <input class="w-full p-2 rounded bg-gray-700 text-white" id="player-name" placeholder="Enter your name" type="text"/>
            </div>
            <div class="flex gap-4 mb-6">
                <button class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors" disabled id="create-game-button">Create New Game</button>
            </div>
            <div class="text-center my-4">OR</div>
            <div class="mb-4">
                <label class="block mb-2" for="join-game-id">Join Existing Game:</label>
                <input class="w-full p-2 rounded bg-gray-700 text-white" id="join-game-id" placeholder="Enter Game ID" type="text"/>
            </div>
            <button class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 px-4 rounded transition-colors" disabled id="join-game-button">Join Game</button>
        </div>
        <div class="hidden text-center" id="waiting-room-view">
            <h2 class="text-2xl font-bold mb-4">Waiting Room</h2>
            <p class="mb-2">Share this Game ID with others:</p>
            <div class="bg-gray-900 p-3 rounded-lg mb-4 flex items-center justify-center">
                <span class="text-2xl font-mono text-yellow-300" id="game-id-display"></span>
                <button class="ml-4 bg-gray-600 hover:bg-gray-500 text-sm py-1 px-2 rounded" id="copy-game-id">Copy</button>
            </div>
            <p class="mb-2 font-bold">Players Joined:</p>
            <div class="space-y-2 mb-6" id="player-list"></div>
            <p class="mb-4 text-gray-400" id="waiting-message">Waiting for more players...</p>
            <button class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors" disabled id="start-game-button">Start Game</button>
        </div>
    </div>
</div>

<!-- Round End Screen -->
<div class="hidden" id="round-end-screen">
    <div class="w-full max-w-md" id="round-end-content">
        <h2 class="text-3xl font-bold text-center mb-4" id="round-end-title">Round Over!</h2>
        <p class="text-xl text-yellow-300 mb-4" id="round-winner-message"></p>
        <div class="mb-6" id="round-results-list"></div>
        <button class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded transition-colors" id="continue-round-button">Continue</button>
    </div>
</div>

<!-- Game Over Screen -->
<div class="hidden" id="game-over-screen">
    <div class="w-full max-w-md" id="final-score-display">
        <h2 class="text-4xl font-bold text-center mb-4 text-yellow-300">Game Over!</h2>
        <p class="text-xl mb-6" id="final-winner-message"></p>
        <div class="space-y-2 text-lg mb-8" id="final-score-list"></div>
        <button class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded transition-colors" id="main-menu-button-final">Main Menu</button>
    </div>
</div>

<!-- Main Game Container -->
<div class="hidden" id="game-container">
    <div id="game-layout">
        <!-- The main div is now a flex container with a gap. The game log is a direct child. -->
        <div class="bg-gray-900 bg-opacity-70 p-2 rounded-lg shadow-lg flex justify-between items-center flex-wrap gap-4" id="game-info">
            <!-- Group 1: Left Controls -->
            <div class="flex items-center gap-4">
                <button class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors" id="main-menu-button">New Game / Exit</button>
                <div>
                    <h2 class="font-bold text-lg">Current Turn: <span id="current-player"></span></h2>
                    <p class="text-sm text-yellow-300" id="game-status">Loading...</p>
                </div>
            </div>
            
            <!-- Group 2: Game Log & Pip Tally -->
            <div class="flex items-center gap-4 flex-grow justify-center">
                 <div id="game-log" class="flex-grow"></div>
                 <!-- NEW: Hand Value Tally -->
                <div class="text-center px-4">
                    <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Your Hand Pips</h3>
                    <p id="hand-value-display" class="text-2xl font-bold text-yellow-300">0</p>
                </div>
            </div>

            <!-- Group 3: Right Controls -->
            <div class="flex items-center gap-4">
                <button class="bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-2 px-4 rounded transition-colors" id="re-deal-button">Next Round</button>
                <select class="bg-gray-700 text-white rounded p-2" id="theme-switcher">
                    <option value="classic">Classic</option>
                    <option value="dr_edell">Dr. Edell</option>
                    <option value="austin">Austin</option>
                    <option value="rose">Rose</option>
                    <option value="anna">Anna</option>
                    <option value="kate">Kate</option>
                </select>
                <div class="text-right flex gap-4" id="scoreboard"></div>
            </div>
        </div>
        
        <div id="left-panel">
            <div id="player-hands-container">
                <!-- Player hands will be rendered here by JS -->
            </div>
            <div id="boneyard-container">
                <h2 class="text-xl font-semibold mb-3 text-center">Boneyard</h2>
                <div id="boneyard-pile" title="Click to draw a domino">
                    <div id="boneyard-stack"></div>
                    <span id="boneyard-count">0</span>
                </div>
                <div class="mt-2 flex items-center justify-center gap-2" id="boneyard-buttons">
                    <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors" id="undo-button">Undo</button>
                    <button class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors" id="end-turn-button">End Turn</button>
                    <button class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition-colors hidden" id="rotate-last-tile-button">Rotate Tile</button>
                </div>
            </div>
        </div>
        
        <div id="main-game-area">
            <div id="world-wrapper">
                <div id="world">
                    <div id="game-board">
                        <div id="starting-area"></div>
                    </div>
                    <div id="minimap-container">
                        <div id="minimap-viewport"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- Firebase SDK -->
<script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

    // --- DOM Elements ---
    const dom = {
        loadingScreen: document.getElementById('loading-screen'),
        authStatus: document.getElementById('auth-status'),
        setupScreen: document.getElementById('setup-screen'),
        gameContainer: document.getElementById('game-container'),
        lobbyView: document.getElementById('lobby-view'),
        waitingRoomView: document.getElementById('waiting-room-view'),
        createGameButton: document.getElementById('create-game-button'),
        joinGameButton: document.getElementById('join-game-button'),
        startGameButton: document.getElementById('start-game-button'),
        reDealButton: document.getElementById('re-deal-button'),
        playerNameInput: document.getElementById('player-name'),
        joinGameIdInput: document.getElementById('join-game-id'),
        gameIdDisplay: document.getElementById('game-id-display'),
        gameIdHeader: document.getElementById('game-id-header'),
        copyGameIdButton: document.getElementById('copy-game-id'),
        playerList: document.getElementById('player-list'),
        waitingMessage: document.getElementById('waiting-message'),
        worldElement: document.getElementById('world'),
        gameBoardElement: document.getElementById('game-board'),
        boneyardPileElement: document.getElementById('boneyard-pile'),
        boneyardStack: document.getElementById('boneyard-stack'),
        boneyardContainer: document.getElementById('boneyard-container'),
        boneyardCountElement: document.getElementById('boneyard-count'),
        currentPlayerElement: document.getElementById('current-player'),
        endTurnButton: document.getElementById('end-turn-button'),
        undoButton: document.getElementById('undo-button'),
        rotateLastTileButton: document.getElementById('rotate-last-tile-button'),
        gameStatusElement: document.getElementById('game-status'),
        playerHandsContainer: document.getElementById('player-hands-container'),
        scoreboard: document.getElementById('scoreboard'),
        themeSwitcher: document.getElementById('theme-switcher'),
        roundEndScreen: document.getElementById('round-end-screen'),
        roundEndTitle: document.getElementById('round-end-title'),
        roundWinnerMessage: document.getElementById('round-winner-message'),
        roundResultsList: document.getElementById('round-results-list'),
        continueRoundButton: document.getElementById('continue-round-button'),
        minimapContainer: document.getElementById('minimap-container'),
        minimapViewport: document.getElementById('minimap-viewport'),
        gameOverScreen: document.getElementById('game-over-screen'),
        finalWinnerMessage: document.getElementById('final-winner-message'),
        finalScoreList: document.getElementById('final-score-list'),
        mainMenuButton: document.getElementById('main-menu-button'),
        mainMenuButtonFinal: document.getElementById('main-menu-button-final'),
        messageModal: document.getElementById('message-modal'),
        messageText: document.getElementById('message-text'),
        messageOkButton: document.getElementById('message-ok-button'),
        gameLog: document.getElementById('game-log'),
        handValueDisplay: document.getElementById('hand-value-display'),
    };
    
    // --- Firebase & Game State ---
    let db, auth, analytics;
    let currentGameId = null;
    let currentPlayerId = null;
    let localGameState = {}; // Local copy of the game state from Firestore
    let unsubscribeGameListener = null; // To stop listening to game updates

    const SPINNER_VALUE = -1;
    const BOARD_SIZE = 2500;
    const DOMINO_WIDTH = 80;
    const DOMINO_HEIGHT = 40;
    
    // --- Interaction State ---
    let isDraggingDomino = false;
    let wasDragged = false;
    let dragStartPos = { x: 0, y: 0 };
    let dragStartTime = 0;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let boardPosition = { x: 0, y: 0 };
    let zoomLevel = 1.0;
    const MIN_ZOOM = 0.3;
    const MAX_ZOOM = 3.0;
    let dominoOffsetX = 0;
    let dominoOffsetY = 0;
    let initialPinchDistance = null;
    let activeDominoElement = null; // The visual element being dragged
    let draggedDominoData = null; // The data object for the domino being dragged
    let originalDominoElement = null; // The original domino element in the hand or on the board

    // --- Firebase Initialization ---
    async function initializeFirebase() {
        try {
            // WARNING: These keys are publicly exposed. For a production app,
            // you should use a more secure method like environment variables
            // and server-side functions to protect your Firebase project.
            const firebaseConfig = {
                apiKey: "AIzaSyCTmUo5UpQW77xhOkI_3XELSISo6WHyqLs",
                authDomain: "spinner-live.firebaseapp.com",
                projectId: "spinner-live",
                storageBucket: "spinner-live.appspot.com",
                messagingSenderId: "878930500451",
                appId: "1:878930500451:web:e281c28d5c29218044d156",
                measurementId: "G-BPHD3B8WDT"
            };
            
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            analytics = getAnalytics(app);

            dom.authStatus.textContent = 'Authenticating...';
            
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    // User is signed in.
                    currentPlayerId = user.uid;
                    enableLobby();
                } else {
                    // User is signed out. Attempt to sign in anonymously.
                    await signInAnonymously(auth);
                }
            });
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            dom.authStatus.textContent = "Error: Could not connect. Please refresh.";
            showMessage(`Firebase Error: ${error.message}`);
        }
    }
    
    function showMessage(message) {
        dom.messageText.textContent = message;
        dom.messageModal.classList.remove('hidden');
    }

    dom.messageOkButton.addEventListener('click', () => {
        dom.messageModal.classList.add('hidden');
    });
    
    function enableLobby() {
        dom.authStatus.textContent = 'Ready to Play!';
        dom.loadingScreen.classList.add('hidden');
        dom.setupScreen.classList.remove('hidden');
        dom.createGameButton.disabled = false;
        dom.joinGameButton.disabled = false;
    }

    // --- Lobby and Game Setup ---
    dom.createGameButton.addEventListener('click', async () => {
        if (!currentPlayerId) return;
        const playerName = dom.playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;
        
        // Generate a random, more unique game ID
        const tempGameRef = doc(collection(db, 'games'));
        const gameId = tempGameRef.id.substring(0, 6).toUpperCase();
        const gameRef = doc(db, "games", gameId);

        const initialGameState = {
            players: {
                [currentPlayerId]: { name: playerName, score: 0, hand: [], isHost: true }
            },
            playerOrder: [currentPlayerId],
            gameStatus: 'waiting', // 'waiting', 'in-progress', 'round-over', 'finished'
            boardDominos: [],
            boneyard: [],
            currentPlayerIndex: 0,
            roundNumber: 0,
            currentStartingDouble: 9,
            turnState: 'WAITING', // 'WAITING', 'PLACED'
            mustDrawToStart: false,
            lastPlayedDominoId: null,
            passCount: 0,
            moveHistory: [],
            log: [], // NEW: For game log
            currentTheme: 'classic',
            actionStatus: null, // To show what other players are doing
            createdAt: serverTimestamp()
        };

        await setDoc(gameRef, initialGameState);
        await joinGame(gameId);
    });

    dom.joinGameButton.addEventListener('click', async () => {
        if (!currentPlayerId) return;
        const gameId = dom.joinGameIdInput.value.trim().toUpperCase();
        const playerName = dom.playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;
        if (!gameId || !playerName) {
            showMessage("Please enter your name and a Game ID.");
            return;
        }

        const gameRef = doc(db, "games", gameId);
        const gameSnap = await getDoc(gameRef);

        if (!gameSnap.exists()) {
            showMessage("Game not found. Please check the ID.");
            return;
        }
        
        const gameData = gameSnap.data();
        if(Object.keys(gameData.players).length >= 8) {
            showMessage("This game is full (max 8 players).");
            return;
        }
        
        if(gameData.gameStatus !== 'waiting') {
            showMessage("This game has already started.");
            return;
        }

        await updateDoc(gameRef, {
            [`players.${currentPlayerId}`]: { name: playerName, score: 0, hand: [], isHost: false },
            playerOrder: [...gameData.playerOrder, currentPlayerId]
        });
        
        await joinGame(gameId);
    });

    async function joinGame(gameId) {
        currentGameId = gameId;
        dom.lobbyView.classList.add('hidden');
        dom.waitingRoomView.classList.remove('hidden');
        dom.gameIdDisplay.textContent = gameId;
        
        if (unsubscribeGameListener) unsubscribeGameListener();
        unsubscribeGameListener = onSnapshot(doc(db, "games", currentGameId), (docSnap) => {
            if (docSnap.exists()) {
                handleGameStateUpdate(docSnap.data());
            } else {
                showMessage("The game has ended or was deleted.");
                leaveGame();
            }
        });
    }

    function leaveGame() {
        window.location.reload();
    }
    dom.mainMenuButton.addEventListener('click', leaveGame);
    dom.mainMenuButtonFinal.addEventListener('click', leaveGame);

    dom.copyGameIdButton.addEventListener('click', () => {
        navigator.clipboard.writeText(currentGameId).then(() => {
            dom.copyGameIdButton.textContent = 'Copied!';
            setTimeout(() => { dom.copyGameIdButton.textContent = 'Copy'; }, 2000);
        }).catch(err => {
            console.error('Failed to copy text: ', err);
             // Fallback for older browsers / insecure contexts
            const textArea = document.createElement("textarea");
            textArea.value = currentGameId;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                dom.copyGameIdButton.textContent = 'Copied!';
            } catch (err) {
                dom.copyGameIdButton.textContent = 'Failed!';
            }
            document.body.removeChild(textArea);
            setTimeout(() => { dom.copyGameIdButton.textContent = 'Copy'; }, 2000);
        });
    });

    dom.startGameButton.addEventListener('click', () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            startRound();
        }
    });
    dom.reDealButton.addEventListener('click', () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            startRound();
        }
    });

    // --- Main Game State Handler ---
    function handleGameStateUpdate(gameState) {
        const oldTheme = localGameState.currentTheme;
        const wasWaiting = localGameState.gameStatus === 'waiting';

        localGameState = gameState;
        
        // Guard against incomplete data during initial load
        if (!gameState.players || !gameState.playerOrder || gameState.playerOrder.length === 0) {
            console.log("Waiting for complete game state...");
            return;
        }

        const playerIds = gameState.playerOrder;
        const playerCount = playerIds.length;
        const isHost = gameState.players[currentPlayerId]?.isHost;

        if (gameState.gameStatus === 'waiting') {
            dom.playerList.innerHTML = '';
            playerIds.forEach(pid => {
                const p = document.createElement('p');
                p.textContent = `${gameState.players[pid].name} ${gameState.players[pid].isHost ? '(Host)' : ''}`;
                dom.playerList.appendChild(p);
            });
            
            const canStart = isHost && playerCount >= 2 && playerCount <= 8;
            dom.startGameButton.disabled = !canStart;
            dom.reDealButton.classList.toggle('hidden', true);

            if (isHost) {
                if (playerCount < 2) {
                    dom.waitingMessage.textContent = "Need at least 2 players to start.";
                } else if (playerCount > 8) {
                    dom.waitingMessage.textContent = "Cannot start with more than 8 players.";
                } else {
                    dom.waitingMessage.textContent = "You're the host. Start the game when ready!";
                }
            } else {
                dom.waitingMessage.textContent = "Waiting for the host to start the game...";
            }

            dom.waitingRoomView.classList.remove('hidden');
            dom.setupScreen.classList.remove('hidden');
            dom.gameContainer.classList.add('hidden');

        } else if (gameState.gameStatus === 'in-progress' || gameState.gameStatus === 'round-over' || gameState.gameStatus === 'finished') {
            dom.setupScreen.classList.add('hidden');
            dom.gameContainer.classList.remove('hidden');
            if (oldTheme !== gameState.currentTheme) {
                dom.themeSwitcher.value = gameState.currentTheme;
            }
            if (wasWaiting && gameState.gameStatus === 'in-progress') {
                centerBoardOnStart();
            }
            dom.reDealButton.classList.toggle('hidden', !isHost);
            renderGameUI(gameState);
        }
        
        if (gameState.gameStatus === 'round-over') {
            displayRoundEndScreen(gameState);
        } else {
            dom.roundEndScreen.classList.add('hidden');
        }

        if (gameState.gameStatus === 'finished') {
            showFinalScores(gameState);
        } else {
            dom.gameOverScreen.classList.add('hidden');
        }
    }
    
    // --- Core Game Logic ---
    function generateDeck() {
        const deck = [];
        for (let i = 0; i <= 9; i++) {
            for (let j = i; j <= 9; j++) deck.push({ top: i, bottom: j, id: `d-${i}-${j}` });
        }
        for (let i = 0; i <= 9; i++) deck.push({ top: SPINNER_VALUE, bottom: i, id: `s-${i}` });
        deck.push({ top: SPINNER_VALUE, bottom: SPINNER_VALUE, id: 'd-s-s' });
        return deck;
    }

    function shuffle(deck) {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    }
    
    async function startRound() {
        const gameRef = doc(db, "games", currentGameId);
        
        await runTransaction(db, async (transaction) => {
            const gameSnap = await transaction.get(gameRef);
            if (!gameSnap.exists()) throw "Game does not exist!";
            
            const currentData = gameSnap.data();
            const playerIds = currentData.playerOrder;
            const numPlayers = playerIds.length;

            const deck = generateDeck();
            shuffle(deck);

            const dominoesPerPlayer = numPlayers <= 4 ? 7 : 5;
            const updatedPlayers = { ...currentData.players };

            playerIds.forEach(pid => {
                updatedPlayers[pid].hand = deck.splice(0, dominoesPerPlayer);
            });

            const newRoundNumber = currentData.roundNumber + 1;
            const newStartingDouble = 9 - ((newRoundNumber - 1) % 10);

            let newPlayerIndex;
            let newMustDraw = false;

            // Determine starter based on previous winner, or find the player with the required double.
            if (currentData.roundNumber > 0 && currentData.roundEndInfo?.winnerId) {
                newPlayerIndex = playerIds.indexOf(currentData.roundEndInfo.winnerId);
                if (newPlayerIndex === -1) { // Fallback if winner left
                    const starterInfo = findRoundStarter(updatedPlayers, playerIds, newStartingDouble);
                    newPlayerIndex = starterInfo.playerIndex;
                    newMustDraw = starterInfo.mustDraw;
                }
            } else {
                const starterInfo = findRoundStarter(updatedPlayers, playerIds, newStartingDouble);
                newPlayerIndex = starterInfo.playerIndex;
                newMustDraw = starterInfo.mustDraw;
            }

            transaction.update(gameRef, {
                gameStatus: 'in-progress',
                players: updatedPlayers,
                boneyard: deck,
                boardDominos: [],
                roundNumber: newRoundNumber,
                currentStartingDouble: newStartingDouble,
                currentPlayerIndex: newPlayerIndex,
                mustDrawToStart: newMustDraw,
                turnState: 'WAITING',
                lastPlayedDominoId: null,
                passCount: 0,
                moveHistory: [],
                log: [`Round ${newRoundNumber} started. Waiting for ${updatedPlayers[playerIds[newPlayerIndex]].name}.`],
                roundEndInfo: null
            });
        });
    }
    
    function findRoundStarter(players, playerOrder, requiredDoubleValue) {
        let starterIndex = -1;
        let mustDraw = false;

        const hasSpecificDouble = (hand, val) => hand.some(d => d.top === val && d.bottom === val);
        const hasDoubleSpinner = (hand) => hand.some(d => d.top === SPINNER_VALUE && d.bottom === SPINNER_VALUE);

        // Find player with the required double for the round
        for (let i = 0; i < playerOrder.length; i++) {
            const pid = playerOrder[i];
            if (hasSpecificDouble(players[pid].hand, requiredDoubleValue)) {
                starterIndex = i;
                break;
            }
        }
        // If no one has it, find player with the double spinner
        if (starterIndex === -1) {
            for (let i = 0; i < playerOrder.length; i++) {
                const pid = playerOrder[i];
                if (hasDoubleSpinner(players[pid].hand)) {
                    starterIndex = i;
                    break;
                }
            }
        }
        // If no one has either, find player with the highest hand value
        if (starterIndex === -1) {
            let highestScore = -1;
            for (let i = 0; i < playerOrder.length; i++) {
                const pid = playerOrder[i];
                const handValue = calculateHandValue(players[pid].hand);
                if (handValue > highestScore) {
                    highestScore = handValue;
                    starterIndex = i;
                }
            }
            mustDraw = true;
        }
        
        return { playerIndex: starterIndex, mustDraw };
    }
    
    async function drawFromBoneyard() {
        const gameRef = doc(db, "games", currentGameId);
        
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw "Game does not exist!";
                const gameState = gameSnap.data();

                const currentTurnPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
                if (currentPlayerId !== currentTurnPlayerId || gameState.turnState === 'PLACED' || gameState.boneyard.length === 0) {
                    return;
                }

                const boneyard = [...gameState.boneyard];
                const drawnDomino = boneyard.pop();
                
                const updatedPlayers = { ...gameState.players };
                updatedPlayers[currentPlayerId].hand.push(drawnDomino);
                
                const newLog = [...(gameState.log || [])];
                newLog.push(`${updatedPlayers[currentPlayerId].name} drew from the boneyard.`);
                if (newLog.length > 5) newLog.shift(); // Keep log size manageable

                transaction.update(gameRef, {
                    players: updatedPlayers,
                    boneyard: boneyard,
                    turnState: 'PLACED',
                    log: newLog
                });
            });
        } catch (error) {
            console.error("Error drawing from boneyard:", error);
            showMessage("Could not draw a domino. Please try again.");
        }
    }
    dom.boneyardPileElement.addEventListener('click', drawFromBoneyard);
    dom.boneyardPileElement.addEventListener('touchstart', (e) => {
        e.preventDefault();
        drawFromBoneyard();
    }, { passive: false });


    async function confirmTurn() {
        const gameRef = doc(db, "games", currentGameId);
        await runTransaction(db, async (transaction) => {
            const gameSnap = await transaction.get(gameRef);
            if (!gameSnap.exists()) throw "Game does not exist!";
            const gameState = gameSnap.data();

            const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.playerOrder.length;
            const nextPlayerName = gameState.players[gameState.playerOrder[nextPlayerIndex]].name;
            const newLog = [...(gameState.log || [])];
            newLog.push(`It's now ${nextPlayerName}'s turn.`);
            if (newLog.length > 5) newLog.shift();

            transaction.update(gameRef, {
                currentPlayerIndex: nextPlayerIndex,
                turnState: 'WAITING',
                moveHistory: [], // Clear history for the next player
                lastPlayedDominoId: null, // Clear the last played domino
                log: newLog
            });
        });
    }
    dom.endTurnButton.addEventListener('click', confirmTurn);
    
    function calculateHandValue(hand) {
        return hand.reduce((total, domino) => {
            const topValue = domino.top === SPINNER_VALUE ? 10 : domino.top;
            const bottomValue = domino.bottom === SPINNER_VALUE ? 10 : domino.bottom;
            return total + topValue + bottomValue;
        }, 0);
    }

    dom.continueRoundButton.addEventListener('click', () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            startRound();
        }
    });

    // --- UI Rendering ---
    function renderGameUI(gameState) {
        const currentTurnPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
        const isMyTurn = currentPlayerId === currentTurnPlayerId;
        
        dom.gameBoardElement.querySelectorAll('.domino').forEach(d => d.remove());
        gameState.boardDominos.forEach(domino => {
            const el = createDomino(domino.dominoData);
            el.style.position = 'absolute';
            el.style.left = `${domino.x}px`;
            el.style.top = `${domino.y}px`;
            el.style.transform = `rotate(${domino.rotation}deg)`;
            el.dataset.rotation = domino.rotation;
            el.dataset.id = domino.dominoData.id;
            
            // Only the current player can move dominoes on the board
            if (isMyTurn) {
                el.addEventListener('mousedown', (e) => startDominoDrag(e, domino, 'board'));
                el.addEventListener('touchstart', (e) => startDominoDrag(e, domino, 'board'), { passive: false });
            }
            dom.gameBoardElement.appendChild(el);
        });
        updateMinimap(gameState.boardDominos);

        dom.playerHandsContainer.innerHTML = ''; // Clear the entire left column
        dom.scoreboard.innerHTML = '';
        
        renderPlayerHands(gameState);
        renderGameLog(gameState.log);

        gameState.playerOrder.forEach(pid => {
            renderScoreboardEntry(gameState.players[pid], pid);
        });
        
        // ADDED: Update hand value tally
        const myPlayerData = gameState.players[currentPlayerId];
        if (myPlayerData) {
            const handValue = calculateHandValue(myPlayerData.hand);
            dom.handValueDisplay.textContent = handValue;
        }

        renderBoneyard(gameState.boneyard, isMyTurn, gameState.turnState);
        dom.currentPlayerElement.textContent = gameState.players[currentTurnPlayerId].name;
        
        // Update status text
        let statusText = '';
        if (gameState.actionStatus) {
            statusText = gameState.actionStatus;
        } else if (isMyTurn) {
            if(gameState.mustDrawToStart) {
                statusText = "You have the highest hand. Draw to find the starting double.";
            } else if (gameState.boardDominos.length === 0) {
                statusText = `You must play the Double ${gameState.currentStartingDouble} or Double Spinner.`;
            } else if (gameState.turnState === 'WAITING') {
                statusText = "Your turn. Play a domino or draw from the boneyard.";
            } else if (gameState.turnState === 'PLACED') {
                statusText = "You've played or drawn. You can adjust tiles or end your turn.";
            }
        } else {
            statusText = `Waiting for ${gameState.players[currentTurnPlayerId].name} to play...`;
        }
        dom.gameStatusElement.textContent = statusText;

        // Update UI controls based on state
        dom.endTurnButton.disabled = !(isMyTurn && gameState.turnState === 'PLACED');
        dom.undoButton.disabled = !(isMyTurn && (gameState.moveHistory || []).length > 0);
        dom.rotateLastTileButton.classList.toggle('hidden', !(isMyTurn && gameState.turnState === 'PLACED' && gameState.lastPlayedDominoId));
        dom.boneyardPileElement.style.cursor = (isMyTurn && gameState.turnState === 'WAITING' && gameState.boneyard.length > 0) ? 'pointer' : 'not-allowed';
        dom.boneyardPileElement.classList.toggle('can-draw', isMyTurn && gameState.turnState === 'WAITING' && gameState.boneyard.length > 0);
    }

    function renderPlayerHands(gameState) {
        const playerOrder = gameState.playerOrder;
        const currentTurnPlayerId = playerOrder[gameState.currentPlayerIndex];
        
        // Create a new display order with the current player first
        const myIndex = playerOrder.indexOf(currentPlayerId);
        const displayOrder = [...playerOrder.slice(myIndex), ...playerOrder.slice(0, myIndex)];

        displayOrder.forEach(playerId => {
            const playerData = gameState.players[playerId];
            const isCurrentPlayer = playerId === currentPlayerId;
            const isTurn = playerId === currentTurnPlayerId;

            const section = document.createElement('div');
            section.className = 'player-hand-section';
            if (isTurn) {
                section.classList.add('flashing-border');
            }

            const title = document.createElement('h3');
            title.className = 'font-bold text-center mb-2 text-sm';
            title.textContent = `${playerData.name} ${isCurrentPlayer ? '(You)' : ''} (${playerData.hand.length})`;

            const handDiv = document.createElement('div');
            handDiv.className = 'player-hand-content';

            if (isCurrentPlayer) {
                // Render my hand with full dominoes
                playerData.hand.forEach(dominoData => {
                    const dominoElement = createDomino(dominoData);
                    dominoElement.dataset.id = dominoData.id;
                    if (isTurn && !gameState.lastPlayedDominoId) {
                        dominoElement.addEventListener('mousedown', (e) => startDominoDrag(e, { dominoData }, 'hand'));
                        dominoElement.addEventListener('touchstart', (e) => startDominoDrag(e, { dominoData }, 'hand'), { passive: false });
                    } else {
                        dominoElement.style.cursor = 'not-allowed';
                    }
                    handDiv.appendChild(dominoElement);
                });
            } else {
                // Render opponent hands with blank mini dominoes
                playerData.hand.forEach(() => {
                    const dominoElement = createDomino(null, true, 'mini');
                    handDiv.appendChild(dominoElement);
                });
            }
            
            section.appendChild(title);
            section.appendChild(handDiv);
            dom.playerHandsContainer.appendChild(section);
        });
    }


    function renderScoreboardEntry(playerData, playerId) {
        const scoreEntry = document.createElement('p');
        scoreEntry.textContent = `${playerData.name}: ${playerData.score}`;
        dom.scoreboard.appendChild(scoreEntry);
    }
    
    function renderGameLog(log) {
        if (!log) return;
        dom.gameLog.innerHTML = '';
        log.forEach(entry => {
            const p = document.createElement('p');
            p.textContent = entry;
            dom.gameLog.appendChild(p);
        });
        dom.gameLog.scrollTop = dom.gameLog.scrollHeight; // Auto-scroll to the bottom
    }

    function renderBoneyard(boneyard, isMyTurn, turnState) {
        dom.boneyardStack.innerHTML = ''; // Clear previous state
        
        if (boneyard.length > 0) {
            const dominoDisplay = document.createElement('div');
            dominoDisplay.className = 'boneyard-domino-display';
            dom.boneyardStack.appendChild(dominoDisplay);
        }

        const existingMessage = document.getElementById('boneyard-message');
        if (existingMessage) existingMessage.remove();

        if (isMyTurn && turnState === 'WAITING' && boneyard.length > 0) {
            const message = document.createElement('div');
            message.id = 'boneyard-message';
            message.textContent = 'Click to Draw';
            dom.boneyardPileElement.appendChild(message);
        }

        dom.boneyardCountElement.textContent = boneyard.length;
    }
    
    function displayRoundEndScreen(gameState) {
        if (!gameState.roundEndInfo) return;
        
        if (gameState.gameStatus === 'finished') {
            dom.gameOverScreen.classList.remove('hidden');
            dom.gameContainer.classList.add('hidden');
            dom.roundEndScreen.classList.add('hidden');
            return;
        }

        dom.gameContainer.classList.add('hidden');
        dom.roundEndScreen.classList.remove('hidden');

        const { winnerId, points } = gameState.roundEndInfo;
        dom.roundEndTitle.textContent = `Round ${gameState.roundNumber} Over!`;
        dom.roundWinnerMessage.textContent = `${gameState.players[winnerId].name} wins the round with 0 points!`;

        dom.roundResultsList.innerHTML = '';
        gameState.playerOrder.forEach(pid => {
            const p = document.createElement('p');
            const oldScore = gameState.players[pid].score - (points[pid] || 0);
            p.textContent = `${gameState.players[pid].name}: ${oldScore} + ${points[pid] || 0} points = ${gameState.players[pid].score} Total`;
            if (pid === winnerId) p.classList.add('winner');
            dom.roundResultsList.appendChild(p);
        });
        
        const isHost = gameState.players[currentPlayerId]?.isHost;
        dom.continueRoundButton.disabled = !isHost;
        dom.continueRoundButton.textContent = isHost ? "Start Next Round" : "Waiting for Host...";
    }

    function showFinalScores(gameState) {
        dom.gameContainer.classList.add('hidden');
        dom.roundEndScreen.classList.add('hidden');
        dom.gameOverScreen.classList.remove('hidden');

        const finalScores = gameState.playerOrder.map(pid => ({
            name: gameState.players[pid].name,
            score: gameState.players[pid].score
        })).sort((a, b) => a.score - b.score); // Sort by lowest score

        const winnerScore = finalScores[0].score;
        const winners = finalScores.filter(p => p.score === winnerScore);

        if (winners.length > 1) {
            dom.finalWinnerMessage.textContent = `It's a tie between ${winners.map(w => w.name).join(' and ')}!`;
        } else {
            dom.finalWinnerMessage.textContent = `${winners[0].name} wins the game!`;
        }

        dom.finalScoreList.innerHTML = '';
        finalScores.forEach(player => {
            const p = document.createElement('p');
            p.textContent = `${player.name}: ${player.score} points`;
            if (player.score === winnerScore) {
                p.classList.add('winner');
            }
            dom.finalScoreList.appendChild(p);
        });
    }

    function createDomino(dominoData, isBack = false, size = 'normal') {
        const dominoElement = document.createElement('div');
        dominoElement.className = 'domino';
        if (size === 'mini') {
            dominoElement.classList.add('mini-domino');
        }

        if (isBack) {
            dominoElement.classList.add('domino-back');
            return dominoElement;
        }
        
        dominoElement.appendChild(createPipContainer(dominoData.top, size));
        dominoElement.appendChild(document.createElement('div')).className = 'divider';
        dominoElement.appendChild(createPipContainer(dominoData.bottom, size));
        return dominoElement;
    }
    
    function createPipContainer(count, size = 'normal') {
        const container = document.createElement('div');
        container.className = 'pip-container';
        if (count === SPINNER_VALUE) {
            const iconContainer = document.createElement('div');
            iconContainer.className = 'spinner-icon';
            const theme = localGameState.currentTheme || 'classic';
            switch (theme) {
                case 'classic':
                    iconContainer.innerHTML = `<svg viewBox="0 0 24 24" class="w-full h-full"><g stroke="#B91C1C" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M 12 12 L 12 4 L 6 4" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(60 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(120 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(180 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(240 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(300 12 12)" /></g></svg>`;
                    break;
                case 'dr_edell': iconContainer.innerHTML = '<div></div><div></div>'; break;
                case 'austin': iconContainer.innerHTML = `<svg viewBox="0 0 24 24" class="w-full h-full"><path fill="#FFDE00" d="M12,2C6.48,2,2,6.48,2,12s4.48,10,10,10s10-4.48,10-10S17.52,2,12,2z"/><path fill="#000000" d="M8.5,10.5c0.83,0,1.5-0.67,1.5-1.5S9.33,7.5,8.5,7.5S7,8.17,7,9S7.67,10.5,8.5,10.5z M15.5,10.5c0.83,0,1.5-0.67,1.5-1.5S16.33,7.5,15.5,7.5S14,8.17,14,9S14.67,10.5,15.5,10.5z"/><path fill="#D9534F" d="M18,14c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S19.1,14,18,14z M6,14c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S7.1,14,6,14z"/><path fill="#000000" d="M12,15c-1.66,0-3-1.34-3-3h1c0,1.1,0.9,2,2,2s2-0.9,2-2h1C15,13.66,13.66,15,12,15z"/></svg>`; break;
                case 'rose': iconContainer.innerHTML = '<div></div><div></div>'; break;
                case 'anna': iconContainer.innerHTML = `<svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="300pt" height="155pt" viewBox="0 0 300 155" preserveAspectRatio="xMidYMid meet"><g transform="translate(0,155) scale(0.1,-0.1)" fill="red" stroke="red"><path d="M599 1217 c-92 -35 -157 -104 -182 -194 -7 -29 -17 -43 -28 -43 -26 0 -69 -39 -69 -64 0 -28 33 -64 65 -72 19 -5 28 -19 45 -68 42 -126 159 -271 285 -351 28 -18 83 -49 122 -69 l73 -36 87 44 c206 103 340 248 402 433 12 34 21 82 21 107 l0 45 45 7 c25 3 61 3 80 0 34 -7 35 -8 35 -52 0 -24 9 -73 21 -107 62 -185 196 -330 402 -433 l87 -44 81 41 c204 102 350 256 404 426 13 39 23 53 41 57 32 8 64 45 64 72 0 25 -43 64 -71 64 -11 0 -19 7 -19 18 0 29 -49 124 -80 153 -16 15 -48 38 -72 51 -87 46 -253 24 -324 -43 l-22 -21 -43 31 c-73 54 -177 74 -259 51 -84 -23 -167 -101 -185 -173 -6 -23 -9 -24 -43 -15 -20 6 -64 7 -97 4 l-60 -6 -24 51 c-73 152 -283 195 -430 88 l-43 -31 -22 21 c-60 56 -211 86 -287 58z m205 -42 c18 -8 38 -21 45 -29 7 -9 17 -13 22 -10 5 3 9 1 9 -4 0 -21 40 -19 71 4 35 26 113 52 177 58 43 5 125 -19 158 -47 25 -20 49 -47 48 -55 0 -10 15 -28 58 -73 31 -32 35 -39 23 -49 -8 -7 -15 -19 -15 -26 0 -8 -3 -14 -7 -14 -5 0 -9 -23 -11 -51 -1 -28 -9 -64 -17 -80 -8 -15 -15 -34 -15 -42 0 -8 -7 -20 -15 -27 -8 -7 -15 -21 -15 -31 0 -11 -3 -19 -8 -19 -4 0 -16 -17 -27 -37 -23 -43 -122 -143 -180 -181 -22 -15 -74 -45 -116 -66 l-77 -39 -58 29 c-33 15 -62 27 -66 26 -5 -1 -8 2 -8 8 0 5 -6 10 -13 10 -8 0 -22 9 -32 20 -10 11 -23 20 -29 20 -7 0 -19 8 -27 18 -8 9 -38 38 -65 63 -43 40 -109 125 -107 139 0 3 -8 16 -18 29 -10 12 -21 38 -25 56 -3 18 -14 42 -25 54 -10 11 -19 25 -19 31 0 5 -6 10 -12 10 -7 0 -21 11 -31 25 -17 24 -17 24 21 54 25 21 42 45 51 75 16 55 75 121 135 150 38 18 59 22 117 18 39 -2 85 -10 103 -17z m1211 -19 c63 -38 95 -45 114 -22 16 19 100 58 111 51 5 -3 11 -2 14 3 5 8 104 8 136 0 44 -11 144 -93 134 -110 -3 -4 -1 -8 4 -8 5 0 15 -19 23 -42 7 -24 31 -60 51 -80 l38 -37 -31 -30 c-17 -17 -35 -31 -40 -31 -5 0 -12 -12 -15 -27 -12 -51 -54 -133 -96 -190 -58 -79 -71 -93 -85 -93 -7 0 -12 -5 -10 -10 1 -6 -11 -18 -27 -28 -16 -9 -40 -26 -53 -37 -50 -43 -162 -100 -193 -99 -18 1 -50 12 -70 25 -8 5 -26 14 -39 19 -99 43 -264 205 -312 308 -44 93 -46 98 -58 177 -7 46 -16 74 -28 83 -15 11 -16 14 -3 22 8 5 17 7 21 5 3 -3 12 7 19 20 7 14 17 25 22 25 4 0 8 6 8 14 0 13 41 60 88 100 26 22 81 32 162 29 44 -1 68 -9 115 -37z"/><path d="M631 1138 c-74 -21 -118 -73 -140 -165 -16 -67 -4 -127 47 -232 56 -114 164 -217 315 -300 l57 -32 48 27 c26 15 56 32 67 38 195 107 340 346 304 501 -16 69 -33 100 -71 128 -82 59 -192 55 -268 -11 -38 -32 -77 -99 -65 -111 3 -3 8 5 12 17 3 12 9 22 13 22 4 0 11 11 14 25 4 14 13 25 21 25 8 0 15 4 15 9 0 18 86 51 134 51 69 0 117 -27 148 -85 51 -95 48 -184 -9 -291 -20 -38 -41 -74 -47 -80 -6 -7 -33 -37 -61 -68 -27 -31 -55 -56 -62 -56 -7 0 -18 -9 -25 -20 -7 -11 -16 -20 -21 -20 -4 0 -31 -16 -61 -36 -50 -33 -92 -41 -112 -21 -4 4 -14 7 -21 7 -8 0 -34 14 -58 30 -24 17 -48 30 -54 30 -6 0 -18 11 -27 25 -9 14 -20 25 -25 25 -36 0 -190 225 -173 252 4 6 3 8 -3 5 -11 -7 -23 45 -23 104 0 70 50 150 116 185 25 13 132 13 154 0 50 -30 95 -75 110 -110 12 -27 19 -34 19 -21 2 51 -76 129 -151 152 -50 15 -70 15 -117 1z"/><path d="M1820 1141 c-89 -27 -126 -69 -150 -168 -34 -147 92 -363 285 -486 130 -82 125 -81 189 -47 154 81 259 180 320 305 64 127 65 234 5 321 -68 99 -214 106 -312 15 -31 -28 -57 -72 -57 -93 1 -7 8 1 17 17 23 44 101 115 126 116 12 0 41 2 63 5 112 15 208 -113 188 -247 -6 -40 -58 -167 -74 -179 -3 -3 -16 -21 -28 -40 -11 -19 -34 -47 -50 -62 -23 -21 -32 -24 -43 -15 -11 10 -11 9 -2 -3 10 -13 -3 -25 -70 -73 -45 -31 -90 -57 -99 -57 -9 0 -19 -4 -23 -9 -6 -10 -158 65 -163 80 -2 5 -8 7 -13 3 -5 -3 -12 2 -15 10 -3 9 -11 16 -18 16 -38 0 -206 231 -192 266 3 8 1 14 -5 14 -6 0 -9 7 -5 15 3 8 1 15 -4 15 -14 0 -12 83 3 132 6 22 30 61 52 85 38 43 43 45 106 50 49 4 73 1 97 -11 42 -22 86 -66 108 -107 9 -19 19 -29 21 -22 14 40 -72 125 -149 148 -56 16 -70 17 -108 6z"/></g></svg>`; break;
                case 'kate': iconContainer.innerHTML = `<svg viewBox="0 0 100 100" class="w-full h-full"><rect x="10" y="25" width="80" height="50" rx="10" ry="10" fill="#F0C68C"/><path d="M 20 25 C 10 15, 10 5, 25 5 L 35 5 L 30 25 Z" fill="#6B4F4F"/><path d="M 80 25 C 90 15, 90 5, 75 5 L 65 5 L 70 25 Z" fill="#6B4F4F"/><circle cx="40" cy="45" r="5" fill="#2D2D2D"/><circle cx="60" cy="45" r="5" fill="#2D2D2D"/><path d="M 50 55 Q 45 60, 50 65 Q 55 60, 50 55 Z" fill="#2D2D2D"/><path d="M 35 70 C 40 65, 60 65, 65 70" stroke="#2D2D2D" stroke-width="3" fill="none"/><path d="M 30 35 Q 40 30, 50 35 Q 60 30, 70 35" stroke="#6B4F4F" stroke-width="2" fill="none"/></svg>`; break;
                default: iconContainer.textContent = 'S';
            }
            container.appendChild(iconContainer);
            return container;
        }
        const pipPositions = {1:[5],2:[1,9],3:[1,5,9],4:[1,3,7,9],5:[1,3,5,7,9],6:[1,2,3,7,8,9],7:[1,2,3,5,7,8,9],8:[1,2,3,4,6,7,8,9],9:[1,2,3,4,5,6,7,8,9]};
        for (let i = 1; i <= 9; i++) {
            const pipCell = document.createElement('div');
            if (pipPositions[count] && pipPositions[count].includes(i)) {
                const pip = document.createElement('div');
                pip.className = `pip pip-color-${count}`;
                pipCell.appendChild(pip);
            }
            container.appendChild(pipCell);
        }
        return container;
    }

    // --- Touch, Drag, Drop, and Rotation Logic ---
    function getEventCoords(e) {
        return e.touches?.[0] || e.changedTouches?.[0] || e;
    }

    async function updateActionStatus(text) {
        if (currentGameId) {
            const gameRef = doc(db, "games", currentGameId);
            await updateDoc(gameRef, { actionStatus: text });
        }
    }

    function startDominoDrag(e, dominoObject, origin) {
        e.stopPropagation();
        if (isDraggingDomino) return;

        const currentTurnPlayerId = localGameState.playerOrder[localGameState.currentPlayerIndex];
        if (currentPlayerId !== currentTurnPlayerId) return;
        
        if (origin === 'hand' && localGameState.lastPlayedDominoId) {
            showMessage("You have already played a tile. Please end your turn.");
            return;
        }
        if (origin === 'board' && localGameState.turnState !== 'PLACED') return;
        
        originalDominoElement = e.currentTarget;
        draggedDominoData = dominoObject;
        isDraggingDomino = true;
        wasDragged = false;
        dragStartTime = Date.now();
        
        const coords = getEventCoords(e);
        dragStartPos = { x: coords.clientX, y: coords.clientY };
        
        activeDominoElement = originalDominoElement.cloneNode(true);
        activeDominoElement.classList.add('dragging');
        document.body.appendChild(activeDominoElement);

        originalDominoElement.style.opacity = '0.3';

        // FIX: Determine the correct scale for the dragged element
        const dragScale = origin === 'hand' ? 1.0 : zoomLevel;

        const scaledWidth = DOMINO_WIDTH * dragScale;
        const scaledHeight = DOMINO_HEIGHT * dragScale;
        const initialLeft = coords.clientX - scaledWidth / 2;
        const initialTop = coords.clientY - scaledHeight / 2;
        activeDominoElement.style.transform = `translate(${initialLeft}px, ${initialTop}px) scale(${dragScale})`;

        updateActionStatus(`${localGameState.players[currentPlayerId].name} is moving a tile...`);
        
        // Use named functions for easy removal and pass the dragScale
        const moveHandler = (ev) => dragDomino(ev, dragScale);
        const endHandler = (ev) => endDominoDrag(ev, origin, moveHandler, endHandler);

        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endHandler, { once: true });
        document.addEventListener('touchmove', moveHandler, { passive: false });
        document.addEventListener('touchend', endHandler, { once: true });
    }

    function dragDomino(e, dragScale) { // Added dragScale parameter
        if (!isDraggingDomino || !activeDominoElement) return;
        e.preventDefault();
        const coords = getEventCoords(e);
        if (Math.abs(coords.clientX - dragStartPos.x) > 5 || Math.abs(coords.clientY - dragStartPos.y) > 5) {
            wasDragged = true;
        }
        
        // Use the passed dragScale
        const scaledWidth = DOMINO_WIDTH * dragScale;
        const scaledHeight = DOMINO_HEIGHT * dragScale;
        const newLeft = coords.clientX - scaledWidth / 2;
        const newTop = coords.clientY - scaledHeight / 2;
        activeDominoElement.style.transform = `translate(${newLeft}px, ${newTop}px) scale(${dragScale})`;
    }

    async function endDominoDrag(e, origin, moveHandler, endHandler) {
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('touchmove', moveHandler);
        
        // BUG FIX: The action status should only be cleared inside the transaction
        // updateActionStatus(null); 

        if (!isDraggingDomino) return;
        
        const gameRef = doc(db, "games", currentGameId);
        const dragDuration = Date.now() - dragStartTime;
        const isTap = !wasDragged && dragDuration < 200;

        if (isTap && origin === 'board') {
            const currentRotation = parseInt(draggedDominoData.rotation || 0);
            const newRotation = (currentRotation + 45) % 360;

            if (originalDominoElement) {
                originalDominoElement.style.transform = `rotate(${newRotation}deg)`;
                originalDominoElement.dataset.rotation = newRotation;
            }

            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw "Game does not exist!";
                const gameState = gameSnap.data();
                let newMoveHistory = [...(gameState.moveHistory || [])];
                const newBoardDominos = [...gameState.boardDominos];
                const boardIndex = newBoardDominos.findIndex(d => d.dominoData.id === draggedDominoData.dominoData.id);
                if (boardIndex > -1) {
                    newMoveHistory.push({ type: 'rotate', dominoId: draggedDominoData.dominoData.id, from: newBoardDominos[boardIndex].rotation });
                    newBoardDominos[boardIndex].rotation = newRotation;
                    // Also clear action status here
                    transaction.update(gameRef, { boardDominos: newBoardDominos, moveHistory: newMoveHistory, actionStatus: null });
                }
            });
        } else if (wasDragged) {
            const coords = getEventCoords(e);
            const worldRect = dom.worldElement.getBoundingClientRect();

            if (origin === 'hand' && (coords.clientX < worldRect.left || coords.clientX > worldRect.right || coords.clientY < worldRect.top || coords.clientY > worldRect.bottom)) {
                // Dropped outside, clear action status without making a move
                await updateActionStatus(null);
            } else {
                const mouseXOnBoard = (coords.clientX - worldRect.left) / zoomLevel + boardPosition.x;
                const mouseYOnBoard = (coords.clientY - worldRect.top) / zoomLevel + boardPosition.y;
                
                const finalXOnBoard = mouseXOnBoard - (DOMINO_WIDTH / 2);
                const finalYOnBoard = mouseYOnBoard - (DOMINO_HEIGHT / 2);
                
                let newX = finalXOnBoard;
                let newY = finalYOnBoard;
                let newRotation = parseInt(originalDominoElement.dataset.rotation || 0);
                
                let isValidPlacement = true;
                if (localGameState.boardDominos.length === 0) {
                    const d = draggedDominoData.dominoData;
                    const required = localGameState.currentStartingDouble;
                    const isCorrectDouble = d.top === required && d.bottom === required;
                    const isDoubleSpinner = d.top === SPINNER_VALUE && d.bottom === SPINNER_VALUE;
                    if (!isCorrectDouble && !isDoubleSpinner) {
                        isValidPlacement = false;
                        showMessage(`Must start with Double ${required} or Double Spinner!`);
                        await updateActionStatus(null); // Clear status on invalid move
                    } else {
                        newX = (BOARD_SIZE / 2) - (DOMINO_WIDTH / 2);
                        newY = (BOARD_SIZE / 2) - (DOMINO_HEIGHT / 2) + 20; // Adjusted for visual centering
                        newRotation = 90;
                    }
                }

                if (isValidPlacement) {
                    try {
                        await runTransaction(db, async (transaction) => {
                            const gameSnap = await transaction.get(gameRef);
                            if (!gameSnap.exists()) throw "Game does not exist!";
                            const gameState = gameSnap.data();
                            
                            let newBoardDominos = [...gameState.boardDominos];
                            let updatedPlayers = { ...gameState.players };
                            let newLog = [...(gameState.log || [])];
                            let newMoveHistory = [...(gameState.moveHistory || [])];

                            if (origin === 'hand') {
                                const playerHand = updatedPlayers[currentPlayerId].hand;
                                const handIndex = playerHand.findIndex(d => d.id === draggedDominoData.dominoData.id);
                                if (handIndex > -1) {
                                    const playedDomino = playerHand.splice(handIndex, 1)[0];
                                    newBoardDominos.push({ dominoData: playedDomino, x: newX, y: newY, rotation: newRotation });
                                    
                                    newLog.push(`${updatedPlayers[currentPlayerId].name} played a tile.`);
                                    if (newLog.length > 5) newLog.shift();

                                    if (playerHand.length === 0) {
                                        const winnerPlayerId = currentPlayerId;
                                        let roundPoints = {};
                                        Object.keys(updatedPlayers).forEach(pid => {
                                            if (pid !== winnerPlayerId) {
                                                const handValue = calculateHandValue(updatedPlayers[pid].hand);
                                                updatedPlayers[pid].score += handValue;
                                                roundPoints[pid] = handValue;
                                            } else {
                                                roundPoints[pid] = 0;
                                            }
                                        });
                                        const isGameOver = gameState.roundNumber >= 10;
                                        transaction.update(gameRef, {
                                            boardDominos: newBoardDominos,
                                            players: updatedPlayers,
                                            gameStatus: isGameOver ? 'finished' : 'round-over',
                                            roundEndInfo: { winnerId: winnerPlayerId, points: roundPoints },
                                            turnState: 'WAITING',
                                            log: newLog,
                                            actionStatus: null
                                        });
                                    } else {
                                        transaction.update(gameRef, {
                                            boardDominos: newBoardDominos,
                                            players: updatedPlayers,
                                            turnState: 'PLACED',
                                            moveHistory: [],
                                            lastPlayedDominoId: playedDomino.id,
                                            log: newLog,
                                            actionStatus: null
                                        });
                                    }
                                }
                            } else { // origin === 'board'
                                const boardIndex = newBoardDominos.findIndex(d => d.dominoData.id === draggedDominoData.dominoData.id);
                                if (boardIndex > -1) {
                                    newMoveHistory.push({ type: 'reposition', dominoId: draggedDominoData.dominoData.id, from: { x: newBoardDominos[boardIndex].x, y: newBoardDominos[boardIndex].y } });
                                    newBoardDominos[boardIndex].x = newX;
                                    newBoardDominos[boardIndex].y = newY;
                                    transaction.update(gameRef, { boardDominos: newBoardDominos, moveHistory: newMoveHistory, actionStatus: null });
                                }
                            }
                        });
                    } catch (error) {
                        console.error("Error during placement transaction:", error);
                        showMessage("Error placing the domino. Please refresh.");
                    }
                }
            }
        } else {
            // It was not a drag, just a click, so clear the status
             await updateActionStatus(null);
        }
        
        // Cleanup drag elements
        if (originalDominoElement) originalDominoElement.style.opacity = '1';
        if (activeDominoElement) activeDominoElement.remove();
        activeDominoElement = null;
        originalDominoElement = null;
        draggedDominoData = null;
        isDraggingDomino = false;
    }

    // --- Pan and Zoom Logic ---
    function centerBoardOnStart() {
        zoomLevel = 1.0;
        boardPosition.x = (BOARD_SIZE / 2) - (dom.worldElement.clientWidth / 2);
        boardPosition.y = (BOARD_SIZE / 2) - (dom.worldElement.clientHeight / 2);
        updateBoardTransform();
    }

    function updateBoardTransform() {
        dom.gameBoardElement.style.transform = `translate(${-boardPosition.x}px, ${-boardPosition.y}px) scale(${zoomLevel})`;
        updateMinimap(localGameState.boardDominos || []);
    }
    
    function updateMinimap(boardDominos) {
        if (!dom.minimapContainer) return;
        const mapSize = dom.minimapContainer.clientWidth;
        const scale = mapSize / BOARD_SIZE;
        const viewWidth = dom.worldElement.clientWidth / zoomLevel;
        const viewHeight = dom.worldElement.clientHeight / zoomLevel;
        dom.minimapViewport.style.width = `${viewWidth * scale}px`;
        dom.minimapViewport.style.height = `${viewHeight * scale}px`;
        dom.minimapViewport.style.left = `${boardPosition.x * scale}px`;
        dom.minimapViewport.style.top = `${boardPosition.y * scale}px`;
        
        dom.minimapContainer.querySelectorAll('.minimap-dot').forEach(dot => dot.remove());
        boardDominos.forEach(domino => {
            const dot = document.createElement('div');
            dot.className = 'minimap-dot';
            dot.style.left = `${domino.x * scale}px`;
            dot.style.top = `${domino.y * scale}px`;
            dot.addEventListener('click', () => {
                boardPosition.x = domino.x - (viewWidth / 2) + (DOMINO_WIDTH / 2);
                boardPosition.y = domino.y - (viewHeight / 2) + (DOMINO_HEIGHT / 2);
                updateBoardTransform();
            });
            dom.minimapContainer.appendChild(dot);
        });
    }
    
    dom.worldElement.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // Only pan with left-click
        if (isDraggingDomino) return;
        // Ensure panning only starts on the background, not on other UI elements
        if (e.target !== dom.worldElement && e.target !== dom.gameBoardElement && e.target.id !== 'world-wrapper') return;
        
        isPanning = true;
        dom.worldElement.classList.add('panning');
        const coords = getEventCoords(e);
        panStart = { x: coords.clientX, y: coords.clientY };
        
        const panMove = (ev) => pan(ev);
        const endPanMove = () => endPan(panMove, endPanMove);

        document.addEventListener('mousemove', panMove);
        document.addEventListener('mouseup', endPanMove, { once: true });
    });

    function pan(e) {
        if (!isPanning) return;
        const coords = getEventCoords(e);
        const dx = coords.clientX - panStart.x;
        const dy = coords.clientY - panStart.y;
        boardPosition.x -= dx / zoomLevel;
        boardPosition.y -= dy / zoomLevel;
        panStart = { x: coords.clientX, y: coords.clientY };
        updateBoardTransform();
    }

    function endPan(panMove, endPanMove) {
        isPanning = false;
        dom.worldElement.classList.remove('panning');
        document.removeEventListener('mousemove', panMove);
        document.removeEventListener('mouseup', endPanMove);
    }
    
    dom.worldElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        handleZoom(e.deltaY * -0.01, e.clientX, e.clientY);
    }, { passive: false });

    dom.worldElement.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            isPanning = true;
            initialPinchDistance = getPinchDistance(e);
            panStart = getAverageTouch(e);
        } else if (e.touches.length === 1 && !isDraggingDomino) {
             // Handle single-touch panning
             if (e.target !== dom.worldElement && e.target !== dom.gameBoardElement && e.target.id !== 'world-wrapper') return;
             isPanning = true;
             dom.worldElement.classList.add('panning');
             const coords = getEventCoords(e);
             panStart = { x: coords.clientX, y: coords.clientY };
        }
    }, { passive: false });

    dom.worldElement.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 2 && isPanning) {
            // Pinch-to-zoom and pan
            const newPinchDistance = getPinchDistance(e);
            const zoomFactor = newPinchDistance / initialPinchDistance;
            handleZoom(zoomFactor - 1, panStart.x, panStart.y);
            initialPinchDistance = newPinchDistance;

            const newAvgTouch = getAverageTouch(e);
            const dx = newAvgTouch.x - panStart.x;
            const dy = newAvgTouch.y - panStart.y;
            boardPosition.x -= dx / zoomLevel;
            boardPosition.y -= dy / zoomLevel;
            panStart = newAvgTouch;
            updateBoardTransform();
        } else if (e.touches.length === 1 && isPanning) {
            // Single-touch pan
            pan(e);
        }
    }, { passive: false });

    dom.worldElement.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) {
            isPanning = false;
            initialPinchDistance = null;
            dom.worldElement.classList.remove('panning');
        }
    });

    function getPinchDistance(e) {
        const t1 = e.touches[0];
        const t2 = e.touches[1];
        return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));
    }

    function getAverageTouch(e) {
        const t1 = e.touches[0];
        const t2 = e.touches[1];
        return { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
    }

    function handleZoom(delta, clientX, clientY) {
        const rect = dom.worldElement.getBoundingClientRect();
        const mouseX = clientX - rect.left;
        const mouseY = clientY - rect.top;
        const worldX_before = (mouseX / zoomLevel) + boardPosition.x;
        const worldY_before = (mouseY / zoomLevel) + boardPosition.y;
        
        const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel * (1 + delta)));
        
        boardPosition.x = worldX_before - (mouseX / newZoom);
        boardPosition.y = worldY_before - (mouseY / newZoom);
        zoomLevel = newZoom;
        updateBoardTransform();
    }

    // --- Undo and Theme Logic ---
    dom.undoButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        await runTransaction(db, async (transaction) => {
            const gameSnap = await transaction.get(gameRef);
            if (!gameSnap.exists()) return;
            const gameState = gameSnap.data();
            if (!gameState.moveHistory || gameState.moveHistory.length === 0) return;

            const newMoveHistory = [...gameState.moveHistory];
            const lastMove = newMoveHistory.pop();
            const newBoardDominos = [...gameState.boardDominos];
            const dominoIndex = newBoardDominos.findIndex(d => d.dominoData.id === lastMove.dominoId);

            if (dominoIndex > -1) {
                if (lastMove.type === 'reposition') {
                    newBoardDominos[dominoIndex].x = lastMove.from.x;
                    newBoardDominos[dominoIndex].y = lastMove.from.y;
                } else if (lastMove.type === 'rotate') {
                    newBoardDominos[dominoIndex].rotation = lastMove.from;
                }
                transaction.update(gameRef, { boardDominos: newBoardDominos, moveHistory: newMoveHistory });
            }
        });
    });

    dom.rotateLastTileButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        const lastPlayedId = localGameState.lastPlayedDominoId;
        if (!lastPlayedId) return;

        const dominoEl = dom.gameBoardElement.querySelector(`.domino[data-id="${lastPlayedId}"]`);
        if (dominoEl) {
            const currentRotation = parseInt(dominoEl.dataset.rotation || 0);
            const newRotation = (currentRotation + 45) % 360;
            dominoEl.style.transform = `rotate(${newRotation}deg)`;
            dominoEl.dataset.rotation = newRotation;
        }

        await runTransaction(db, async (transaction) => {
            const gameSnap = await transaction.get(gameRef);
            if (!gameSnap.exists()) return;
            const gameState = gameSnap.data();
            if (!gameState.lastPlayedDominoId) return;

            const newBoardDominos = [...gameState.boardDominos];
            const boardIndex = newBoardDominos.findIndex(d => d.dominoData.id === gameState.lastPlayedDominoId);

            if (boardIndex > -1) {
                const currentRotation = newBoardDominos[boardIndex].rotation;
                const newRotation = (currentRotation + 45) % 360;
                newBoardDominos[boardIndex].rotation = newRotation;
                transaction.update(gameRef, { boardDominos: newBoardDominos });
            }
        });
    });

    dom.themeSwitcher.addEventListener('change', async (e) => {
        if (currentGameId) {
            const gameRef = doc(db, "games", currentGameId);
            await updateDoc(gameRef, { currentTheme: e.target.value });
        }
    });

    // --- Initial Load ---
    window.onload = initializeFirebase;
</script>
</body>
</html>
