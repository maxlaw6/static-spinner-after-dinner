<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
    <title>Spinner after Dinner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet"/>
    <style>
        /* General Body and Layout Styles */
        html, body {
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
        }
        body {
            font-family: 'Inter', sans-serif;
            user-select: none;
            -webkit-user-select: none; /* Safari */
            background-color: #3a2a21; /* Wood color */
            background-image: linear-gradient(rgba(0,0,0,0.2) 0 0.1em, transparent 0.1em 100%),
                              linear-gradient(90deg, rgba(0,0,0,0.2) 0 0.1em, transparent 0.1em 100%);
            background-size: 3em 3em;
        }
        
        /* Accessibility class */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Game World and Board Styles */
        #world {
            position: relative;
            overflow: hidden;
            cursor: grab;
            width: 100%;
            height: 100%;
            background-color: #004d25;
            background-image: radial-gradient(rgba(255, 255, 255, 0.03) 15%, transparent 0);
            background-size: 5px 5px;
            border-radius: 9999px; /* Make it a circle/oval */
            box-shadow: 0 0 0 15px #6b4f4f, 0 0 0 20px #4a3c31, inset 0 0 25px rgba(0,0,0,0.6);
            transition: background 0.5s ease;
        }
        #world::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border-radius: 9999px;
            background: radial-gradient(circle at center, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0) 60%);
            pointer-events: none;
        }
        #world.panning {
            cursor: grabbing;
        }
        #game-board {
            position: absolute;
            width: 4000px;
            height: 4000px;
            transform-origin: top left;
            will-change: transform; /* Performance hint for the browser */
        }
        #starting-area {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 44px;
            height: 84px;
            border: 2px dashed rgba(255, 255, 255, 0.4);
            border-radius: 8px;
        }

        /* Domino Styles */
        .domino {
            width: 80px;
            height: 40px;
            border: 1px solid #1a1a1a;
            background-color: #f5f5dc; /* Ivory */
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-radius: 6px;
            cursor: grab;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.3);
            transform-origin: center center;
            color: #1a1a1a;
            transition: all 0.25s ease;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on iOS */
        }
        .domino.domino-back {
            background-color: #f5f5dc;
            border: 1px solid #1a1a1a;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            position: relative;
        }
        .domino.domino-back::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 10%;
            height: 80%;
            width: 2px;
            background-color: rgba(0,0,0,0.1);
            transform: translateX(-50%);
        }
        .domino.dragging {
            cursor: grabbing;
            transition: none !important;
            z-index: 3000 !important;
            position: fixed !important;
            top: 0;
            left: 0;
            opacity: 0.95;
            pointer-events: none;
            transform-origin: center center; 
            will-change: transform;
            backface-visibility: hidden;
        }
        
        /* Mini Domino Styles for Opponent Hands */
        .mini-domino {
            width: 40px;
            height: 20px;
            border-radius: 3px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            cursor: default !important;
        }
        .mini-domino.domino-back::after {
            width: 1px;
        }

        /* Pip and Spinner Styles */
        .pip-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
            pointer-events: none;
        }
        .divider {
            width: 1.5px;
            height: 70%;
            background-color: #555;
            pointer-events: none;
            border-radius: 1px;
            box-shadow: inset 0 0 1px rgba(0,0,0,0.5);
        }
        .spinner-icon {
            width: 24px;
            height: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            line-height: 1.1;
        }
        .spinner-icon svg {
            width: 100%;
            height: 100%;
        }

        /* UI Components */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #boneyard-pile {
            border: 2px dashed #a0aec0;
            height: 60px;
            width: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            position: relative;
            border-radius: 8px;
            background-color: rgba(0,0,0,0.2);
        }
        #boneyard-pile:hover {
            background-color: rgba(255,255,255,0.1);
        }
        #boneyard-stack {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .boneyard-domino-display {
            width: 80px;
            height: 40px;
            border: 1px solid #a0aec0;
            background-color: #f7f7f7;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #boneyard-count {
            position: absolute;
            z-index: 10;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.6);
            padding: 2px 10px;
            border-radius: 12px;
            text-shadow: 0 0 5px #000;
        }
        #boneyard-message {
            position: absolute;
            z-index: 11;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 3px #000;
            pointer-events: none;
        }
        @keyframes flash-border {
            0%, 100% { border-color: #a0aec0; box-shadow: none; }
            50% { border-color: #FFD700; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        }
        .flashing-border {
            animation: flash-border 1.5s infinite;
        }
        #boneyard-pile.can-draw {
            animation: flash-border 1.5s infinite;
        }
        #minimap-container {
            position: absolute;
            top: 25px; /* Adjusted for table border */
            right: 25px; /* Adjusted for table border */
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            z-index: 2000;
            cursor: pointer;
        }
        #minimap-viewport {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }
        .minimap-dot {
            position: absolute;
            width: 8px;
            height: 4px;
            background-color: white;
            border-radius: 1px;
            pointer-events: auto;
            cursor: pointer;
            border: 1px solid white;
            box-shadow: 0 0 3px rgba(255,255,255,0.4); /* Reduced glow */
            transform-origin: center;
        }
        .player-hand-section {
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            transition: all 0.3s ease;
            background-color: rgba(0,0,0,0.3);
        }
        .player-hand-content {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
        }
        #setup-screen, #round-end-screen, #loading-screen, #game-over-screen, #message-modal, #round-start-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }
        #round-end-screen, #game-over-screen {
            z-index: 10001 !important; /* Ensure it's on top */
        }
        #setup-screen > div {
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        .hidden {
            display: none !important;
        }
        #final-score-display, #round-end-content, #message-modal-content, #round-start-content {
            background-color: rgba(31, 41, 55, 0.9);
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .winner {
            color: #FFD700;
            font-weight: bold;
        }

        /* --- LAYOUT STYLES --- */
        #game-container {
            height: 100%;
            width: 100%;
        }
        #game-layout {
            display: grid;
            grid-template-columns: 250px 1fr;
            grid-template-rows: auto 1fr;
            height: 100%;
            width: 100%;
            padding-left: calc(1rem + env(safe-area-inset-left));
            padding-right: calc(1rem + env(safe-area-inset-right));
            padding-top: calc(1rem + env(safe-area-inset-top));
            padding-bottom: calc(1rem + env(safe-area-inset-bottom));
            gap: 1rem;
            box-sizing: border-box;
        }
        #game-info { 
            grid-column: 1 / -1;
            grid-row: 1 / 2; 
        }
        #left-panel {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-height: 0;
        }
        #player-hands-container {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #boneyard-container {
            flex-shrink: 0;
        }
        #main-game-area {
            grid-column: 2 / 3;
            grid-row: 2 / 3;
            position: relative;
            display: grid;
            place-items: center;
            min-height: 0;
        }
        #main-game-area > * {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
        }
        #world-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #boneyard-buttons {
            flex-direction: row;
        }
        
        #game-log {
            background-color: rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 8px;
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #d1d5db;
            min-width: 150px;
        }

        /* --- ANIMATIONS & EFFECTS --- */
        @keyframes pending-glow {
            0%, 100% { box-shadow: 0 0 10px 2px rgba(74, 222, 128, 0.7); } /* green-400 */
            50% { box-shadow: 0 0 20px 5px rgba(74, 222, 128, 1); }
        }
        .pending-validation-glow {
            animation: pending-glow 1.5s infinite;
        }

        @keyframes thud {
            from { transform: scale(1.1); }
            to { transform: scale(1); }
        }
        .thud-animation {
            animation: thud 0.2s ease-out;
        }
        
        #particle-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 5000;
        }
        .particle {
            position: absolute;
            background-color: rgba(255, 215, 0, 0.7);
            border-radius: 50%;
            width: 5px;
            height: 5px;
            animation: burst 0.5s ease-out forwards;
        }
        @keyframes burst {
            0% { transform: translate(0, 0) scale(var(--start-scale, 1)); opacity: 1; }
            100% { transform: translate(var(--x), var(--y)) scale(0); opacity: 0; }
        }
        
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10002;
            overflow: hidden;
        }
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00;
            opacity: 0;
            animation: fall 3s linear forwards;
        }
        @keyframes fall {
            0% {
                transform: translateY(-10vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(110vh) rotate(720deg);
                opacity: 0;
            }
        }
        .ripple {
            position: absolute;
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: ripple-effect 0.7s ease-out forwards;
            pointer-events: none;
        }
        @keyframes ripple-effect {
            from {
                width: 0;
                height: 0;
                opacity: 1;
            }
            to {
                width: 200px;
                height: 200px;
                opacity: 0;
            }
        }

        /* --- DETAILED SCOREBOARD --- */
        #detailed-scoreboard-container {
            background-color: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            flex-shrink: 1;
            min-height: 100px;
            overflow-y: auto;
        }
        #detailed-scoreboard-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        #detailed-scoreboard-table th, #detailed-scoreboard-table td {
            padding: 4px 6px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        #detailed-scoreboard-table th {
            background-color: rgba(0,0,0,0.4);
            font-weight: bold;
        }
        #detailed-scoreboard-table .total-row td {
            font-weight: bold;
            background-color: rgba(31, 41, 55, 0.5); /* bg-gray-800 */
        }
        
        /* --- LOCAL PLAYER LIST --- */
        #local-player-list-item {
              display: flex;
              justify-content: space-between;
              align-items: center;
              background-color: #374151; /* bg-gray-700 */
              padding: 4px 8px;
              border-radius: 4px;
       }
       #local-player-list-item button {
              background-color: #ef4444; /* bg-red-500 */
              color: white;
              border: none;
              border-radius: 50%;
              width: 20px;
              height: 20px;
              font-weight: bold;
              line-height: 1;
              cursor: pointer;
       }


        @media (max-width: 1024px) {
            #game-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }
            #game-info { grid-row: 1 / 2; }
            #left-panel {
                grid-column: 1 / -1;
                grid-row: 2 / 3;
                flex-direction: row;
                overflow-x: auto;
                padding-bottom: 1rem;
            }
            #player-hands-container {
                flex-direction: row;
                flex-grow: 0;
            }
            .player-hand-section {
                flex-shrink: 0;
                width: 180px;
            }
            #boneyard-container {
                flex-shrink: 0;
            }
            #main-game-area {
                grid-column: 1 / -1;
                grid-row: 3 / 4;
            }
            #detailed-scoreboard-container {
                display: none; /* Hide detailed scoreboard on small screens for now */
            }
        }
    </style>
</head>
<body class="text-white">

<svg width="0" height="0" style="position:absolute;z-index:-1;">
    <defs>
        <radialGradient id="pipGradient" cx="50%" cy="50%" r="65%" fx="30%" fy="30%">
            <stop offset="0%" style="stop-color:rgba(255,255,255,0.4)" />
            <stop offset="100%" style="stop-color:rgba(0,0,0,0.4)" />
        </radialGradient>
    </defs>
</svg>

<!-- Message Modal -->
<div id="message-modal" class="hidden">
    <div id="message-modal-content" class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm">
        <p id="message-text" class="text-lg mb-4"></p>
        <button id="message-ok-button" class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-2 px-3 rounded transition-colors">OK</button>
    </div>
</div>

<!-- Loading Screen -->
<div id="loading-screen" class="flex items-center justify-center">
    <div class="text-center">
        <h1 class="text-3xl font-bold">Connecting to Game Service...</h1>
        <p id="auth-status">Initializing...</p>
    </div>
</div>

<!-- NEW: Round Start Screen -->
<div id="round-start-screen" class="hidden">
    <div id="round-start-content" class="w-full max-w-md">
        <h2 class="text-3xl font-bold text-center mb-4">Starting Round <span id="round-start-number"></span></h2>
        <p class="text-xl text-center mb-6">
            <span id="round-starter-name" class="text-yellow-300 font-bold"></span> has the starting tile!
        </p>
        <p id="round-start-wait-message" class="text-gray-400 mb-6">Waiting for them to start the round...</p>
        <button id="confirm-round-start-button" class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors hidden">
            Show Hand & Start Round
        </button>
    </div>
</div>

<!-- Pass Device Screen -->
<div id="pass-device-screen" class="hidden fixed top-0 left-0 w-full h-full bg-gray-900 bg-opacity-90 z-[10000] flex items-center justify-center backdrop-filter backdrop-blur-md">
    <div id="pass-device-content" class="bg-gray-800 p-8 rounded-lg shadow-xl text-center">
        <h2 class="text-3xl font-bold mb-4">Pass the Device to...</h2>
        <p id="next-player-name-pass" class="text-5xl font-bold text-yellow-300 mb-8"></p>
        <button id="confirm-turn-button" class="w-full bg-green-600 hover:bg-green-700 font-bold py-4 px-6 rounded transition-colors text-xl">Show My Hand & Start Turn</button>
    </div>
</div>

<!-- Setup / Lobby Screen -->
<div class="hidden" id="setup-screen">
    <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-white w-full max-w-md">
        <h1 class="text-3xl font-bold text-center mb-6">Spinner after Dinner</h1>
        
        <div id="lobby-view">
            <div class="mb-4">
                <label for="player-name" class="block mb-2">Your Name:</label>
                <input class="w-full p-2 rounded bg-gray-700 text-white" id="player-name" placeholder="Enter your name" type="text"/>
            </div>
            
            <!-- Create Game Flow -->
            <div id="create-game-flow">
                <label class="block mb-2">Game Mode:</label>
                <div class="flex gap-4 mb-6">
                    <button class="w-full bg-gray-600 font-bold py-3 px-4 rounded transition-colors" id="mode-online-button" disabled>Create Online Game</button>
                    <button class="w-full bg-gray-600 font-bold py-3 px-4 rounded transition-colors" id="mode-hybrid-button" disabled>Create Hybrid Game</button>
                </div>
            </div>

            <!-- Join Game Flow -->
            <div id="join-game-flow">
                 <div class="text-center my-4">OR</div>
                <div class="mb-4">
                    <label for="join-game-id" class="block mb-2">Join Existing Game:</label>
                    <input class="w-full p-2 rounded bg-gray-700 text-white" id="join-game-id" placeholder="Enter Game ID" type="text"/>
                </div>
                <button class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 px-4 rounded transition-colors" disabled id="join-game-button">Find Game</button>
            </div>

            <!-- Host's Local Player Setup View -->
            <div id="local-player-setup-view" class="hidden">
                <p class="text-center text-gray-400 mb-4">You (the host) are Player 1. Add other local players below.</p>
                <div class="mb-4">
                    <label for="local-player-name-input" class="block mb-2">Add Local Player:</label>
                    <div class="flex gap-2">
                        <input class="w-full p-2 rounded bg-gray-700 text-white" id="local-player-name-input" placeholder="Enter local player's name" type="text"/>
                        <button class="bg-blue-600 hover:bg-blue-700 font-bold py-2 px-4 rounded transition-colors" id="add-local-player-button">Add</button>
                    </div>
                </div>
                <div id="local-player-list" class="space-y-2 mb-6"></div>
                <button class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors" disabled id="create-hybrid-game-button">Create Hybrid Game</button>
                 <div class="text-center my-4"></div>
                 <button class="w-full bg-gray-500 hover:bg-gray-600 font-bold py-3 px-4 rounded transition-colors" id="back-to-mode-selection-button">Back</button>
            </div>

            <!-- NEW: Join Type Selection View -->
            <div id="join-type-selection-view" class="hidden">
                <h2 class="text-2xl font-bold text-center mb-4">How are you joining?</h2>
                <p class="text-center text-gray-400 mb-6">Joining game: <span id="join-type-game-id-display"></span></p>
                <div class="flex flex-col gap-4">
                    <button id="join-as-single-player-button" class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 px-4 rounded transition-colors">Join as Single Player</button>
                    <button id="join-as-group-button" class="w-full bg-purple-600 hover:bg-purple-700 font-bold py-3 px-4 rounded transition-colors">Join as a Local Group</button>
                    <button id="back-to-lobby-button" class="w-full bg-gray-500 hover:bg-gray-600 font-bold py-3 px-4 rounded transition-colors mt-4">Back</button>
                </div>
            </div>

            <!-- Joiner's Group Setup View -->
            <div id="join-group-setup-view" class="hidden">
                <h2 class="text-2xl font-bold text-center mb-4">Joining Game: <span id="joining-game-id-display"></span></h2>
                <p class="text-center text-gray-400 mb-4">You are Player 1 for your group. Add other local players from your device below.</p>
                 <div class="mb-4">
                    <label for="joiner-local-player-name-input" class="block mb-2">Add Local Player:</label>
                    <div class="flex gap-2">
                        <input class="w-full p-2 rounded bg-gray-700 text-white" id="joiner-local-player-name-input" placeholder="Enter local player's name" type="text"/>
                        <button class="bg-blue-600 hover:bg-blue-700 font-bold py-2 px-4 rounded transition-colors" id="add-joiner-local-player-button">Add</button>
                    </div>
                </div>
                <div id="joiner-local-player-list" class="space-y-2 mb-6"></div>
                <button class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors" id="confirm-join-group-button">Join Game with Group</button>
            </div>

        </div>

        <div class="hidden text-center" id="waiting-room-view">
            <h2 class="text-2xl font-bold mb-4">Waiting Room</h2>
            <p class="mb-2">Share this Game ID with others:</p>
            <div class="bg-gray-900 p-3 rounded-lg mb-4 flex items-center justify-center">
                <span class="text-2xl font-mono text-yellow-300" id="game-id-display"></span>
                <button class="ml-4 bg-gray-600 hover:bg-gray-500 text-sm py-1 px-2 rounded" id="copy-game-id">Copy</button>
            </div>
            <p class="mb-2 font-bold">Players Joined:</p>
            <div class="space-y-2 mb-6" id="player-list"></div>
            <p class="mb-4 text-gray-400" id="waiting-message">Waiting for more players...</p>
            <button class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors" disabled id="start-game-button">Start Game</button>
        </div>
    </div>
</div>

<!-- Round End Screen -->
<div class="hidden" id="round-end-screen">
    <div class="w-full max-w-md" id="round-end-content">
        <h2 class="text-3xl font-bold text-center mb-4" id="round-end-title">Round Over!</h2>
        <p class="text-xl text-yellow-300 mb-4" id="round-winner-message"></p>
        <div class="mb-6" id="round-results-list"></div>
        <button class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded transition-colors" id="continue-round-button">Continue</button>
    </div>
</div>

<!-- Game Over Screen -->
<div class="hidden" id="game-over-screen">
    <div class="w-full max-w-md" id="final-score-display">
        <h2 class="text-4xl font-bold text-center mb-4 text-yellow-300">Game Over!</h2>
        <p class="text-xl mb-6" id="final-winner-message"></p>
        <div class="space-y-2 text-lg mb-8" id="final-score-list"></div>
        <button class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded transition-colors" id="main-menu-button-final">Main Menu</button>
    </div>
</div>

<!-- Main Game Container -->
<div class="hidden" id="game-container">
    <div id="particle-container"></div>
    <div class="confetti-container"></div>
    <div id="game-layout">
        <div class="bg-gray-900 bg-opacity-70 p-2 rounded-lg shadow-lg flex justify-between items-center flex-wrap gap-4" id="game-info">
            <!-- Group 1: Left Controls -->
            <div class="flex items-center gap-4">
                <button class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors" id="main-menu-button">New Game / Exit</button>
                <div>
                    <h2 class="font-bold text-lg">Current Turn: <span id="current-player"></span></h2>
                    <p class="text-sm text-yellow-300" id="game-status">Loading...</p>
                </div>
            </div>
            
            <!-- Group 2: Game Log & Pip Tally -->
            <div class="flex items-center gap-4 flex-grow justify-center">
                 <div id="game-log" class="flex-grow"></div>
                <div class="text-center px-4">
                    <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Your Hand Pips</h3>
                    <p id="hand-value-display" class="text-2xl font-bold text-yellow-300">0</p>
                </div>
            </div>

            <!-- Group 3: Right Controls -->
            <div class="flex items-center gap-4">
                <button class="bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-2 px-4 rounded transition-colors" id="re-deal-button">Next Round</button>
                <label for="theme-switcher" class="sr-only">Theme</label>
                <select class="bg-gray-700 text-white rounded p-2" id="theme-switcher">
                    <option value="classic">Classic</option>
                    <option value="dr_edell">Dr. Edell</option>
                    <option value="austin">Austin</option>
                    <option value="rose">Rose</option>
                    <option value="anna">Anna</option>
                    <option value="kate">Kate</option>
                </select>
                <div class="text-right flex gap-4" id="scoreboard"></div>
            </div>
        </div>
        
        <div id="left-panel">
            <div id="player-hands-container">
                <!-- Player hands will be rendered here by JS -->
            </div>
            <div id="boneyard-container">
                <h2 class="text-xl font-semibold mb-3 text-center">Boneyard</h2>
                <div id="boneyard-pile" title="Click to draw a domino">
                    <div id="boneyard-stack"></div>
                    <span id="boneyard-count">0</span>
                </div>
                <div class="mt-2 flex items-center justify-center gap-2" id="boneyard-buttons">
                    <button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors" id="undo-button">Undo</button>
                    <button class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors" id="end-turn-button">End Turn</button>
                    <button class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition-colors hidden" id="rotate-last-tile-button">Rotate Tile</button>
                    <!-- NEW: Validation Buttons -->
                    <button class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded transition-colors hidden" id="validate-move-button">Validate Move</button>
                    <button class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-3 rounded transition-colors hidden" id="challenge-move-button">Challenge</button>
                </div>
            </div>
            <!-- NEW: Detailed Scoreboard Container -->
            <div id="detailed-scoreboard-container">
                <h3 class="text-lg font-semibold text-center mb-2">Score History</h3>
                <div id="detailed-scoreboard-content"></div>
            </div>
        </div>
        
        <div id="main-game-area">
            <div id="world-wrapper">
                <div id="world">
                    <div id="game-board">
                        <div id="starting-area"></div>
                    </div>
                </div>
            </div>
            <div id="minimap-container">
                <div id="minimap-viewport"></div>
            </div>
            <!-- NEW: Zoom Controls -->
            <div id="zoom-controls" class="absolute bottom-4 right-4 z-10 flex flex-col gap-2">
                <button id="zoom-in-button" class="w-10 h-10 bg-gray-900 bg-opacity-70 rounded-full text-white text-2xl font-bold flex items-center justify-center shadow-lg hover:bg-opacity-90 transition-all">+</button>
                <button id="zoom-out-button" class="w-10 h-10 bg-gray-900 bg-opacity-70 rounded-full text-white text-2xl font-bold flex items-center justify-center shadow-lg hover:bg-opacity-90 transition-all">-</button>
            </div>
        </div>
    </div>
</div>
<!-- Firebase SDK -->
<script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

    // --- DOM Elements ---
    const dom = {
        loadingScreen: document.getElementById('loading-screen'),
        authStatus: document.getElementById('auth-status'),
        setupScreen: document.getElementById('setup-screen'),
        gameContainer: document.getElementById('game-container'),
        lobbyView: document.getElementById('lobby-view'),
        waitingRoomView: document.getElementById('waiting-room-view'),
        joinGameButton: document.getElementById('join-game-button'),
        startGameButton: document.getElementById('start-game-button'),
        reDealButton: document.getElementById('re-deal-button'),
        playerNameInput: document.getElementById('player-name'),
        joinGameIdInput: document.getElementById('join-game-id'),
        gameIdDisplay: document.getElementById('game-id-display'),
        gameIdHeader: document.getElementById('game-id-header'),
        copyGameIdButton: document.getElementById('copy-game-id'),
        playerList: document.getElementById('player-list'),
        waitingMessage: document.getElementById('waiting-message'),
        worldElement: document.getElementById('world'),
        gameBoardElement: document.getElementById('game-board'),
        boneyardPileElement: document.getElementById('boneyard-pile'),
        boneyardStack: document.getElementById('boneyard-stack'),
        boneyardContainer: document.getElementById('boneyard-container'),
        boneyardCountElement: document.getElementById('boneyard-count'),
        currentPlayerElement: document.getElementById('current-player'),
        endTurnButton: document.getElementById('end-turn-button'),
        undoButton: document.getElementById('undo-button'),
        rotateLastTileButton: document.getElementById('rotate-last-tile-button'),
        gameStatusElement: document.getElementById('game-status'),
        playerHandsContainer: document.getElementById('player-hands-container'),
        scoreboard: document.getElementById('scoreboard'),
        themeSwitcher: document.getElementById('theme-switcher'),
        roundEndScreen: document.getElementById('round-end-screen'),
        roundEndTitle: document.getElementById('round-end-title'),
        roundWinnerMessage: document.getElementById('round-winner-message'),
        roundResultsList: document.getElementById('round-results-list'),
        continueRoundButton: document.getElementById('continue-round-button'),
        minimapContainer: document.getElementById('minimap-container'),
        minimapViewport: document.getElementById('minimap-viewport'),
        gameOverScreen: document.getElementById('game-over-screen'),
        finalWinnerMessage: document.getElementById('final-winner-message'),
        finalScoreList: document.getElementById('final-score-list'),
        mainMenuButton: document.getElementById('main-menu-button'),
        mainMenuButtonFinal: document.getElementById('main-menu-button-final'),
        messageModal: document.getElementById('message-modal'),
        messageText: document.getElementById('message-text'),
        messageOkButton: document.getElementById('message-ok-button'),
        gameLog: document.getElementById('game-log'),
        handValueDisplay: document.getElementById('hand-value-display'),
        validateMoveButton: document.getElementById('validate-move-button'),
        challengeMoveButton: document.getElementById('challenge-move-button'),
        detailedScoreboardContent: document.getElementById('detailed-scoreboard-content'),
        zoomInButton: document.getElementById('zoom-in-button'),
        zoomOutButton: document.getElementById('zoom-out-button'),
        
        // MODIFIED: Lobby DOM Elements
        createGameFlow: document.getElementById('create-game-flow'),
        joinGameFlow: document.getElementById('join-game-flow'),
        modeOnlineButton: document.getElementById('mode-online-button'),
        modeHybridButton: document.getElementById('mode-hybrid-button'),
        localPlayerSetupView: document.getElementById('local-player-setup-view'),
        localPlayerNameInput: document.getElementById('local-player-name-input'),
        addLocalPlayerButton: document.getElementById('add-local-player-button'),
        localPlayerList: document.getElementById('local-player-list'),
        createHybridGameButton: document.getElementById('create-hybrid-game-button'),
        backToModeSelectionButton: document.getElementById('back-to-mode-selection-button'),

        // NEW: Joiner Group Setup DOM Elements
        joinTypeSelectionView: document.getElementById('join-type-selection-view'),
        joinTypeGameIdDisplay: document.getElementById('join-type-game-id-display'),
        joinAsSinglePlayerButton: document.getElementById('join-as-single-player-button'),
        joinAsGroupButton: document.getElementById('join-as-group-button'),
        backToLobbyButton: document.getElementById('back-to-lobby-button'),
        joinGroupSetupView: document.getElementById('join-group-setup-view'),
        joiningGameIdDisplay: document.getElementById('joining-game-id-display'),
        joinerLocalPlayerNameInput: document.getElementById('joiner-local-player-name-input'),
        addJoinerLocalPlayerButton: document.getElementById('add-joiner-local-player-button'),
        joinerLocalPlayerList: document.getElementById('joiner-local-player-list'),
        confirmJoinGroupButton: document.getElementById('confirm-join-group-button'),
        
        // NEW: Round Start Screen Elements
        roundStartScreen: document.getElementById('round-start-screen'),
        roundStartNumber: document.getElementById('round-start-number'),
        roundStarterName: document.getElementById('round-starter-name'),
        roundStartWaitMessage: document.getElementById('round-start-wait-message'),
        confirmRoundStartButton: document.getElementById('confirm-round-start-button'),

        // Pass Device Screen Elements
        passDeviceScreen: document.getElementById('pass-device-screen'),
        nextPlayerNamePass: document.getElementById('next-player-name-pass'),
        confirmTurnButton: document.getElementById('confirm-turn-button'),
    };
    
    // --- Firebase & Game State ---
    let db, auth, analytics;
    let currentGameId = null;
    let currentPlayerId = null;
    let localGameState = {};
    let unsubscribeGameListener = null;
    let localPlayers = []; // For host
    let joinerLocalPlayers = []; // NEW: For joiner

    const PLAYER_COLORS = ['#E6194B', '#4363d8', '#3cb44b', '#ffe119', '#911eb4', '#f58231', '#42d4f4', '#f032e6'];
    const SPINNER_VALUE = -1;
    const BOARD_SIZE = 4000;
    const DOMINO_WIDTH = 80;
    const DOMINO_HEIGHT = 40;
    
    // --- Interaction State ---
    let isDraggingDomino = false;
    let wasDragged = false;
    let dragStartPos = { x: 0, y: 0 };
    let dragStartTime = 0;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let boardPosition = { x: 0, y: 0 };
    let zoomLevel = 1.0;
    const MIN_ZOOM = 0.3;
    const MAX_ZOOM = 3.0;
    let initialPinchDistance = null;
    let activeDominoElement = null;
    let draggedDominoData = null;
    let originalDominoElement = null;

    // --- Firebase Initialization ---
    async function initializeFirebase() {
        try {
            const firebaseConfig = {
                apiKey: "AIzaSyCTmUo5UpQW77xhOkI_3XELSISo6WHyqLs",
                authDomain: "spinner-live.firebaseapp.com",
                projectId: "spinner-live",
                storageBucket: "spinner-live.appspot.com",
                messagingSenderId: "878930500451",
                appId: "1:878930500451:web:e281c28d5c29218044d156",
                measurementId: "G-BPHD3B8WDT"
            };
            
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            analytics = getAnalytics(app);

            dom.authStatus.textContent = 'Authenticating...';
            
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentPlayerId = user.uid;
                    enableLobby();
                } else {
                    await signInAnonymously(auth);
                }
            });
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            dom.authStatus.textContent = "Error: Could not connect. Please refresh.";
            showMessage(`Firebase Error: ${error.message}`);
        }
    }
    
    function showMessage(message) {
        dom.messageText.textContent = message;
        dom.messageModal.classList.remove('hidden');
    }

    dom.messageOkButton.addEventListener('click', () => {
        dom.messageModal.classList.add('hidden');
    });
    
    function enableLobby() {
        dom.authStatus.textContent = 'Ready to Play!';
        dom.loadingScreen.classList.add('hidden');
        dom.setupScreen.classList.remove('hidden');
        dom.joinGameButton.disabled = false;
        dom.modeOnlineButton.disabled = false;
        dom.modeHybridButton.disabled = false;
    }

    // --- Lobby and Game Setup ---

    function showMainLobbyView() {
        dom.createGameFlow.classList.remove('hidden');
        dom.joinGameFlow.classList.remove('hidden');
        dom.localPlayerSetupView.classList.add('hidden');
        dom.joinGroupSetupView.classList.add('hidden');
        dom.joinTypeSelectionView.classList.add('hidden');
    }

    function showHostHybridSetup() {
        dom.createGameFlow.classList.add('hidden');
        dom.joinGameFlow.classList.add('hidden');
        dom.localPlayerSetupView.classList.remove('hidden');
        updateLocalPlayerList();
    }
    
    function addLocalPlayer() {
        const name = dom.localPlayerNameInput.value.trim();
        if (name && localPlayers.length < 7) {
            localPlayers.push({ name });
            dom.localPlayerNameInput.value = '';
            updateLocalPlayerList();
        } else if (localPlayers.length >= 7) {
            showMessage("You can have a maximum of 8 players total (including you).");
        }
    }

    function removeLocalPlayer(index) {
        localPlayers.splice(index, 1);
        updateLocalPlayerList();
    }

    function updateLocalPlayerList() {
        dom.localPlayerList.innerHTML = '';
        if (localPlayers.length > 0) {
            localPlayers.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = "flex justify-between items-center bg-gray-700 p-2 rounded";
                item.innerHTML = `<span>${player.name}</span><button data-index="${index}" class="bg-red-500 text-white w-6 h-6 rounded-full flex items-center justify-center font-bold">&times;</button>`;
                item.querySelector('button').addEventListener('click', () => removeLocalPlayer(index));
                dom.localPlayerList.appendChild(item);
            });
        } else {
             dom.localPlayerList.innerHTML = '<p class="text-gray-500 text-center text-sm">No local players added yet.</p>';
        }
        dom.createHybridGameButton.disabled = localPlayers.length === 0;
    }

    function addJoinerLocalPlayer() {
        const name = dom.joinerLocalPlayerNameInput.value.trim();
        if (name && joinerLocalPlayers.length < 7) {
            joinerLocalPlayers.push({ name });
            dom.joinerLocalPlayerNameInput.value = '';
            updateJoinerLocalPlayerList();
        } else if (joinerLocalPlayers.length >= 7) {
            showMessage("You can have a maximum of 8 players total in your group (including you).");
        }
    }

    function removeJoinerLocalPlayer(index) {
        joinerLocalPlayers.splice(index, 1);
        updateJoinerLocalPlayerList();
    }

    function updateJoinerLocalPlayerList() {
        dom.joinerLocalPlayerList.innerHTML = '';
        if (joinerLocalPlayers.length > 0) {
            joinerLocalPlayers.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = "flex justify-between items-center bg-gray-700 p-2 rounded";
                item.innerHTML = `<span>${player.name}</span><button data-index="${index}" class="bg-red-500 text-white w-6 h-6 rounded-full flex items-center justify-center font-bold">&times;</button>`;
                item.querySelector('button').addEventListener('click', () => removeJoinerLocalPlayer(index));
                dom.joinerLocalPlayerList.appendChild(item);
            });
        } else {
             dom.joinerLocalPlayerList.innerHTML = '<p class="text-gray-500 text-center text-sm">No other local players added yet.</p>';
        }
    }

    const handleCreateOnlineGame = async () => {
        if (!currentPlayerId) return;
        const playerName = dom.playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;
        
        const players = {
            [currentPlayerId]: { id: currentPlayerId, controller: currentPlayerId, name: playerName, score: 0, hand: [], isHost: true }
        };
        const playerOrder = [currentPlayerId];
        
        await createGameInFirestore(players, playerOrder);
    };
    
    const handleCreateHybridGame = async () => {
        if (!currentPlayerId) return;
        const hostName = dom.playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;

        const players = {
            [currentPlayerId]: { id: currentPlayerId, controller: currentPlayerId, name: hostName, score: 0, hand: [], isHost: true }
        };
        const playerOrder = [currentPlayerId];

        localPlayers.forEach((p, i) => {
            const localId = `local_${Date.now()}_${i}`;
            players[localId] = { id: localId, controller: currentPlayerId, name: p.name, score: 0, hand: [], isHost: false };
            playerOrder.push(localId);
        });

        await createGameInFirestore(players, playerOrder);
    };

    async function createGameInFirestore(players, playerOrder) {
        const tempGameRef = doc(collection(db, 'games'));
        const gameId = tempGameRef.id.substring(0, 6).toUpperCase();
        const gameRef = doc(db, "games", gameId);

        // Assign colors to initial players
        playerOrder.forEach((pid, index) => {
            players[pid].color = PLAYER_COLORS[index % PLAYER_COLORS.length];
        });

        const initialGameState = {
            players, playerOrder, gameStatus: 'waiting', boardDominos: [], boneyard: [],
            currentPlayerIndex: 0, roundNumber: 0, currentStartingDouble: 9, turnState: 'WAITING',
            hasDrawn: false, scoreHistory: [], mustDrawToStart: false, lastPlayedDominoId: null,
            passCount: 0, moveHistory: [], log: [], currentTheme: 'classic',
            createdAt: serverTimestamp(), turnConfirmationPending: false,
        };

        await setDoc(gameRef, initialGameState);
        await joinGame(gameId);
    }

    const handleFindGame = async () => {
        const gameId = dom.joinGameIdInput.value.trim().toUpperCase();
        if (!gameId) {
            showMessage("Please enter a Game ID.");
            return;
        }

        const gameRef = doc(db, "games", gameId);
        const gameSnap = await getDoc(gameRef);

        if (!gameSnap.exists()) {
            showMessage("Game not found. Please check the ID.");
            return;
        }
        
        // Show the join type selection screen
        dom.createGameFlow.classList.add('hidden');
        dom.joinGameFlow.classList.add('hidden');
        dom.joinTypeSelectionView.classList.remove('hidden');
        dom.joinTypeGameIdDisplay.textContent = gameId;
    };

    const handleJoinAsSinglePlayer = async () => {
        const gameId = dom.joinTypeGameIdDisplay.textContent;
        const playerName = dom.playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;
        const gameRef = doc(db, "games", gameId);

        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw new Error("Game not found.");
                const gameData = gameSnap.data();

                if (Object.keys(gameData.players).length >= 8) {
                    throw new Error("This game is full.");
                }

                const playerCount = gameData.playerOrder.length;
                const newPlayerColor = PLAYER_COLORS[playerCount % PLAYER_COLORS.length];
                const newPlayer = { id: currentPlayerId, controller: currentPlayerId, name: playerName, score: 0, hand: [], isHost: false, color: newPlayerColor };
                
                transaction.update(gameRef, {
                    [`players.${currentPlayerId}`]: newPlayer,
                    playerOrder: [...gameData.playerOrder, currentPlayerId]
                });
            });
            await joinGame(gameId);
        } catch (error) {
            console.error("Error joining as single player:", error);
            showMessage(error.message);
            showMainLobbyView();
        }
    };

    const handleShowJoinAsGroup = () => {
        const gameId = dom.joinTypeGameIdDisplay.textContent;
        dom.joinTypeSelectionView.classList.add('hidden');
        dom.joinGroupSetupView.classList.remove('hidden');
        dom.joiningGameIdDisplay.textContent = gameId;
        updateJoinerLocalPlayerList();
    };

    const handleConfirmJoinGroup = async () => {
        if (!currentPlayerId) return;
        const gameId = dom.joiningGameIdDisplay.textContent;
        const playerName = dom.playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;

        const gameRef = doc(db, "games", gameId);
        
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw new Error("Game not found.");
                
                const gameData = gameSnap.data();
                let playerCount = gameData.playerOrder.length;
                const updates = {};
                const newPlayerIds = [];

                // Add the main joining player
                const mainPlayerColor = PLAYER_COLORS[playerCount % PLAYER_COLORS.length];
                playerCount++;
                updates[`players.${currentPlayerId}`] = { id: currentPlayerId, controller: currentPlayerId, name: playerName, score: 0, hand: [], isHost: false, color: mainPlayerColor };
                newPlayerIds.push(currentPlayerId);

                // Add the local players for the joiner
                joinerLocalPlayers.forEach((p, i) => {
                    const localId = `local_${Date.now()}_${i}`;
                    const localPlayerColor = PLAYER_COLORS[playerCount % PLAYER_COLORS.length];
                    playerCount++;
                    updates[`players.${localId}`] = { id: localId, controller: currentPlayerId, name: p.name, score: 0, hand: [], isHost: false, color: localPlayerColor };
                    newPlayerIds.push(localId);
                });

                if (Object.keys(gameData.players).length + newPlayerIds.length > 8) {
                    throw new Error("This would exceed the maximum of 8 players.");
                }

                updates.playerOrder = [...gameData.playerOrder, ...newPlayerIds];

                transaction.update(gameRef, updates);
            });

            await joinGame(gameId);

        } catch (error) {
            console.error("Error joining game with group:", error);
            showMessage(error.message);
            showMainLobbyView();
        }
    };


    dom.modeOnlineButton.addEventListener('click', handleCreateOnlineGame);
    dom.modeHybridButton.addEventListener('click', showHostHybridSetup);
    dom.backToModeSelectionButton.addEventListener('click', showMainLobbyView);
    dom.addLocalPlayerButton.addEventListener('click', addLocalPlayer);
    dom.localPlayerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addLocalPlayer(); });
    dom.createHybridGameButton.addEventListener('click', handleCreateHybridGame);
    
    dom.joinGameButton.addEventListener('click', handleFindGame);
    dom.joinAsSinglePlayerButton.addEventListener('click', handleJoinAsSinglePlayer);
    dom.joinAsGroupButton.addEventListener('click', handleShowJoinAsGroup);
    dom.backToLobbyButton.addEventListener('click', showMainLobbyView);

    dom.addJoinerLocalPlayerButton.addEventListener('click', addJoinerLocalPlayer);
    dom.joinerLocalPlayerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addJoinerLocalPlayer(); });
    dom.confirmJoinGroupButton.addEventListener('click', handleConfirmJoinGroup);


    async function joinGame(gameId) {
        currentGameId = gameId;
        dom.lobbyView.classList.add('hidden');
        dom.waitingRoomView.classList.remove('hidden');
        dom.gameIdDisplay.textContent = gameId;
        
        if (unsubscribeGameListener) unsubscribeGameListener();
        unsubscribeGameListener = onSnapshot(doc(db, "games", currentGameId), (docSnap) => {
            if (docSnap.exists()) {
                handleGameStateUpdate(docSnap.data());
            } else {
                showMessage("The game has ended or was deleted.");
                leaveGame();
            }
        });
    }

    function leaveGame() {
        window.location.reload();
    }
    dom.mainMenuButton.addEventListener('click', leaveGame);
    dom.mainMenuButtonFinal.addEventListener('click', leaveGame);

    dom.copyGameIdButton.addEventListener('click', () => {
        navigator.clipboard.writeText(currentGameId).then(() => {
            dom.copyGameIdButton.textContent = 'Copied!';
            setTimeout(() => { dom.copyGameIdButton.textContent = 'Copy'; }, 2000);
        }).catch(err => {
            const textArea = document.createElement("textarea");
            textArea.value = currentGameId;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                dom.copyGameIdButton.textContent = 'Copied!';
            } catch (err) {
                dom.copyGameIdButton.textContent = 'Failed!';
            }
            document.body.removeChild(textArea);
            setTimeout(() => { dom.copyGameIdButton.textContent = 'Copy'; }, 2000);
        });
    });

    dom.startGameButton.addEventListener('click', () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            startRound();
        }
    });
    dom.reDealButton.addEventListener('click', () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            startRound();
        }
    });

    // --- Main Game State Handler ---
    function handleGameStateUpdate(gameState) {
        const oldTheme = localGameState.currentTheme;
        const oldStatus = localGameState.gameStatus; // Capture old status

        localGameState = gameState;
        
        // Handle modals first, as they take precedence over the main game view
        if (gameState.turnConfirmationPending) {
            const nextPlayer = gameState.players[gameState.playerOrder[gameState.currentPlayerIndex]];
            if (nextPlayer && nextPlayer.controller === currentPlayerId) {
                showPassDeviceScreen(nextPlayer.name);
                return; // IMPORTANT: Stop further rendering
            }
        }
        dom.passDeviceScreen.classList.add('hidden');

        if (gameState.gameStatus === 'round-starting') {
            dom.setupScreen.classList.add('hidden');
            showRoundStartScreen(gameState);
            return; // IMPORTANT: Stop further rendering
        }
        dom.roundStartScreen.classList.add('hidden');

        if (!gameState.players || !gameState.playerOrder || gameState.playerOrder.length === 0) {
            return;
        }

        const playerIds = gameState.playerOrder;
        const playerCount = playerIds.length;
        const isHost = gameState.players[currentPlayerId]?.isHost;

        if (gameState.gameStatus === 'waiting') {
            dom.playerList.innerHTML = '';
            playerIds.forEach(pid => {
                const p = document.createElement('p');
                p.textContent = `${gameState.players[pid].name} ${gameState.players[pid].isHost ? '(Host)' : ''}`;
                dom.playerList.appendChild(p);
            });
            
            const canStart = isHost && playerCount >= 2 && playerCount <= 8;
            dom.startGameButton.disabled = !canStart;
            dom.reDealButton.classList.toggle('hidden', true);

            if (isHost) {
                if (playerCount < 2) dom.waitingMessage.textContent = "Need at least 2 players to start.";
                else if (playerCount > 8) dom.waitingMessage.textContent = "Cannot start with more than 8 players.";
                else dom.waitingMessage.textContent = "You're the host. Start the game when ready!";
            } else {
                dom.waitingMessage.textContent = "Waiting for the host to start the game...";
            }

            dom.waitingRoomView.classList.remove('hidden');
            dom.setupScreen.classList.remove('hidden');
            dom.gameContainer.classList.add('hidden');

        } else if (gameState.gameStatus === 'in-progress' || gameState.gameStatus === 'round-over' || gameState.gameStatus === 'finished') {
            dom.setupScreen.classList.add('hidden');
            dom.gameContainer.classList.remove('hidden');
            
            if (oldTheme !== gameState.currentTheme) {
                if(dom.themeSwitcher) {
                   dom.themeSwitcher.value = gameState.currentTheme;
                }
            }

            // **FIXED**: Center board on first round start AND subsequent round starts.
            if ((oldStatus === 'waiting' || oldStatus === 'round-starting') && gameState.gameStatus === 'in-progress') {
                // Using a timeout within rAF ensures layout has been calculated.
                requestAnimationFrame(() => setTimeout(centerBoardOnStart, 0));
            }
            dom.reDealButton.classList.toggle('hidden', !isHost);
            renderGameUI(gameState);
        }
        
        if (gameState.gameStatus === 'round-over') {
            displayRoundEndScreen(gameState);
        } else {
            dom.roundEndScreen.classList.add('hidden');
        }

        if (gameState.gameStatus === 'finished') {
            showFinalScores(gameState);
        } else {
            dom.gameOverScreen.classList.add('hidden');
        }
    }
    
    function showPassDeviceScreen(nextPlayerName) {
        dom.gameContainer.classList.add('hidden');
        dom.playerHandsContainer.innerHTML = ''; // Explicitly clear hands
        dom.nextPlayerNamePass.textContent = nextPlayerName;
        dom.passDeviceScreen.classList.remove('hidden');
    }

    dom.confirmTurnButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        await updateDoc(gameRef, { turnConfirmationPending: false });
    });
    
    // NEW: Round Start Screen Logic
    function showRoundStartScreen(gameState) {
        const { roundNumber, roundStartInfo } = gameState;
        const starter = gameState.players[roundStartInfo.starterId];
        
        // **FIXED**: Ensure round-end screen is hidden when round-start screen appears.
        dom.roundEndScreen.classList.add('hidden');
        dom.gameContainer.classList.add('hidden');
        dom.roundStartNumber.textContent = roundNumber;
        dom.roundStarterName.textContent = starter.name;

        if (starter.controller === currentPlayerId) {
            dom.confirmRoundStartButton.classList.remove('hidden');
            dom.roundStartWaitMessage.classList.add('hidden');
        } else {
            dom.confirmRoundStartButton.classList.add('hidden');
            dom.roundStartWaitMessage.classList.remove('hidden');
        }
        
        dom.roundStartScreen.classList.remove('hidden');
    }

    dom.confirmRoundStartButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        const { roundStartInfo, players } = localGameState;
        const starter = players[roundStartInfo.starterId];
        
        const needsConfirmation = starter.controller === currentPlayerId && starter.id !== currentPlayerId;

        await updateDoc(gameRef, {
            gameStatus: 'in-progress',
            currentPlayerIndex: roundStartInfo.starterIndex,
            roundStartInfo: null, // Clear the info to proceed
            turnConfirmationPending: needsConfirmation // Set the flag here
        });
    });

    // --- Core Game Logic ---
    function generateDeck() {
        const deck = [];
        for (let i = 0; i <= 9; i++) {
            for (let j = i; j <= 9; j++) deck.push({ top: i, bottom: j, id: `d-${i}-${j}` });
        }
        for (let i = 0; i <= 9; i++) deck.push({ top: SPINNER_VALUE, bottom: i, id: `s-${i}` });
        deck.push({ top: SPINNER_VALUE, bottom: SPINNER_VALUE, id: 'd-s-s' });
        return deck;
    }

    function shuffle(deck) {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    }
    
    // REFACTORED: startRound is now much faster and safer.
    async function startRound() {
        // --- Preparation (before transaction) ---
        const currentData = localGameState;
        const playerIds = currentData.playerOrder;
        const deck = generateDeck();
        shuffle(deck);

        const dominoesPerPlayer = 7;
        const updatedPlayers = JSON.parse(JSON.stringify(currentData.players)); // Deep copy

        playerIds.forEach(pid => {
            updatedPlayers[pid].hand = deck.splice(0, dominoesPerPlayer);
        });

        const newRoundNumber = currentData.roundNumber + 1;
        const newStartingDouble = 9 - ((newRoundNumber - 1) % 10);

        let starterIndex;
        let mustDraw = false;

        const tileStarterIndex = findRoundStarter(updatedPlayers, playerIds, newStartingDouble);

        if (tileStarterIndex !== -1) {
            starterIndex = tileStarterIndex;
            mustDraw = false;
        } else {
            const previousWinnerId = currentData.roundEndInfo?.winnerId;
            const previousWinnerIndex = playerIds.indexOf(previousWinnerId);

            if (newRoundNumber > 1 && previousWinnerId && previousWinnerIndex !== -1) {
                starterIndex = previousWinnerIndex;
                mustDraw = true;
            } else {
                let highestScore = -1;
                let highestScoreIndex = -1;
                for (let i = 0; i < playerIds.length; i++) {
                    const pid = playerIds[i];
                    const handValue = calculateHandValue(updatedPlayers[pid].hand);
                    if (handValue > highestScore) {
                        highestScore = handValue;
                        highestScoreIndex = i;
                    }
                }
                starterIndex = highestScoreIndex;
                mustDraw = true;
            }
        }
        
        const starterId = playerIds[starterIndex];

        // This is the final object we will write to Firestore.
        const newRoundState = {
            gameStatus: 'round-starting',
            players: updatedPlayers,
            boneyard: deck,
            boardDominos: [],
            roundNumber: newRoundNumber,
            currentStartingDouble: newStartingDouble,
            mustDrawToStart: mustDraw,
            turnState: 'WAITING',
            hasDrawn: false,
            lastPlayedDominoId: null,
            passCount: 0,
            moveHistory: [],
            log: [],
            roundEndInfo: null,
            turnConfirmationPending: false,
            roundStartInfo: {
                starterId: starterId,
                starterIndex: starterIndex,
            }
        };

        // --- Transaction (fast write) ---
        const gameRef = doc(db, "games", currentGameId);
        try {
            await updateDoc(gameRef, newRoundState);
        } catch (error) {
            console.error("Failed to start next round:", error);
            showMessage("Could not start the next round. The host may need to try again.");
        }
    }
    
    function findRoundStarter(players, playerOrder, requiredDoubleValue) {
        const hasSpecificDouble = (hand, val) => hand.some(d => d.top === val && d.bottom === val);
        const hasDoubleSpinner = (hand) => hand.some(d => d.top === SPINNER_VALUE && d.bottom === SPINNER_VALUE);

        for (let i = 0; i < playerOrder.length; i++) {
            const pid = playerOrder[i];
            if (hasSpecificDouble(players[pid].hand, requiredDoubleValue)) {
                return i;
            }
        }
        
        for (let i = 0; i < playerOrder.length; i++) {
            const pid = playerOrder[i];
            if (hasDoubleSpinner(players[pid].hand)) {
                return i;
            }
        }

        return -1;
    }
    
    async function drawFromBoneyard() {
        const gameRef = doc(db, "games", currentGameId);
        
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw "Game does not exist!";
                const gameState = gameSnap.data();
                
                const currentTurnPlayer = gameState.players[gameState.playerOrder[gameState.currentPlayerIndex]];
                const isMyDeviceTurn = currentTurnPlayer.controller === currentPlayerId;

                if (!isMyDeviceTurn || gameState.hasDrawn || gameState.turnState !== 'WAITING' || gameState.boneyard.length === 0) {
                    return;
                }

                const boneyard = [...gameState.boneyard];
                const drawnDomino = boneyard.pop();
                
                const updatedPlayers = { ...gameState.players };
                updatedPlayers[currentTurnPlayer.id].hand.push(drawnDomino);
                
                const newLog = [...(gameState.log || [])];
                newLog.push(`${currentTurnPlayer.name} drew from the boneyard.`);
                if (newLog.length > 5) newLog.shift();

                transaction.update(gameRef, {
                    players: updatedPlayers,
                    boneyard: boneyard,
                    hasDrawn: true,
                    log: newLog
                });
            });
        } catch (error) {
            console.error("Error drawing from boneyard:", error);
            showMessage("Could not draw a domino. Please try again.");
        }
    }
    dom.boneyardPileElement.addEventListener('click', drawFromBoneyard);
    dom.boneyardPileElement.addEventListener('touchstart', (e) => { e.preventDefault(); drawFromBoneyard(); });

    async function submitTurnForValidation() {
        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw "Game does not exist!";
                const gameState = gameSnap.data();

                const currentTurnPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
                const currentTurnPlayer = gameState.players[currentTurnPlayerId];

                const newLog = [...(gameState.log || [])];
                if(gameState.hasDrawn && gameState.turnState === 'WAITING'){
                    newLog.push(`${currentTurnPlayer.name} passed their turn.`);
                } else {
                     newLog.push(`${currentTurnPlayer.name} submitted their move for validation.`);
                }
                if (newLog.length > 5) newLog.shift();

                transaction.update(gameRef, {
                    turnState: 'PENDING_VALIDATION',
                    log: newLog
                });
            });
        } catch(error) {
            console.error("Error submitting turn:", error);
            showMessage("Could not submit turn. Please try again.");
        }
    }
    dom.endTurnButton.addEventListener('click', submitTurnForValidation);
    
    function calculateHandValue(hand) {
        return hand.reduce((total, domino) => {
            const topValue = domino.top === SPINNER_VALUE ? 10 : domino.top;
            const bottomValue = domino.bottom === SPINNER_VALUE ? 10 : domino.bottom;
            return total + topValue + bottomValue;
        }, 0);
    }

    dom.continueRoundButton.addEventListener('click', () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            dom.continueRoundButton.disabled = true;
            dom.continueRoundButton.textContent = "Starting...";
            startRound();
        }
    });

    // --- UI Rendering ---
    function renderGameUI(gameState) {
        const currentTurnPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
        const currentTurnPlayer = gameState.players[currentTurnPlayerId];
        const isMyDeviceTurn = currentTurnPlayer?.controller === currentPlayerId;
        
        // --- Render Board and Dominoes ---
        if (!isDraggingDomino) {
            dom.gameBoardElement.querySelectorAll('.domino').forEach(d => d.remove());
            gameState.boardDominos.forEach(domino => {
                const el = createDomino(domino.dominoData);
                el.style.position = 'absolute';
                el.style.left = `${domino.x}px`;
                el.style.top = `${domino.y}px`;
                el.style.transform = `rotate(${domino.rotation}deg)`;
                el.dataset.rotation = domino.rotation;
                el.dataset.id = domino.dominoData.id;
                
                if (isMyDeviceTurn) {
                    el.addEventListener('mousedown', (e) => startDominoDrag(e, domino, 'board'));
                    el.addEventListener('touchstart', (e) => startDominoDrag(e, domino, 'board'), { passive: false });
                }

                if (gameState.turnState === 'PENDING_VALIDATION' && domino.dominoData.id === gameState.lastPlayedDominoId) {
                    el.classList.add('pending-validation-glow');
                }

                dom.gameBoardElement.appendChild(el);
            });
        }
        updateMinimap(gameState.boardDominos);

        // --- Render Player Hands, Scoreboards, and Logs ---
        dom.playerHandsContainer.innerHTML = '';
        dom.scoreboard.innerHTML = '';
        renderPlayerHands(gameState);
        renderGameLog(gameState.log);
        renderDetailedScoreboard(gameState);

        gameState.playerOrder.forEach(pid => {
            renderScoreboardEntry(gameState.players[pid], pid);
        });
        
        const myPlayerData = gameState.players[currentPlayerId];
        if (myPlayerData) {
            dom.handValueDisplay.textContent = calculateHandValue(myPlayerData.hand);
        }

        // --- Update UI State (Buttons, Status Text) ---
        renderBoneyard(gameState, isMyDeviceTurn);
        dom.currentPlayerElement.textContent = gameState.players[currentTurnPlayerId].name;
        
        updateStatusAndButtons(gameState, isMyDeviceTurn, currentTurnPlayerId);
    }

    function updateStatusAndButtons(gameState, isMyDeviceTurn, currentTurnPlayerId) {
        let statusText = '';
        dom.endTurnButton.classList.add('hidden');
        dom.validateMoveButton.classList.add('hidden');
        dom.challengeMoveButton.classList.add('hidden');

        if (isMyDeviceTurn) {
            switch(gameState.turnState) {
                case 'PENDING_VALIDATION':
                    statusText = "Waiting for other players to validate your move...";
                    break;
                case 'PLACED':
                    statusText = "You've played. You can adjust your tile or end your turn.";
                    dom.endTurnButton.classList.remove('hidden');
                    dom.endTurnButton.disabled = false;
                    break;
                case 'WAITING':
                default:
                    if(gameState.hasDrawn){
                        statusText = "You have drawn a tile. Play it or end your turn.";
                        dom.endTurnButton.classList.remove('hidden');
                        dom.endTurnButton.disabled = false;
                    } else if(gameState.mustDrawToStart) {
                        statusText = "You must draw to start the round.";
                    } else if (gameState.boardDominos.length === 0) {
                        statusText = `You must play the Double ${gameState.currentStartingDouble} or Double Spinner.`;
                    } else {
                        statusText = "Your turn. Play a domino or draw from the boneyard.";
                    }
                    break;
            }
        } else { // Not my turn
            statusText = `Waiting for ${gameState.players[currentTurnPlayerId].name}...`;
            if (gameState.turnState === 'PENDING_VALIDATION') {
                statusText = `Validate ${gameState.players[currentTurnPlayerId].name}'s move.`;
                dom.validateMoveButton.classList.remove('hidden');
                dom.challengeMoveButton.classList.remove('hidden');
            }
        }
        if (!isDraggingDomino) {
            dom.gameStatusElement.textContent = statusText;
        }

        dom.undoButton.disabled = !(isMyDeviceTurn && (gameState.moveHistory || []).length > 0);
        dom.rotateLastTileButton.classList.toggle('hidden', !(isMyDeviceTurn && gameState.turnState === 'PLACED' && gameState.lastPlayedDominoId));
        dom.boneyardPileElement.style.cursor = (isMyDeviceTurn && gameState.turnState === 'WAITING' && !gameState.hasDrawn && gameState.boneyard.length > 0) ? 'pointer' : 'not-allowed';
        dom.boneyardPileElement.classList.toggle('can-draw', isMyDeviceTurn && gameState.turnState === 'WAITING' && !gameState.hasDrawn && gameState.boneyard.length > 0);
    }

    function renderPlayerHands(gameState) {
        const playerOrder = gameState.playerOrder;
        const currentTurnPlayerId = playerOrder[gameState.currentPlayerIndex];
        const currentTurnPlayer = gameState.players[currentTurnPlayerId];
        const isMyDeviceControllingThisTurn = currentTurnPlayer?.controller === currentPlayerId;
        const isTurnPendingConfirmation = gameState.turnConfirmationPending;

        playerOrder.forEach(playerId => {
            const playerData = gameState.players[playerId];
            if (!playerData) return;

            const isThisPlayerTheActiveTurn = playerId === currentTurnPlayerId;
            
            const section = document.createElement('div');
            section.className = 'player-hand-section';
            if (isThisPlayerTheActiveTurn) {
                section.classList.add('flashing-border');
            }

            const title = document.createElement('h3');
            title.className = 'font-bold text-center mb-2 text-sm flex items-center justify-center';
            
            let nameTag = '';
            if (playerData.controller === currentPlayerId && playerId !== currentPlayerId) {
                nameTag = '(Local)';
            } else if (playerId === currentPlayerId) {
                nameTag = '(You)';
            } else if (playerData.isHost) {
                 nameTag = '(Host)';
            }
            
            const colorDot = document.createElement('span');
            colorDot.style.display = 'inline-block';
            colorDot.style.width = '10px';
            colorDot.style.height = '10px';
            colorDot.style.borderRadius = '50%';
            colorDot.style.backgroundColor = playerData.color || '#FFFFFF';
            colorDot.style.marginRight = '8px';
            colorDot.style.border = '1px solid rgba(255,255,255,0.5)';
            
            title.appendChild(colorDot);
            title.appendChild(document.createTextNode(`${playerData.name} ${nameTag} (${playerData.hand.length})`));


            const handDiv = document.createElement('div');
            handDiv.className = 'player-hand-content';

            const showHandFaceUp = isThisPlayerTheActiveTurn && isMyDeviceControllingThisTurn && !isTurnPendingConfirmation;
            
            if (showHandFaceUp) {
                playerData.hand.forEach(dominoData => {
                    const dominoElement = createDomino(dominoData);
                    dominoElement.dataset.id = dominoData.id;
                    
                    if (isThisPlayerTheActiveTurn && isMyDeviceControllingThisTurn && gameState.turnState === 'WAITING') {
                        dominoElement.addEventListener('mousedown', (e) => startDominoDrag(e, { dominoData }, 'hand'));
                        dominoElement.addEventListener('touchstart', (e) => startDominoDrag(e, { dominoData }, 'hand'), { passive: false });
                    } else {
                        dominoElement.style.cursor = 'not-allowed';
                    }
                    handDiv.appendChild(dominoElement);
                });
            } else {
                playerData.hand.forEach(() => {
                    const dominoElement = createDomino(null, true, 'mini');
                    handDiv.appendChild(dominoElement);
                });
            }
            
            section.appendChild(title);
            section.appendChild(handDiv);
            dom.playerHandsContainer.appendChild(section);
        });
    }


    function renderScoreboardEntry(playerData, playerId) {
        if (!playerData) return;
        const scoreEntry = document.createElement('p');
        scoreEntry.textContent = `${playerData.name}: ${playerData.score}`;
        dom.scoreboard.appendChild(scoreEntry);
    }
    
    function renderGameLog(log) {
        if (!log) return;
        dom.gameLog.innerHTML = '';
        log.forEach(entry => {
            const p = document.createElement('p');
            p.textContent = entry;
            dom.gameLog.appendChild(p);
        });
        dom.gameLog.scrollTop = dom.gameLog.scrollHeight;
    }

    function renderBoneyard(gameState, isMyDeviceTurn) {
        dom.boneyardStack.innerHTML = '';
        
        if (gameState.boneyard.length > 0) {
            const dominoDisplay = document.createElement('div');
            dominoDisplay.className = 'boneyard-domino-display';
            dom.boneyardStack.appendChild(dominoDisplay);
        }

        const existingMessage = document.getElementById('boneyard-message');
        if (existingMessage) existingMessage.remove();

        if (isMyDeviceTurn && gameState.turnState === 'WAITING' && !gameState.hasDrawn && gameState.boneyard.length > 0) {
            const message = document.createElement('div');
            message.id = 'boneyard-message';
            message.textContent = 'Click to Draw';
            dom.boneyardPileElement.appendChild(message);
        }

        dom.boneyardCountElement.textContent = gameState.boneyard.length;
    }
    
    function displayRoundEndScreen(gameState) {
        if (!gameState.roundEndInfo) return;
        
        if (gameState.gameStatus === 'finished') {
            showFinalScores(gameState);
            return;
        }

        dom.roundEndScreen.classList.remove('hidden');

        const { winnerId, points } = gameState.roundEndInfo;
        dom.roundEndTitle.textContent = `Round ${gameState.roundNumber} Over!`;
        dom.roundWinnerMessage.textContent = `${gameState.players[winnerId].name} wins the round!`;

        dom.roundResultsList.innerHTML = '';
        gameState.playerOrder.forEach(pid => {
            const p = document.createElement('p');
            const oldScore = gameState.players[pid].score - (points[pid] || 0);
            p.textContent = `${gameState.players[pid].name}: ${oldScore} + ${points[pid] || 0} points = ${gameState.players[pid].score} Total`;
            if (pid === winnerId) p.classList.add('winner');
            dom.roundResultsList.appendChild(p);
        });
        
        const isHost = gameState.players[currentPlayerId]?.isHost;
        dom.continueRoundButton.disabled = !isHost;
        dom.continueRoundButton.textContent = isHost ? "Start Next Round" : "Waiting for Host...";
    }

    function showFinalScores(gameState) {
        dom.roundEndScreen.classList.add('hidden');
        dom.gameOverScreen.classList.remove('hidden');

        const finalScores = gameState.playerOrder.map(pid => ({
            name: gameState.players[pid].name,
            score: gameState.players[pid].score
        })).sort((a, b) => a.score - b.score);

        const winnerScore = finalScores[0].score;
        const winners = finalScores.filter(p => p.score === winnerScore);

        if (winners.length > 1) {
            dom.finalWinnerMessage.textContent = `It's a tie between ${winners.map(w => w.name).join(' and ')}!`;
        } else {
            dom.finalWinnerMessage.textContent = `${winners[0].name} wins the game!`;
        }

        dom.finalScoreList.innerHTML = '';
        finalScores.forEach(player => {
            const p = document.createElement('p');
            p.textContent = `${player.name}: ${player.score} points`;
            if (player.score === winnerScore) {
                p.classList.add('winner');
            }
            dom.finalScoreList.appendChild(p);
        });
        
        // Trigger confetti for the winner(s)
        winners.forEach(winner => {
            const winnerData = Object.values(gameState.players).find(p => p.name === winner.name);
            if (winnerData) {
                triggerConfetti(winnerData.color);
            }
        });
    }

    function createDomino(dominoData, isBack = false, size = 'normal') {
        const dominoElement = document.createElement('div');
        dominoElement.className = 'domino';
        if (size === 'mini') {
            dominoElement.classList.add('mini-domino');
        }

        if (isBack) {
            dominoElement.classList.add('domino-back');
            return dominoElement;
        }
        
        dominoElement.appendChild(createPipContainer(dominoData.top, size));
        dominoElement.appendChild(document.createElement('div')).className = 'divider';
        dominoElement.appendChild(createPipContainer(dominoData.bottom, size));
        return dominoElement;
    }
    
    // **FIXED**: Replaced with user's requested color palette.
    const PIP_COLORS = [
        '#cbd5e0', // 0
        '#EADCA6', // 1
        '#8B0000', // 2
        '#800000', // 3
        '#00BFFF', // 4
        '#006400', // 5
        '#000000', // 6
        '#A0522D', // 7
        '#9370DB', // 8
        '#808080'  // 9
    ];

    function createPipContainer(count, size = 'normal') {
        const container = document.createElement('div');
        container.className = 'pip-container';

        if (count === SPINNER_VALUE) {
            const iconContainer = document.createElement('div');
            iconContainer.className = 'spinner-icon';
            const theme = localGameState.currentTheme || 'classic';
            switch (theme) {
                case 'classic':
                    iconContainer.innerHTML = `<svg viewBox="0 0 24 24" class="w-full h-full"><g stroke="#B91C1C" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M 12 12 L 12 4 L 6 4" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(60 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(120 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(180 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(240 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(300 12 12)" /></g></svg>`;
                    break;
                case 'dr_edell': iconContainer.innerHTML = '<div>🫁</div><div>🩺</div>'; break;
                case 'austin': iconContainer.innerHTML = `<svg viewBox="0 0 24 24" class="w-full h-full"><path fill="#FFDE00" d="M12,2C6.48,2,2,6.48,2,12s4.48,10,10,10s10-4.48,10-10S17.52,2,12,2z"/><path fill="#000000" d="M8.5,10.5c0.83,0,1.5-0.67,1.5-1.5S9.33,7.5,8.5,7.5S7,8.17,7,9S7.67,10.5,8.5,10.5z M15.5,10.5c0.83,0,1.5-0.67,1.5-1.5S16.33,7.5,15.5,7.5S14,8.17,14,9S14.67,10.5,15.5,10.5z"/><path fill="#D9534F" d="M18,14c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S19.1,14,18,14z M6,14c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S7.1,14,6,14z"/><path fill="#000000" d="M12,15c-1.66,0-3-1.34-3-3h1c0,1.1,0.9,2,2,2s2-0.9,2-2h1C15,13.66,13.66,15,12,15z"/></svg>`; break;
                case 'rose': iconContainer.innerHTML = '<div>✍️</div><div>🧩</div>'; break;
                case 'anna': iconContainer.innerHTML = `<svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="300pt" height="155pt" viewBox="0 0 300 155" preserveAspectRatio="xMidYMid meet"><g transform="translate(0,155) scale(0.1,-0.1)" fill="red" stroke="red"><path d="M599 1217 c-92 -35 -157 -104 -182 -194 -7 -29 -17 -43 -28 -43 -26 0 -69 -39 -69 -64 0 -28 33 -64 65 -72 19 -5 28 -19 45 -68 42 -126 159 -271 285 -351 28 -18 83 -49 122 -69 l73 -36 87 44 c206 103 340 248 402 433 12 34 21 82 21 107 l0 45 45 7 c25 3 61 3 80 0 34 -7 35 -8 35 -52 0 -24 9 -73 21 -107 62 -185 196 -330 402 -433 l87 -44 81 41 c204 102 350 256 404 426 13 39 23 53 41 57 32 8 64 45 64 72 0 25 -43 64 -71 64 -11 0 -19 7 -19 18 0 29 -49 124 -80 153 -16 15 -48 38 -72 51 -87 46 -253 24 -324 -43 l-22 -21 -43 31 c-73 54 -177 74 -259 51 -84 -23 -167 -101 -185 -173 -6 -23 -9 -24 -43 -15 -20 6 -64 7 -97 4 l-60 -6 -24 51 c-73 152 -283 195 -430 88 l-43 -31 -22 21 c-60 56 -211 86 -287 58z m205 -42 c18 -8 38 -21 45 -29 7 -9 17 -13 22 -10 5 3 9 1 9 -4 0 -21 40 -19 71 4 35 26 113 52 177 58 43 5 125 -19 158 -47 25 -20 49 -47 48 -55 0 -10 15 -28 58 -73 31 -32 35 -39 23 -49 -8 -7 -15 -19 -15 -26 0 -8 -3 -14 -7 -14 -5 0 -9 -23 -11 -51 -1 -28 -9 -64 -17 -80 -8 -15 -15 -34 -15 -42 0 -8 -7 -20 -15 -27 -8 -7 -15 -21 -15 -31 0 -11 -3 -19 -8 -19 -4 0 -16 -17 -27 -37 -23 -43 -122 -143 -180 -181 -22 -15 -74 -45 -116 -66 l-77 -39 -58 29 c-33 15 -62 27 -66 26 -5 -1 -8 2 -8 8 0 5 -6 10 -13 10 -8 0 -22 9 -32 20 -10 11 -23 20 -29 20 -7 0 -19 8 -27 18 -8 9 -38 38 -65 63 -43 40 -109 125 -107 139 0 3 -8 16 -18 29 -10 12 -21 38 -25 56 -3 18 -14 42 -25 54 -10 11 -19 25 -19 31 0 5 -6 10 -12 10 -7 0 -21 11 -31 25 -17 24 -17 24 21 54 25 21 42 45 51 75 16 55 75 121 135 150 38 18 59 22 117 18 39 -2 85 -10 103 -17z m1211 -19 c63 -38 95 -45 114 -22 16 19 100 58 111 51 5 -3 11 -2 14 3 5 8 104 8 136 0 44 -11 144 -93 134 -110 -3 -4 -1 -8 4 -8 5 0 15 -19 23 -42 7 -24 31 -60 51 -80 l38 -37 -31 -30 c-17 -17 -35 -31 -40 -31 -5 0 -12 -12 -15 -27 -12 -51 -54 -133 -96 -190 -58 -79 -71 -93 -85 -93 -7 0 -12 -5 -10 -10 1 -6 -11 -18 -27 -28 -16 -9 -40 -26 -53 -37 -50 -43 -162 -100 -193 -99 -18 1 -50 12 -70 25 -8 5 -26 14 -39 19 -99 43 -264 205 -312 308 -44 93 -46 98 -58 177 -7 46 -16 74 -28 83 -15 11 -16 14 -3 22 8 5 17 7 21 5 3 -3 12 7 19 20 7 14 17 25 22 25 4 0 8 6 8 14 0 13 41 60 88 100 26 22 81 32 162 29 44 -1 68 -9 115 -37z"/><path d="M631 1138 c-74 -21 -118 -73 -140 -165 -16 -67 -4 -127 47 -232 56 -114 164 -217 315 -300 l57 -32 48 27 c26 15 56 32 67 38 195 107 340 346 304 501 -16 69 -33 100 -71 128 -82 59 -192 55 -268 -11 -38 -32 -77 -99 -65 -111 3 -3 8 5 12 17 3 12 9 22 13 22 4 0 11 11 14 25 4 14 13 25 21 25 8 0 15 4 15 9 0 18 86 51 134 51 69 0 117 -27 148 -85 51 -95 48 -184 -9 -291 -20 -38 -41 -74 -47 -80 -6 -7 -33 -37 -61 -68 -27 -31 -55 -56 -62 -56 -7 0 -18 -9 -25 -20 -7 -11 -16 -20 -21 -20 -4 0 -31 -16 -61 -36 -50 -33 -92 -41 -112 -21 -4 4 -14 7 -21 7 -8 0 -34 14 -58 30 -24 17 -48 30 -54 30 -6 0 -18 11 -27 25 -9 14 -20 25 -25 25 -36 0 -190 225 -173 252 4 6 3 8 -3 5 -11 -7 -23 45 -23 104 0 70 50 150 116 185 25 13 132 13 154 0 50 -30 95 -75 110 -110 12 -27 19 -34 19 -21 2 51 -76 129 -151 152 -50 15 -70 15 -117 1z"/><path d="M1820 1141 c-89 -27 -126 -69 -150 -168 -34 -147 92 -363 285 -486 130 -82 125 -81 189 -47 154 81 259 180 320 305 64 127 65 234 5 321 -68 99 -214 106 -312 15 -31 -28 -57 -72 -57 -93 1 -7 8 1 17 17 23 44 101 115 126 116 12 0 41 2 63 5 112 15 208 -113 188 -247 -6 -40 -58 -167 -74 -179 -3 -3 -16 -21 -28 -40 -11 -19 -34 -47 -50 -62 -23 -21 -32 -24 -43 -15 -11 10 -11 9 -2 -3 10 -13 -3 -25 -70 -73 -45 -31 -90 -57 -99 -57 -9 0 -19 -4 -23 -9 -6 -10 -158 65 -163 80 -2 5 -8 7 -13 3 -5 -3 -12 2 -15 10 -3 9 -11 16 -18 16 -38 0 -206 231 -192 266 3 8 1 14 -5 14 -6 0 -9 7 -5 15 3 8 1 15 -4 15 -14 0 -12 83 3 132 6 22 30 61 52 85 38 43 43 45 106 50 49 4 73 1 97 -11 42 -22 86 -66 108 -107 9 -19 19 -29 21 -22 14 40 -72 125 -149 148 -56 16 -70 17 -108 6z"/></g></svg>`; break;
                case 'kate': iconContainer.innerHTML = `<svg viewBox="0 0 100 100" class="w-full h-full"><rect x="10" y="25" width="80" height="50" rx="10" ry="10" fill="#F0C68C"/><path d="M 20 25 C 10 15, 10 5, 25 5 L 35 5 L 30 25 Z" fill="#6B4F4F"/><path d="M 80 25 C 90 15, 90 5, 75 5 L 65 5 L 70 25 Z" fill="#6B4F4F"/><circle cx="40" cy="45" r="5" fill="#2D2D2D"/><circle cx="60" cy="45" r="5" fill="#2D2D2D"/><path d="M 50 55 Q 45 60, 50 65 Q 55 60, 50 55 Z" fill="#2D2D2D"/><path d="M 35 70 C 40 65, 60 65, 65 70" stroke="#2D2D2D" stroke-width="3" fill="none"/><path d="M 30 35 Q 40 30, 50 35 Q 60 30, 70 35" stroke="#6B4F4F" stroke-width="2" fill="none"/></svg>`; break;
                default: iconContainer.textContent = 'S';
            }
            container.appendChild(iconContainer);
            return container;
        }

        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute('viewBox', '0 0 40 40');
        svg.style.width = '100%';
        svg.style.height = '100%';

        // **FIXED**: Swapped X and Y coordinates to rotate the pip patterns 90 degrees.
        const pipPositions = {
            1: [[20, 20]],
            2: [[10, 30], [30, 10]],
            3: [[10, 30], [20, 20], [30, 10]],
            4: [[10, 10], [30, 10], [10, 30], [30, 30]],
            5: [[10, 10], [30, 10], [20, 20], [10, 30], [30, 30]],
            6: [[10, 10], [20, 10], [30, 10], [10, 30], [20, 30], [30, 30]],
            7: [[10, 10], [20, 10], [30, 10], [20, 20], [10, 30], [20, 30], [30, 30]],
            8: [[10, 10], [20, 10], [30, 10], [10, 20], [30, 20], [10, 30], [20, 30], [30, 30]],
            9: [[10, 10], [20, 10], [30, 10], [10, 20], [20, 20], [30, 20], [10, 30], [20, 30], [30, 30]]
        };

        if (pipPositions[count]) {
            pipPositions[count].forEach(([cx, cy]) => {
                const circle = document.createElementNS(svgNS, "circle");
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', 4.5);
                circle.setAttribute('fill', PIP_COLORS[count] || '#000000');
                svg.appendChild(circle);
            });
        }
        
        container.appendChild(svg);
        return container;
    }

    // --- Touch, Drag, Drop, and Rotation Logic ---
    function getEventCoords(e) {
        return e.touches?.[0] || e.changedTouches?.[0] || e;
    }

    function startDominoDrag(e, dominoObject, origin) {
        e.stopPropagation();
        if (isDraggingDomino) return;

        const currentTurnPlayer = localGameState.players[localGameState.playerOrder[localGameState.currentPlayerIndex]];
        if (currentTurnPlayer.controller !== currentPlayerId) return;
        
        if (origin === 'hand' && localGameState.turnState !== 'WAITING') {
            showMessage("You can only play a tile when it is your turn to play.");
            return;
        }
        
        if (origin === 'board') {
            if (localGameState.turnState !== 'PLACED') {
                return;
            }
            const playedThisTurn = (localGameState.moveHistory || []).some(move => move.dominoId === dominoObject.dominoData.id);
            if (!playedThisTurn) {
                showMessage("You can only reposition tiles played this turn.");
                return;
            }
        }
        
        originalDominoElement = e.currentTarget;
        draggedDominoData = dominoObject;
        isDraggingDomino = true;
        wasDragged = false;
        dragStartTime = Date.now();
        
        const coords = getEventCoords(e);
        dragStartPos = { x: coords.clientX, y: coords.clientY };
        
        activeDominoElement = createDomino(draggedDominoData.dominoData);
        activeDominoElement.classList.add('dragging');
        document.body.appendChild(activeDominoElement);

        originalDominoElement.style.opacity = '0.3';

        const initialLeft = coords.clientX - (DOMINO_WIDTH / 2);
        const initialTop = coords.clientY - (DOMINO_HEIGHT / 2);
        
        const currentRotation = draggedDominoData.rotation || 0;
        activeDominoElement.style.transform = `translate3d(${initialLeft}px, ${initialTop}px, 0) scale(${zoomLevel}) rotate(${currentRotation}deg)`;

        dom.gameStatusElement.textContent = `Moving a tile...`;
        
        const moveHandler = (ev) => dragDomino(ev);
        const endHandler = (ev) => endDominoDrag(ev, origin, moveHandler, endHandler);

        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endHandler, { once: true });
        document.addEventListener('touchmove', moveHandler, { passive: false });
        document.addEventListener('touchend', endHandler, { once: true });
    }

    function dragDomino(e) {
        if (!isDraggingDomino || !activeDominoElement) return;
        e.preventDefault();
        const coords = getEventCoords(e);
        if (Math.abs(coords.clientX - dragStartPos.x) > 5 || Math.abs(coords.clientY - dragStartPos.y) > 5) {
            wasDragged = true;
        }
        
        const newLeft = coords.clientX - (DOMINO_WIDTH / 2);
        const newTop = coords.clientY - (DOMINO_HEIGHT / 2);

        const currentRotation = draggedDominoData.rotation || 0;
        activeDominoElement.style.transform = `translate3d(${newLeft}px, ${newTop}px, 0) scale(${zoomLevel}) rotate(${currentRotation}deg)`;
    }

    async function endDominoDrag(e, origin, moveHandler, endHandler) {
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('touchmove', moveHandler);
        
        if (!isDraggingDomino) return;
        
        const gameRef = doc(db, "games", currentGameId);
        const dragDuration = Date.now() - dragStartTime;
        const isTap = !wasDragged && dragDuration < 200;

        if (isTap && origin === 'board') {
            const currentRotation = parseInt(draggedDominoData.rotation || 0);
            const newRotation = (currentRotation + 45) % 360;

            if (originalDominoElement) {
                originalDominoElement.style.transform = `rotate(${newRotation}deg)`;
                originalDominoElement.dataset.rotation = newRotation;
                const rect = originalDominoElement.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                triggerParticleEffect(centerX, centerY);
            }

            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw "Game does not exist!";
                const gameState = gameSnap.data();
                let newMoveHistory = [...(gameState.moveHistory || [])];
                const newBoardDominos = [...gameState.boardDominos];
                const boardIndex = newBoardDominos.findIndex(d => d.dominoData.id === draggedDominoData.dominoData.id);
                if (boardIndex > -1) {
                    newMoveHistory.push({ type: 'rotate', dominoId: draggedDominoData.dominoData.id, from: newBoardDominos[boardIndex].rotation });
                    newBoardDominos[boardIndex].rotation = newRotation;
                    transaction.update(gameRef, { boardDominos: newBoardDominos, moveHistory: newMoveHistory });
                }
            });
        } else if (wasDragged) {
            const coords = getEventCoords(e);
            const worldRect = dom.worldElement.getBoundingClientRect();

            if (origin === 'hand' && (coords.clientX < worldRect.left || coords.clientX > worldRect.right || coords.clientY < worldRect.top || coords.clientY > worldRect.bottom)) {
                // Dragged outside, do nothing
            } else {
                const cursorX_relative = coords.clientX - worldRect.left;
                const cursorY_relative = coords.clientY - worldRect.top;

                const cursorX_onBoard = (cursorX_relative / zoomLevel) + boardPosition.x;
                const cursorY_onBoard = (cursorY_relative / zoomLevel) + boardPosition.y;

                const finalXOnBoard = cursorX_onBoard - (DOMINO_WIDTH / 2);
                const finalYOnBoard = cursorY_onBoard - (DOMINO_HEIGHT / 2);
                
                let newX = finalXOnBoard;
                let newY = finalYOnBoard;
                let newRotation = parseInt(originalDominoElement.dataset.rotation || 0);
                
                let isValidPlacement = true;
                if (localGameState.boardDominos.length === 0) {
                    const d = draggedDominoData.dominoData;
                    const required = localGameState.currentStartingDouble;
                    const isCorrectDouble = d.top === required && d.bottom === required;
                    const isDoubleSpinner = d.top === SPINNER_VALUE && d.bottom === SPINNER_VALUE;
                    if (!isCorrectDouble && !isDoubleSpinner) {
                        isValidPlacement = false;
                        showMessage(`Must start with Double ${required} or Double Spinner!`);
                    } else {
                        newX = (BOARD_SIZE / 2) - (DOMINO_WIDTH / 2);
                        newY = (BOARD_SIZE / 2) - (DOMINO_HEIGHT / 2);
                        newRotation = 90;
                    }
                }

                if (isValidPlacement) {
                    try {
                        // **FIXED**: Rewrote transaction for placing a tile to be more atomic and less prone to errors.
                        await runTransaction(db, async (transaction) => {
                            const gameSnap = await transaction.get(gameRef);
                            if (!gameSnap.exists()) throw "Game does not exist!";
                            const gameState = gameSnap.data();
                            const currentTurnPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
                            const currentTurnPlayer = gameState.players[currentTurnPlayerId];

                            if (origin === 'hand') {
                                const newHand = gameState.players[currentTurnPlayerId].hand.filter(d => d.id !== draggedDominoData.dominoData.id);
                                if (newHand.length === gameState.players[currentTurnPlayerId].hand.length) {
                                    throw new Error("Domino to be played not found in player's hand.");
                                }
                                const playedDomino = draggedDominoData.dominoData;
                                const newBoardDominos = [...gameState.boardDominos, { dominoData: playedDomino, x: newX, y: newY, rotation: newRotation, playerId: currentTurnPlayerId }];
                                const newLog = [...(gameState.log || []), `${currentTurnPlayer.name} played a tile.`];
                                if (newLog.length > 5) newLog.shift();
                                const newMoveHistory = [{ type: 'play', dominoId: playedDomino.id }];

                                transaction.update(gameRef, {
                                    boardDominos: newBoardDominos,
                                    [`players.${currentTurnPlayerId}.hand`]: newHand,
                                    turnState: 'PLACED',
                                    moveHistory: newMoveHistory,
                                    lastPlayedDominoId: playedDomino.id,
                                    log: newLog
                                });
                            } else { // origin === 'board'
                                const newBoardDominos = gameState.boardDominos.map(d => (d.dominoData.id === draggedDominoData.dominoData.id) ? { ...d, x: newX, y: newY } : d);
                                const newMoveHistory = [...(gameState.moveHistory || []), { type: 'reposition', dominoId: draggedDominoData.dominoData.id, from: { x: draggedDominoData.x, y: draggedDominoData.y } }];
                                transaction.update(gameRef, { boardDominos: newBoardDominos, moveHistory: newMoveHistory });
                            }
                        });
                        triggerRippleEffect(newX + DOMINO_WIDTH / 2, newY + DOMINO_HEIGHT / 2);
                    } catch (error) {
                        // **FIXED**: Added more detailed error logging to the console.
                        console.error("Firebase transaction for placing domino failed:", error);
                        showMessage("Error placing the domino. Please try again.");
                    }
                }
            }
        }
        
        // Cleanup drag elements
        if (originalDominoElement) originalDominoElement.style.opacity = '1';
        if (activeDominoElement) activeDominoElement.remove();
        activeDominoElement = null;
        originalDominoElement = null;
        draggedDominoData = null;
        isDraggingDomino = false;
    }

    // --- Pan and Zoom Logic ---
    function centerBoardOnStart() {
        zoomLevel = 1.0;
        boardPosition.x = (BOARD_SIZE / 2) - (dom.worldElement.clientWidth / 2);
        boardPosition.y = (BOARD_SIZE / 2) - (dom.worldElement.clientHeight / 2);
        updateBoardTransform();
    }

    function updateBoardTransform() {
        const viewWidth = dom.worldElement.clientWidth / zoomLevel;
        const viewHeight = dom.worldElement.clientHeight / zoomLevel;
        boardPosition.x = Math.max(0, Math.min(boardPosition.x, BOARD_SIZE - viewWidth));
        boardPosition.y = Math.max(0, Math.min(boardPosition.y, BOARD_SIZE - viewHeight));

        dom.gameBoardElement.style.transform = `scale(${zoomLevel}) translate(${-boardPosition.x}px, ${-boardPosition.y}px)`;
        updateMinimap(localGameState.boardDominos || []);
    }
    
    function updateMinimap(boardDominos) {
        if (!dom.minimapContainer) return;
        const mapSize = dom.minimapContainer.clientWidth;
        const scale = mapSize / BOARD_SIZE;
        const viewWidth = dom.worldElement.clientWidth / zoomLevel;
        const viewHeight = dom.worldElement.clientHeight / zoomLevel;
        dom.minimapViewport.style.width = `${viewWidth * scale}px`;
        dom.minimapViewport.style.height = `${viewHeight * scale}px`;
        dom.minimapViewport.style.left = `${boardPosition.x * scale}px`;
        dom.minimapViewport.style.top = `${boardPosition.y * scale}px`;
        
        dom.minimapContainer.querySelectorAll('.minimap-dot').forEach(dot => dot.remove());
        boardDominos.forEach(domino => {
            const dot = document.createElement('div');
            dot.className = 'minimap-dot';
            dot.style.left = `${(domino.x + DOMINO_WIDTH / 2) * scale}px`;
            dot.style.top = `${(domino.y + DOMINO_HEIGHT / 2) * scale}px`;
            
            const player = localGameState.players[domino.playerId];
            if (player && player.color) {
                dot.style.backgroundColor = player.color;
                dot.style.borderColor = player.color;
            }

            dot.style.transform = `translate(-50%, -50%) rotate(${domino.rotation}deg)`;

            dot.addEventListener('click', (e) => {
                e.stopPropagation();
                boardPosition.x = domino.x - (viewWidth / 2) + (DOMINO_WIDTH / 2);
                boardPosition.y = domino.y - (viewHeight / 2) + (DOMINO_HEIGHT / 2);
                updateBoardTransform();
            });
            dom.minimapContainer.appendChild(dot);
        });
    }
    
    dom.worldElement.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        if (isDraggingDomino) return;
        if (e.target !== dom.worldElement && e.target !== dom.gameBoardElement && e.target.id !== 'world-wrapper') return;
        
        isPanning = true;
        dom.worldElement.classList.add('panning');
        const coords = getEventCoords(e);
        panStart = { x: coords.clientX, y: coords.clientY };
        
        const panMove = (ev) => pan(ev);
        const endPanMove = () => endPan(panMove, endPanMove);

        document.addEventListener('mousemove', panMove);
        document.addEventListener('mouseup', endPanMove, { once: true });
    });

    function pan(e) {
        if (!isPanning) return;
        const coords = getEventCoords(e);
        const dx = coords.clientX - panStart.x;
        const dy = coords.clientY - panStart.y;
        boardPosition.x -= dx / zoomLevel;
        boardPosition.y -= dy / zoomLevel;
        panStart = { x: coords.clientX, y: coords.clientY };
        updateBoardTransform();
    }

    function endPan(panMove, endPanMove) {
        isPanning = false;
        dom.worldElement.classList.remove('panning');
        document.removeEventListener('mousemove', panMove);
        document.removeEventListener('mouseup', endPanMove);
    }
    
    dom.worldElement.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1 && !isDraggingDomino) {
             if (e.target !== dom.worldElement && e.target !== dom.gameBoardElement && e.target.id !== 'world-wrapper') return;
             isPanning = true;
             dom.worldElement.classList.add('panning');
             const coords = getEventCoords(e);
             panStart = { x: coords.clientX, y: coords.clientY };
        }
    }, { passive: false });

    dom.worldElement.addEventListener('touchmove', (e) => {
        if (isPanning && e.touches.length === 1) {
            pan(e);
        }
    }, { passive: false });

    dom.worldElement.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) {
            isPanning = false;
            dom.worldElement.classList.remove('panning');
        }
    });

    function handleZoom(delta, clientX, clientY) {
        const rect = dom.worldElement.getBoundingClientRect();
        const mouseX = clientX - rect.left;
        const mouseY = clientY - rect.top;
        const worldX_before = (mouseX / zoomLevel) + boardPosition.x;
        const worldY_before = (mouseY / zoomLevel) + boardPosition.y;
        
        const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel * (1 + delta)));
        
        boardPosition.x = worldX_before - (mouseX / newZoom);
        boardPosition.y = worldY_before - (mouseY / newZoom);
        zoomLevel = newZoom;
        updateBoardTransform();
    }

    function zoomWithControls(delta) {
        const rect = dom.worldElement.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        handleZoom(delta, centerX, centerY);
    }

    dom.zoomInButton.addEventListener('click', () => zoomWithControls(0.2));
    dom.zoomOutButton.addEventListener('click', () => zoomWithControls(-0.2));

    dom.minimapContainer.addEventListener('click', (e) => {
        e.stopPropagation();
        if (e.target.classList.contains('minimap-dot') || e.target.id === 'minimap-viewport') {
            return;
        }

        const mapSize = dom.minimapContainer.clientWidth;
        const scale = mapSize / BOARD_SIZE;

        const clickXOnMap = e.offsetX;
        const clickYOnMap = e.offsetY;

        const targetBoardX = clickXOnMap / scale;
        const targetBoardY = clickYOnMap / scale;

        const viewWidth = dom.worldElement.clientWidth / zoomLevel;
        const viewHeight = dom.worldElement.clientHeight / zoomLevel;
        
        boardPosition.x = targetBoardX - (viewWidth / 2);
        boardPosition.y = targetBoardY - (viewHeight / 2);

        updateBoardTransform();
    });

    // --- Undo and Theme Logic ---
    dom.undoButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        await runTransaction(db, async (transaction) => {
            const gameSnap = await transaction.get(gameRef);
            if (!gameSnap.exists()) return;
            const gameState = gameSnap.data();
            if (!gameState.moveHistory || gameState.moveHistory.length === 0) return;

            const newMoveHistory = [...gameState.moveHistory];
            const lastMove = newMoveHistory.pop();
            const newBoardDominos = [...gameState.boardDominos];
            const dominoIndex = newBoardDominos.findIndex(d => d.dominoData.id === lastMove.dominoId);

            if (dominoIndex > -1) {
                if (lastMove.type === 'reposition') {
                    newBoardDominos[dominoIndex].x = lastMove.from.x;
                    newBoardDominos[dominoIndex].y = lastMove.from.y;
                } else if (lastMove.type === 'rotate') {
                    newBoardDominos[dominoIndex].rotation = lastMove.from;
                }
                transaction.update(gameRef, { boardDominos: newBoardDominos, moveHistory: newMoveHistory });
            }
        });
    });

    dom.rotateLastTileButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        const lastPlayedId = localGameState.lastPlayedDominoId;
        if (!lastPlayedId) return;

        const dominoEl = dom.gameBoardElement.querySelector(`.domino[data-id="${lastPlayedId}"]`);
        if (dominoEl) {
            const currentRotation = parseInt(dominoEl.dataset.rotation || 0);
            const newRotation = (currentRotation + 45) % 360;
            dominoEl.style.transform = `rotate(${newRotation}deg)`;
            dominoEl.dataset.rotation = newRotation;
            const rect = dominoEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            triggerParticleEffect(centerX, centerY);
        }

        await runTransaction(db, async (transaction) => {
            const gameSnap = await transaction.get(gameRef);
            if (!gameSnap.exists()) return;
            const gameState = gameSnap.data();
            if (!gameState.lastPlayedDominoId) return;

            const newBoardDominos = [...gameState.boardDominos];
            const boardIndex = newBoardDominos.findIndex(d => d.dominoData.id === gameState.lastPlayedDominoId);

            if (boardIndex > -1) {
                const currentRotation = newBoardDominos[boardIndex].rotation;
                const newRotation = (currentRotation + 45) % 360;
                newBoardDominos[boardIndex].rotation = newRotation;
                transaction.update(gameRef, { boardDominos: newBoardDominos });
            }
        });
    });

    dom.themeSwitcher.addEventListener('change', async (e) => {
        if (currentGameId) {
            const gameRef = doc(db, "games", currentGameId);
            await updateDoc(gameRef, { currentTheme: e.target.value });
        }
    });

    // --- Validation & Challenge Logic ---
    dom.validateMoveButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) return;
                const gameState = gameSnap.data();
                
                if (gameState.turnState !== 'PENDING_VALIDATION') {
                    return; 
                }

                const currentTurnPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
                const playerHand = gameState.players[currentTurnPlayerId].hand;

                if (playerHand.length === 0) {
                    let roundPoints = {};
                    let scoreHistoryEntry = { round: gameState.roundNumber, scores: {} };
                    const updatedPlayers = { ...gameState.players };

                    Object.keys(updatedPlayers).forEach(pid => {
                        const handValue = (pid === currentTurnPlayerId) ? 0 : calculateHandValue(updatedPlayers[pid].hand);
                        updatedPlayers[pid].score += handValue;
                        roundPoints[pid] = handValue;
                        scoreHistoryEntry.scores[pid] = handValue;
                    });
                    
                    const newScoreHistory = [...(gameState.scoreHistory || []), scoreHistoryEntry];
                    const isGameOver = gameState.roundNumber >= 10;

                    transaction.update(gameRef, {
                        players: updatedPlayers,
                        gameStatus: isGameOver ? 'finished' : 'round-over',
                        roundEndInfo: { winnerId: currentTurnPlayerId, points: roundPoints },
                        turnState: 'WAITING',
                        hasDrawn: false,
                        scoreHistory: newScoreHistory
                    });
                } else {
                    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.playerOrder.length;
                    const nextPlayerId = gameState.playerOrder[nextPlayerIndex];
                    const nextPlayerName = gameState.players[nextPlayerId].name;
                    const validatorName = gameState.players[currentPlayerId].name;
                    const newLog = [...(gameState.log || []), `${validatorName} validated the move. It's now ${nextPlayerName}'s turn.`];
                    if (newLog.length > 5) newLog.shift();

                    // NEW: Check if turn is passing between two local players on the same device.
                    const currentPlayerController = gameState.players[currentTurnPlayerId].controller;
                    const nextPlayerController = gameState.players[nextPlayerId].controller;
                    const needsConfirmation = (currentPlayerController === nextPlayerController);

                    transaction.update(gameRef, {
                        currentPlayerIndex: nextPlayerIndex,
                        turnState: 'WAITING',
                        hasDrawn: false,
                        moveHistory: [],
                        lastPlayedDominoId: null,
                        log: newLog,
                        turnConfirmationPending: needsConfirmation // Set the flag
                    });
                }
            });
        } catch(error) {
            console.error("Validation failed:", error);
            showMessage("Could not validate the move. Please try again.");
        }
    });

    dom.challengeMoveButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) return;
                const gameState = gameSnap.data();

                if (gameState.turnState !== 'PENDING_VALIDATION') {
                    return; // Move already validated or challenged
                }

                const challengerName = gameState.players[currentPlayerId].name;
                const challengedPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
                const challengedPlayerName = gameState.players[challengedPlayerId].name;

                const newBoardDominos = [...gameState.boardDominos];
                const challengedDominoIndex = newBoardDominos.findIndex(d => d.dominoData.id === gameState.lastPlayedDominoId);

                if (challengedDominoIndex > -1) {
                    const challengedDomino = newBoardDominos.splice(challengedDominoIndex, 1)[0];
                    const updatedPlayers = { ...gameState.players };
                    updatedPlayers[challengedPlayerId].hand.push(challengedDomino.dominoData);

                    const newLog = [...(gameState.log || []), `${challengerName} challenged ${challengedPlayerName}'s move! Tile returned.`];
                    if (newLog.length > 5) newLog.shift();

                    transaction.update(gameRef, {
                        boardDominos: newBoardDominos,
                        players: updatedPlayers,
                        turnState: 'WAITING',
                        hasDrawn: false,
                        lastPlayedDominoId: null,
                        moveHistory: [],
                        log: newLog
                    });
                }
            });
        } catch(error) {
            console.error("Challenge failed:", error);
            showMessage("Could not challenge the move. Please try again.");
        }
    });
    
    // --- Detailed Scoreboard Rendering ---
    function renderDetailedScoreboard(gameState) {
        const { scoreHistory, players, playerOrder } = gameState;
        if (!scoreHistory || !dom.detailedScoreboardContent) return;

        dom.detailedScoreboardContent.innerHTML = ''; // Clear previous content

        const table = document.createElement('table');
        table.id = 'detailed-scoreboard-table';

        // Header
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const roundHeader = document.createElement('th');
        roundHeader.textContent = 'R';
        headerRow.appendChild(roundHeader);
        playerOrder.forEach(pid => {
            const th = document.createElement('th');
            th.textContent = players[pid].name.substring(0, 3); // Abbreviate name
            headerRow.appendChild(th);
        });

        // Body
        const tbody = table.createTBody();
        scoreHistory.forEach(roundData => {
            const row = tbody.insertRow();
            row.insertCell().textContent = roundData.round;
            playerOrder.forEach(pid => {
                row.insertCell().textContent = roundData.scores[pid] ?? '0';
            });
        });

        // Footer (Total)
        const tfoot = table.createTFoot();
        const totalRow = tfoot.insertRow();
        totalRow.className = 'total-row';
        const totalCell = totalRow.insertCell();
        totalCell.textContent = 'Total';
        playerOrder.forEach(pid => {
            const cell = totalRow.insertCell();
            cell.textContent = players[pid].score;
        });

        dom.detailedScoreboardContent.appendChild(table);
    }

    // --- Animation Functions ---
    function triggerConfetti(color) {
        const container = document.querySelector('.confetti-container');
        if (!container) return;

        for (let i = 0; i < 100; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = `${Math.random() * 100}vw`;
            confetti.style.animationDelay = `${Math.random() * 2}s`;
            confetti.style.backgroundColor = color || PLAYER_COLORS[Math.floor(Math.random() * PLAYER_COLORS.length)];
            confetti.style.transform = `scale(${Math.random() * 0.5 + 0.5})`;
            container.appendChild(confetti);

            setTimeout(() => {
                confetti.remove();
            }, 3000);
        }
    }

    function triggerParticleEffect(x, y) {
        const container = document.getElementById('particle-container');
        if (!container) return;
        const particleCount = 20; // Increased count
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;

            const angle = Math.random() * 2 * Math.PI;
            const distance = (Math.random() * 60 + 30) * zoomLevel; // Increased distance and scaled by zoom
            const endX = Math.cos(angle) * distance;
            const endY = Math.sin(angle) * distance;

            particle.style.setProperty('--x', `${endX}px`);
            particle.style.setProperty('--y', `${endY}px`);
            particle.style.setProperty('--start-scale', zoomLevel);
            particle.style.backgroundColor = PLAYER_COLORS[Math.floor(Math.random() * PLAYER_COLORS.length)];
            const size = (Math.random() * 4 + 4) * zoomLevel; // Increased size and scaled by zoom
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;

            container.appendChild(particle);
            setTimeout(() => particle.remove(), 500);
        }
    }

    function triggerRippleEffect(boardX, boardY) {
        const ripple = document.createElement('div');
        ripple.className = 'ripple';
        ripple.style.left = `${boardX}px`;
        ripple.style.top = `${boardY}px`;
        dom.gameBoardElement.appendChild(ripple);
        setTimeout(() => {
            ripple.remove();
        }, 700);
    }


    // --- Initial Load ---
    window.onload = initializeFirebase;
</script>
</body>
</html>
