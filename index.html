<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport"/>
    <title>Spinner after Dinner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&amp;display=swap" rel="stylesheet"/>
    <style>
        /* General Body and Layout Styles */
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
            user-select: none;
            touch-action: none;
            background-color: #1f2937; /* bg-gray-800 */
        }

        /* Game World and Board Styles */
        #world {
            position: relative;
            overflow: hidden;
            cursor: grab;
            width: 100%;
            height: 100%;
            background-color: #00693E; /* Felt Green */
            background-image: radial-gradient(rgba(255, 255, 255, 0.05) 10%, transparent 0);
            background-size: 5px 5px;
            border-radius: 20px; /* Rounded corners for the table */
        }
        #world.panning {
            cursor: grabbing;
        }
        #game-board {
            position: absolute;
            width: 2500px;
            height: 2500px;
            transform-origin: top left;
        }
        #starting-area {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 42px;
            height: 82px;
            border: 2px dashed rgba(255, 255, 255, 0.4);
            border-radius: 8px;
        }

        /* Domino Styles */
        .domino {
            width: 80px;
            height: 40px;
            border: 1px solid #1a1a1a;
            background-color: #f7f7f7;
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-radius: 6px;
            cursor: grab;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2), inset 0 0 2px rgba(0,0,0,0.2);
            transform-origin: center center;
            color: #1a1a1a;
            transition: box-shadow 0.2s ease, transform 0.3s ease, top 0.3s ease, left 0.3s ease;
        }
        .domino.domino-back {
            background-color: #f7f7f7; /* Ivory color for opponent hands */
            border: 1px solid #a0aec0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            position: relative;
        }
        .domino.domino-back::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 10%;
            height: 80%;
            width: 2px;
            background-color: rgba(0,0,0,0.1);
            transform: translateX(-50%);
        }
        .player-hand .domino {
            position: relative;
        }
        #game-board .domino {
            position: absolute;
        }
        .domino.selected {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.9), 0 0 5px rgba(255, 215, 0, 0.7);
            border-color: #FFD700;
            z-index: 1000;
        }
        .domino.dragging {
            cursor: grabbing;
            transition: none;
            z-index: 3000; /* Ensure dragged domino is on top */
            box-shadow: 0 5px 15px rgba(0,0,0,0.5), inset 0 0 2px rgba(0,0,0,0.2);
            pointer-events: none; /* Crucial for drag-and-drop to register drop targets */
        }

        /* Pip and Spinner Styles */
        .pip-container {
            width: 50%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            align-items: center;
            justify-items: center;
            padding: 4px;
            pointer-events: none;
        }
        .divider {
            width: 2px;
            height: 80%;
            background-color: #1a1a1a;
            pointer-events: none;
        }
        .pip {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
        }
        .pip-color-0 { background-color: #cbd5e0; }
        .pip-color-1 { background-color: #EADCA6; }
        .pip-color-2 { background-color: #8B0000; }
        .pip-color-3 { background-color: #800000; }
        .pip-color-4 { background-color: #00BFFF; }
        .pip-color-5 { background-color: #006400; }
        .pip-color-6 { background-color: #000000; }
        .pip-color-7 { background-color: #A0522D; }
        .pip-color-8 { background-color: #9370DB; }
        .pip-color-9 { background-color: #808080; }
        .spinner-icon {
            width: 24px;
            height: 24px;
            grid-column: 1 / -1;
            grid-row: 1 / -1;
            font-size: 11px;
            line-height: 1.1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .spinner-icon svg, .spinner-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* UI Components */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #boneyard-pile {
            border: 2px dashed #a0aec0;
            min-height: 50px;
            min-width: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            position: relative;
        }
        #boneyard-pile:hover {
            background-color: rgba(255,255,255,0.1);
        }
        .boneyard-domino {
            position: absolute;
            background-color: #f7f7f7; /* Ivory color */
            border: 1px solid #a0aec0;
            transition: all 0.3s ease;
        }
        #boneyard-count {
            position: absolute;
            z-index: 10;
            font-size: 2rem;
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.6);
            padding: 2px 10px;
            border-radius: 12px;
            text-shadow: 0 0 5px #000;
        }
        #boneyard-message {
            position: absolute;
            z-index: 11;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 3px #000;
            pointer-events: none;
        }
        @keyframes flash-border {
            0%, 100% { border-color: #a0aec0; }
            50% { border-color: #FFD700; }
        }
        #boneyard-pile.can-draw {
            animation: flash-border 1.5s infinite;
        }
        #minimap-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            z-index: 2000;
        }
        #minimap-viewport {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }
        .minimap-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: white;
            border-radius: 50%;
            pointer-events: auto;
            cursor: pointer;
            border: 1px solid white;
            box-shadow: 0 0 5px rgba(255,255,255,0.6);
        }
        .opponent-hand-section {
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            transition: all 0.3s ease;
            background-color: rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }
        .opponent-hand-section.current-player {
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        #setup-screen, #round-end-screen, #loading-screen, #game-over-screen, #message-modal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* IPAD FIX */
        #setup-screen > div {
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        .hidden {
            display: none !important;
        }
        #final-score-display, #round-end-content, #message-modal-content {
            background-color: rgba(0,0,0,0.9);
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            color: white;
        }
        .winner {
            color: #FFD700;
            font-weight: bold;
        }
        #drag-label {
            position: fixed;
            transform: translate(-50%, -120%);
            z-index: 3000;
            pointer-events: none;
        }

        /* --- LAYOUT STYLES --- */
        #game-container {
            height: 100%;
            width: 100%;
        }
        #game-layout {
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: 100%; /* IPAD FIX */
            width: 100%;
            padding: 1rem;
            gap: 1rem;
        }
        #game-info { grid-row: 1 / 2; }
        #main-game-area {
            grid-row: 2 / 3;
            position: relative;
            display: grid;
            place-items: center;
            min-height: 0; /* IPAD FIX */
        }
        #main-game-area > * {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
        }
        #world-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #opponent-hands-container {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        #top-hand-area, #left-hand-area, #right-hand-area {
            position: absolute;
            pointer-events: auto;
        }
        #top-hand-area {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 700px;
        }
        #left-hand-area {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            height: 80%;
            max-height: 500px;
        }
        #right-hand-area {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            height: 80%;
            max-height: 500px;
        }
        .side-hand-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            align-content: start;
            overflow-y: auto;
            flex-grow: 1;
        }
        .top-hand {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            overflow-x: auto;
            flex-grow: 1;
        }
        .side-hand-grid .domino {
            transform: rotate(90deg);
        }

        #bottom-hand-area {
            grid-row: 3 / 4;
            display: flex;
            justify-content: center;
            align-items: center; /* Changed from flex-end */
            gap: 1.5rem; /* Increased gap */
            width: 100%;
        }
        .player-hand {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            max-width: 600px;
            overflow-y: auto; /* IPAD FIX */
        }
        #my-hand-container {
            display: flex;
            justify-content: center;
            max-height: 150px; /* IPAD FIX */
            flex-grow: 1; /* Allow hand to take up space */
        }
        #boneyard-container {
            flex-shrink: 0; /* Prevent boneyard from shrinking */
        }
        #boneyard-buttons {
            flex-direction: row; /* Align buttons horizontally */
        }

        @media (max-width: 768px) {
            #game-layout {
                padding: 0.5rem;
                gap: 0.5rem;
            }
            #game-info { flex-direction: column; align-items: stretch; }
            #bottom-hand-area {
                flex-direction: column;
                align-items: center;
            }
            .domino { width: 60px; height: 30px; }
            .pip { width: 6px; height: 6px; }
            .spinner-icon { width: 18px; height: 18px; }
            #left-hand-area, #right-hand-area { display: none; }
            #top-hand-area { width: 95%; }
        }
    </style>
</head>
<body class="text-white">

<!-- Message Modal -->
<div id="message-modal" class="hidden">
    <div id="message-modal-content" class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm">
        <p id="message-text" class="text-lg mb-4"></p>
        <button id="message-ok-button" class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-2 px-3 rounded transition-colors">OK</button>
    </div>
</div>

<!-- Drag Label -->
<div class="hidden bg-black bg-opacity-70 text-white px-3 py-1 rounded-lg" id="drag-label"></div>
<!-- Loading Screen -->
<div id="loading-screen">
<div class="text-center">
<h1 class="text-3xl font-bold">Connecting to Game Service...</h1>
<p id="auth-status">Initializing...</p>
</div>
</div>
<!-- Setup / Lobby Screen -->
<div class="hidden" id="setup-screen">
<div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-white w-full max-w-md">
<h1 class="text-3xl font-bold text-center mb-6">Spinner after Dinner</h1>
<div id="lobby-view">
<div class="mb-4">
<label class="block mb-2" for="player-name">Your Name:</label>
<input class="w-full p-2 rounded bg-gray-700 text-white" id="player-name" placeholder="Enter your name" type="text"/>
</div>
<div class="flex gap-4 mb-6">
<button class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors" disabled="" id="create-game-button">Create New Game</button>
</div>
<div class="text-center my-4">OR</div>
<div class="mb-4">
<label class="block mb-2" for="join-game-id">Join Existing Game:</label>
<input class="w-full p-2 rounded bg-gray-700 text-white" id="join-game-id" placeholder="Enter Game ID" type="text"/>
</div>
<button class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 px-4 rounded transition-colors" disabled="" id="join-game-button">Join Game</button>
</div>
<div class="hidden text-center" id="waiting-room-view">
<h2 class="text-2xl font-bold mb-4">Waiting Room</h2>
<p class="mb-2">Share this Game ID with others:</p>
<div class="bg-gray-900 p-3 rounded-lg mb-4">
<span class="text-2xl font-mono text-yellow-300" id="game-id-display"></span>
<button class="ml-4 bg-gray-600 hover:bg-gray-500 text-sm py-1 px-2 rounded" id="copy-game-id">Copy</button>
</div>
<p class="mb-2 font-bold">Players Joined:</p>
<div class="space-y-2 mb-6" id="player-list"></div>
<p class="mb-4 text-gray-400" id="waiting-message">Waiting for more players...</p>
<button class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors" disabled="" id="start-game-button">Start Game</button>
</div>
</div>
</div>
<!-- Round End Screen -->
<div class="hidden" id="round-end-screen">
<div class="w-full max-w-md" id="round-end-content">
<h2 class="text-3xl font-bold text-center mb-4" id="round-end-title">Round Over!</h2>
<p class="text-xl text-yellow-300 mb-4" id="round-winner-message"></p>
<div class="mb-6" id="round-results-list"></div>
<button class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded transition-colors" id="continue-round-button">Continue</button>
</div>
</div>
<!-- Game Over Screen -->
<div class="hidden" id="game-over-screen">
<div class="w-full max-w-md" id="final-score-display">
<h2 class="text-4xl font-bold text-center mb-4 text-yellow-300">Game Over!</h2>
<p class="text-xl mb-6" id="final-winner-message"></p>
<div class="space-y-2 text-lg mb-8" id="final-score-list"></div>
<button class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded transition-colors" id="main-menu-button-final">Main Menu</button>
</div>
</div>
<!-- Main Game Container -->
<div class="hidden" id="game-container">
<div id="game-layout">
<div class="bg-gray-900 bg-opacity-70 p-2 rounded-lg shadow-lg flex justify-between items-center flex-wrap" id="game-info">
<div class="flex items-center gap-4">
<button class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors" id="main-menu-button">New Game / Exit</button>
<div>
<h2 class="font-bold text-lg">Current Turn: <span id="current-player"></span></h2>
<p class="text-sm text-yellow-300" id="game-status">Loading...</p>
</div>
</div>
<div class="flex items-center gap-4">
<button class="bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-2 px-4 rounded transition-colors" id="re-deal-button">Re-Deal</button>
<div class="text-right">
<p class="text-xs text-gray-400">Game ID</p>
<p class="font-mono text-yellow-300" id="game-id-header"></p>
</div>
<select class="bg-gray-700 text-white rounded p-2" id="theme-switcher">
<option value="classic">Classic</option>
<option value="dr_edell">Dr. Edell</option>
<option value="austin">Austin</option>
<option value="rose">Rose</option>
<option value="anna">Anna</option>
<option value="kate">Kate</option>
</select>
<div class="text-right flex gap-4" id="scoreboard"></div>
</div>
</div>
<div id="main-game-area">
<div id="opponent-hands-container">
<div id="top-hand-area"></div>
<div id="left-hand-area"></div>
<div id="right-hand-area"></div>
</div>
<div id="world-wrapper">
<div id="world">
<div id="starting-area"></div>
</div>
<div id="minimap-container">
<div id="minimap-viewport"></div>
</div>
</div>
</div>
<div id="bottom-hand-area">
<div class="flex-grow" id="my-hand-container"></div>
<div class="bg-gray-900 bg-opacity-70 p-4 rounded-lg shadow-inner" id="boneyard-container">
<h2 class="text-xl font-semibold mb-3 text-center">Boneyard</h2>
<div id="boneyard-pile" title="Click to draw a domino">
<span id="boneyard-count">0</span>
</div>
<div class="mt-2 flex items-center gap-2" id="boneyard-buttons">
<button class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors" id="undo-button">Undo Move</button>
<button class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors hidden" id="end-turn-button">End Turn</button>
</div>
</div>
</div>
</div>
</div>
<!-- Firebase SDK -->
<script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

    // --- DOM Elements ---
    const loadingScreen = document.getElementById('loading-screen');
    const authStatus = document.getElementById('auth-status');
    const setupScreen = document.getElementById('setup-screen');
    const gameContainer = document.getElementById('game-container');
    const lobbyView = document.getElementById('lobby-view');
    const waitingRoomView = document.getElementById('waiting-room-view');
    const createGameButton = document.getElementById('create-game-button');
    const joinGameButton = document.getElementById('join-game-button');
    const startGameButton = document.getElementById('start-game-button');
    const reDealButton = document.getElementById('re-deal-button');
    const playerNameInput = document.getElementById('player-name');
    const joinGameIdInput = document.getElementById('join-game-id');
    const gameIdDisplay = document.getElementById('game-id-display');
    const gameIdHeader = document.getElementById('game-id-header');
    const copyGameIdButton = document.getElementById('copy-game-id');
    const playerList = document.getElementById('player-list');
    const waitingMessage = document.getElementById('waiting-message');
    const worldElement = document.getElementById('world');
    const gameBoardElement = document.getElementById('game-board');
    const boneyardPileElement = document.getElementById('boneyard-pile');
    const boneyardCountElement = document.getElementById('boneyard-count');
    const currentPlayerElement = document.getElementById('current-player');
    const endTurnButton = document.getElementById('end-turn-button');
    const undoButton = document.getElementById('undo-button');
    const gameStatusElement = document.getElementById('game-status');
    const myHandContainer = document.getElementById('my-hand-container');
    const topHandArea = document.getElementById('top-hand-area');
    const leftHandArea = document.getElementById('left-hand-area');
    const rightHandArea = document.getElementById('right-hand-area');
    const scoreboard = document.getElementById('scoreboard');
    const themeSwitcher = document.getElementById('theme-switcher');
    const roundEndScreen = document.getElementById('round-end-screen');
    const roundEndTitle = document.getElementById('round-end-title');
    const roundWinnerMessage = document.getElementById('round-winner-message');
    const roundResultsList = document.getElementById('round-results-list');
    const continueRoundButton = document.getElementById('continue-round-button');
    const minimapContainer = document.getElementById('minimap-container');
    const minimapViewport = document.getElementById('minimap-viewport');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalWinnerMessage = document.getElementById('final-winner-message');
    const finalScoreList = document.getElementById('final-score-list');
    const mainMenuButton = document.getElementById('main-menu-button');
    const mainMenuButtonFinal = document.getElementById('main-menu-button-final');
    const dragLabel = document.getElementById('drag-label');
    const messageModal = document.getElementById('message-modal');
    const messageText = document.getElementById('message-text');
    const messageOkButton = document.getElementById('message-ok-button');
    
    // --- Firebase & Game State ---
    let db, auth, analytics;
    let currentGameId = null;
    let currentPlayerId = null;
    let localGameState = {}; // Local copy of the game state from Firestore
    let unsubscribeGameListener = null; // To stop listening to game updates

    const SPINNER_VALUE = -1;
    const BOARD_SIZE = 2500;
    const DOMINO_WIDTH = 80;
    const DOMINO_HEIGHT = 40;
    
    // --- Interaction State ---
    let isDraggingDomino = false;
    let wasDragged = false;
    let dragStartPos = { x: 0, y: 0 };
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let boardPosition = { x: 0, y: 0 };
    let zoomLevel = 1.0;
    const MIN_ZOOM = 0.3;
    const MAX_ZOOM = 3.0;
    let dominoOffsetX = 0;
    let dominoOffsetY = 0;
    let initialPinchDistance = null;
    let activeDominoElement = null; // The visual element being dragged
    let draggedDominoData = null; // The data object for the domino being dragged
    let originalHandElement = null; // The original domino element in the hand

    // --- Firebase Initialization ---
    async function initializeFirebase() {
        try {
            // Your web app's Firebase configuration
            const firebaseConfig = {
                apiKey: "AIzaSyCTmUo5UpQW77xhOkI_3XELSISo6WHyqLs",
                authDomain: "spinner-live.firebaseapp.com",
                projectId: "spinner-live",
                storageBucket: "spinner-live.firebasestorage.app",
                messagingSenderId: "878930500451",
                appId: "1:878930500451:web:e281c28d5c29218044d156",
                measurementId: "G-BPHD3B8WDT"
            };
            
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            analytics = getAnalytics(app);

            authStatus.textContent = 'Authenticating...';
            
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    // User is signed in.
                    currentPlayerId = user.uid;
                    enableLobby();
                } else {
                    // User is signed out. Attempt to sign in anonymously.
                    await signInAnonymously(auth);
                }
            });
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            authStatus.textContent = "Error: Could not connect. Please refresh.";
            showMessage(`Firebase Error: ${error.message}`);
        }
    }
    
    function showMessage(message) {
        messageText.textContent = message;
        messageModal.classList.remove('hidden');
    }

    messageOkButton.addEventListener('click', () => {
        messageModal.classList.add('hidden');
    });
    
    function enableLobby() {
        authStatus.textContent = 'Ready to Play!';
        loadingScreen.classList.add('hidden');
        setupScreen.classList.remove('hidden');
        createGameButton.disabled = false;
        joinGameButton.disabled = false;
    }

    // --- Lobby and Game Setup ---
    createGameButton.addEventListener('click', async () => {
        if (!currentPlayerId) return;
        const playerName = playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;
        
        const tempGameRef = doc(collection(db, 'games'));
        const gameId = tempGameRef.id.substring(0, 6).toUpperCase();
        const gameRef = doc(db, "games", gameId);

        const initialGameState = {
            players: {
                [currentPlayerId]: { name: playerName, score: 0, hand: [], isHost: true }
            },
            gameStatus: 'waiting',
            boardDominos: [],
            boneyard: [],
            currentPlayerIndex: 0,
            playerOrder: [currentPlayerId],
            roundNumber: 0,
            currentStartingDouble: 9,
            turnState: 'WAITING',
            mustDrawToStart: false,
            lastDrawnDominoId: null,
            moveHistory: [],
            currentTheme: 'classic',
            actionStatus: null,
            createdAt: serverTimestamp()
        };

        await setDoc(gameRef, initialGameState);
        await joinGame(gameId);
    });

    joinGameButton.addEventListener('click', async () => {
        if (!currentPlayerId) return;
        const gameId = joinGameIdInput.value.trim().toUpperCase();
        const playerName = playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;
        if (!gameId || !playerName) {
            showMessage("Please enter your name and a Game ID.");
            return;
        }

        const gameRef = doc(db, "games", gameId);
        const gameSnap = await getDoc(gameRef);

        if (!gameSnap.exists()) {
            showMessage("Game not found. Please check the ID.");
            return;
        }
        
        const gameData = gameSnap.data();
        if(Object.keys(gameData.players).length >= 8) {
            showMessage("This game is full (max 8 players).");
            return;
        }
        
        if(gameData.gameStatus !== 'waiting') {
            showMessage("This game has already started.");
            return;
        }

        await updateDoc(gameRef, {
            [`players.${currentPlayerId}`]: { name: playerName, score: 0, hand: [], isHost: false },
            playerOrder: [...gameData.playerOrder, currentPlayerId]
        });
        
        await joinGame(gameId);
    });

    async function joinGame(gameId) {
        currentGameId = gameId;
        lobbyView.classList.add('hidden');
        waitingRoomView.classList.remove('hidden');
        gameIdDisplay.textContent = gameId;
        
        if (unsubscribeGameListener) unsubscribeGameListener();
        unsubscribeGameListener = onSnapshot(doc(db, "games", currentGameId), (docSnap) => {
            if (docSnap.exists()) {
                handleGameStateUpdate(docSnap.data());
            } else {
                showMessage("The game has ended or was deleted.");
                leaveGame();
            }
        });
    }

    function leaveGame() {
        window.location.reload();
    }
    mainMenuButton.addEventListener('click', leaveGame);
    mainMenuButtonFinal.addEventListener('click', leaveGame);

    copyGameIdButton.addEventListener('click', () => {
        const textArea = document.createElement("textarea");
        textArea.value = currentGameId;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            copyGameIdButton.textContent = 'Copied!';
        } catch (err) {
            console.error('Failed to copy: ', err);
            copyGameIdButton.textContent = 'Failed!';
        }
        document.body.removeChild(textArea);
        setTimeout(() => { copyGameIdButton.textContent = 'Copy'; }, 2000);
    });

    startGameButton.addEventListener('click', () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            startRound();
        }
    });
    reDealButton.addEventListener('click', () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            startRound();
        }
    });

    // --- Main Game State Handler ---
    function handleGameStateUpdate(gameState) {
        const oldTheme = localGameState.currentTheme;
        const wasWaiting = localGameState.gameStatus === 'waiting';

        localGameState = gameState;
        const playerIds = gameState.playerOrder;
        const playerCount = playerIds.length;
        const isHost = gameState.players[currentPlayerId]?.isHost;

        if (gameState.gameStatus === 'waiting') {
            playerList.innerHTML = '';
            playerIds.forEach(pid => {
                const p = document.createElement('p');
                p.textContent = `${gameState.players[pid].name} ${gameState.players[pid].isHost ? '(Host)' : ''}`;
                playerList.appendChild(p);
            });
            
            const canStart = isHost && playerCount >= 2 && playerCount <= 8;
            startGameButton.disabled = !canStart;
            reDealButton.classList.add('hidden');

            if (isHost) {
                if (playerCount < 2) {
                    waitingMessage.textContent = "Need at least 2 players to start.";
                } else if (playerCount > 8) {
                    waitingMessage.textContent = "Cannot start with more than 8 players.";
                } else {
                    waitingMessage.textContent = "You're the host. Start the game when ready!";
                }
            } else {
                waitingMessage.textContent = "Waiting for the host to start the game...";
            }

            waitingRoomView.classList.remove('hidden');
            setupScreen.classList.remove('hidden');
            gameContainer.classList.add('hidden');

        } else if (gameState.gameStatus === 'in-progress' || gameState.gameStatus === 'round-over' || gameState.gameStatus === 'finished') {
            setupScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            reDealButton.classList.toggle('hidden', !isHost); // Show re-deal button for host in game

            if (oldTheme !== gameState.currentTheme) {
                applyTheme(gameState.currentTheme);
                themeSwitcher.value = gameState.currentTheme;
            }

            gameIdHeader.textContent = currentGameId;
            updateScoreboard();

            // Update current player turn display
            const currentPlayerName = gameState.players[gameState.playerOrder[gameState.currentPlayerIndex]]?.name || 'Unknown';
            currentPlayerElement.textContent = currentPlayerName;

            // Update game status message
            let statusMessage = '';
            if (gameState.gameStatus === 'in-progress') {
                if (gameState.playerOrder[gameState.currentPlayerIndex] === currentPlayerId) {
                    statusMessage = 'Your Turn!';
                    endTurnButton.classList.remove('hidden');
                    boneyardPileElement.classList.toggle('can-draw', gameState.boneyard.length > 0 && gameState.turnState === 'DRAWING');
                } else {
                    statusMessage = `Waiting for ${currentPlayerName}...`;
                    endTurnButton.classList.add('hidden');
                    boneyardPileElement.classList.remove('can-draw');
                }
                undoButton.disabled = gameState.playerOrder[gameState.currentPlayerIndex] !== currentPlayerId || gameState.moveHistory.length === 0;

            } else if (gameState.gameStatus === 'round-over') {
                statusMessage = 'Round Ended!';
                endTurnButton.classList.add('hidden');
                boneyardPileElement.classList.remove('can-draw');
                displayRoundEndScreen();
            } else if (gameState.gameStatus === 'finished') {
                statusMessage = 'Game Over!';
                endTurnButton.classList.add('hidden');
                boneyardPileElement.classList.remove('can-draw');
                displayGameOverScreen();
            }
            gameStatusElement.textContent = statusMessage;

            renderHands();
            renderBoard(gameState.boardDominos);
            boneyardCountElement.textContent = gameState.boneyard.length;
            updateMinimap();
        }
    }

    // --- Game Logic Functions ---

    // Generates a standard double-9 domino set
    function generateDominos() {
        const dominos = [];
        let idCounter = 0;
        for (let i = 0; i <= 9; i++) {
            for (let j = i; j <= 9; j++) {
                dominos.push({ id: `d${idCounter++}`, v1: i, v2: j, isDouble: i === j });
            }
        }
        return dominos;
    }

    // Shuffles an array (Fisher-Yates algorithm)
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // Deals dominoes to players based on player count
    async function dealDominos(playerOrder, currentStartingDouble) {
        const allDominos = shuffleArray(generateDominos());
        const numPlayers = playerOrder.length;
        let dominosPerPlayer;

        if (numPlayers <= 2) {
            dominosPerPlayer = 14;
        } else if (numPlayers >=3 && numPlayers <= 7) {
            dominosPerPlayer = 7;
        } else { // 8 players
            dominosPerPlayer = 6; // Adjust for 8 players to fit double-9 set (55 dominoes total)
        }

        const newPlayersState = {};
        let boneyard = [...allDominos];
        let startingDomino = null;
        let startingPlayerId = null;

        // Deal hands and find starting double
        for (const playerId of playerOrder) {
            const hand = [];
            for (let i = 0; i < dominosPerPlayer; i++) {
                if (boneyard.length > 0) {
                    hand.push(boneyard.shift());
                }
            }
            newPlayersState[playerId] = { ...localGameState.players[playerId], hand: hand };

            // Find the highest double in hands, starting from currentStartingDouble down
            // If no double found, the player with the highest sum starts
            const playerHighestDouble = hand.find(d => d.isDouble && d.v1 === currentStartingDouble);
            if (playerHighestDouble && (!startingDomino || playerHighestDouble.v1 > startingDomino.v1)) {
                startingDomino = playerHighestDouble;
                startingPlayerId = playerId;
            }
        }

        // If no player has the current starting double, find the highest double overall
        if (!startingDomino) {
            let highestDouble = -1;
            for (const playerId of playerOrder) {
                const playerHand = newPlayersState[playerId].hand;
                for (const domino of playerHand) {
                    if (domino.isDouble && domino.v1 > highestDouble) {
                        highestDouble = domino.v1;
                        startingDomino = domino;
                        startingPlayerId = playerId;
                    }
                }
            }
        }

        // If still no double found (very rare), find the domino with the highest sum
        if (!startingDomino) {
            let highestSum = -1;
            for (const playerId of playerOrder) {
                const playerHand = newPlayersState[playerId].hand;
                for (const domino of playerHand) {
                    const sum = domino.v1 + domino.v2;
                    if (sum > highestSum) {
                        highestSum = sum;
                        startingDomino = domino;
                        startingPlayerId = playerId;
                    }
                }
            }
        }

        // Remove starting domino from player's hand and place it on board
        if (startingDomino && startingPlayerId) {
            const playerHand = newPlayersState[startingPlayerId].hand;
            newPlayersState[startingPlayerId].hand = playerHand.filter(d => d.id !== startingDomino.id);

            const boardDominos = [{
                id: startingDomino.id,
                v1: startingDomino.v1,
                v2: startingDomino.v2,
                x: BOARD_SIZE / 2 - DOMINO_WIDTH / 2,
                y: BOARD_SIZE / 2 - DOMINO_HEIGHT / 2,
                rotation: 0,
                isSpinner: startingDomino.isDouble,
                side: 'center' // Indicates it's the first domino
            }];

            // Determine starting player index
            const startingPlayerIndex = playerOrder.indexOf(startingPlayerId);

            await updateDoc(doc(db, "games", currentGameId), {
                players: newPlayersState,
                boneyard: boneyard,
                boardDominos: boardDominos,
                currentPlayerIndex: startingPlayerIndex,
                gameStatus: 'in-progress',
                roundNumber: localGameState.roundNumber + 1,
                currentStartingDouble: startingDomino.isDouble ? startingDomino.v1 - 1 : currentStartingDouble, // Next round starts with lower double
                turnState: 'PLAYING',
                mustDrawToStart: false,
                lastDrawnDominoId: null,
                moveHistory: [{ type: 'initial_placement', domino: startingDomino, playerId: startingPlayerId }],
                actionStatus: `${newPlayersState[startingPlayerId].name} started the round with ${startingDomino.v1}-${startingDomino.v2}.`
            });
        } else {
            // This case should ideally not happen if domino set is complete
            showMessage("Could not find a starting domino. Re-dealing.");
            await startRound(); // Try again
        }
    }

    async function startRound() {
        if (!localGameState.players[currentPlayerId]?.isHost) {
            showMessage("Only the host can start a new round.");
            return;
        }

        // Reset player hands and scores for the new round
        const players = { ...localGameState.players };
        for (const playerId in players) {
            players[playerId].hand = [];
        }

        await updateDoc(doc(db, "games", currentGameId), {
            players: players,
            gameStatus: 'dealing', // Temporary status to prevent concurrent deals
            boardDominos: [],
            boneyard: [],
            currentPlayerIndex: 0,
            turnState: 'WAITING',
            mustDrawToStart: false,
            lastDrawnDominoId: null,
            moveHistory: [],
            actionStatus: 'Dealing dominoes...'
        });

        // Now deal the dominoes
        await dealDominos(localGameState.playerOrder, localGameState.currentStartingDouble);
    }

    // Renders the dominoes in a player's hand
    function renderHand(hand, container, isMyHand = false) {
        container.innerHTML = '';
        hand.forEach(domino => {
            const dominoEl = createDominoElement(domino, !isMyHand);
            dominoEl.dataset.dominoId = domino.id; // Store ID for interaction
            if (isMyHand) {
                dominoEl.addEventListener('mousedown', (e) => dominoMouseDown(e, domino, dominoEl));
                dominoEl.addEventListener('touchstart', (e) => dominoTouchStart(e, domino, dominoEl));
            }
            container.appendChild(dominoEl);
        });
    }

    // Renders all player hands (my hand and opponents)
    function renderHands() {
        const playerOrder = localGameState.playerOrder;
        const players = localGameState.players;

        myHandContainer.innerHTML = '';
        topHandArea.innerHTML = '';
        leftHandArea.innerHTML = '';
        rightHandArea.innerHTML = '';

        const myPlayerIndex = playerOrder.indexOf(currentPlayerId);

        playerOrder.forEach((pid, index) => {
            const player = players[pid];
            if (pid === currentPlayerId) {
                renderHand(player.hand, myHandContainer, true);
            } else {
                const handSize = player.hand.length;
                let opponentHandContainer;
                let handClass = 'flex gap-2 p-2 rounded-lg';
                let nameClass = 'text-sm font-bold text-white mb-1';
                let countClass = 'text-xs text-gray-300';

                // Determine position for opponent hands relative to current player
                const relativeIndex = (index - myPlayerIndex + playerOrder.length) % playerOrder.length;

                if (playerOrder.length === 2) { // 1 opponent
                    opponentHandContainer = topHandArea;
                    handClass += ' top-hand';
                } else if (playerOrder.length === 3) { // 2 opponents
                    if (relativeIndex === 1) { // Left
                        opponentHandContainer = leftHandArea;
                        handClass += ' side-hand-grid flex-col';
                    } else { // Right
                        opponentHandContainer = rightHandArea;
                        handClass += ' side-hand-grid flex-col';
                    }
                } else { // 4-8 opponents (top, left, right)
                    if (relativeIndex === 1) { // Top-Left
                        opponentHandContainer = topHandArea; // Or a dedicated top-left area
                        handClass += ' top-hand';
                    } else if (relativeIndex === playerOrder.length - 1) { // Top-Right
                        opponentHandContainer = topHandArea; // Or a dedicated top-right area
                        handClass += ' top-hand';
                    } else if (relativeIndex < playerOrder.length / 2) { // Left side
                        opponentHandContainer = leftHandArea;
                        handClass += ' side-hand-grid flex-col';
                    } else { // Right side
                        opponentHandContainer = rightHandArea;
                        handClass += ' side-hand-grid flex-col';
                    }
                }

                if (opponentHandContainer) {
                    const opponentSection = document.createElement('div');
                    opponentSection.className = `opponent-hand-section flex flex-col items-center ${handClass} ${localGameState.playerOrder[localGameState.currentPlayerIndex] === pid ? 'current-player' : ''}`;
                    opponentSection.innerHTML = `
                        <p class="${nameClass}">${player.name}</p>
                        <p class="${countClass}">${handSize} dominoes</p>
                        <div class="flex flex-wrap justify-center gap-1 mt-2"></div>
                    `;
                    const dominoesContainer = opponentSection.querySelector('div.flex-wrap');
                    for (let i = 0; i < handSize; i++) {
                        dominoesContainer.appendChild(createDominoElement({ v1: 0, v2: 0 }, true)); // Render back of domino
                    }
                    opponentHandContainer.appendChild(opponentSection);
                }
            }
        });
    }


    // Renders dominoes on the game board
    function renderBoard(boardDominos) {
        gameBoardElement.innerHTML = '';
        const startingArea = document.createElement('div');
        startingArea.id = 'starting-area';
        gameBoardElement.appendChild(startingArea); // Always show starting area

        boardDominos.forEach(domino => {
            const dominoEl = createDominoElement(domino);
            dominoEl.style.left = `${domino.x}px`;
            dominoEl.style.top = `${domino.y}px`;
            dominoEl.style.transform = `rotate(${domino.rotation}deg)`;
            gameBoardElement.appendChild(dominoEl);
        });
    }

    // Helper to create a domino HTML element
    function createDominoElement(dominoData, isBack = false) {
        const dominoEl = document.createElement('div');
        dominoEl.className = 'domino';
        dominoEl.dataset.v1 = dominoData.v1;
        dominoEl.dataset.v2 = dominoData.v2;
        dominoEl.dataset.id = dominoData.id;

        if (isBack) {
            dominoEl.classList.add('domino-back');
            return dominoEl;
        }

        const createPips = (value, side) => {
            const pipContainer = document.createElement('div');
            pipContainer.className = 'pip-container';
            if (dominoData.isSpinner && side === 'center') {
                pipContainer.innerHTML = `<svg class="spinner-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2zm0 4h2v-2h-2v2zm0 4h2v-2h-2v2z"/></svg>`;
            } else {
                const pipLayouts = {
                    0: [],
                    1: [[1, 1]],
                    2: [[0, 2], [2, 0]],
                    3: [[0, 2], [1, 1], [2, 0]],
                    4: [[0, 0], [0, 2], [2, 0], [2, 2]],
                    5: [[0, 0], [0, 2], [1, 1], [2, 0], [2, 2]],
                    6: [[0, 0], [0, 1], [0, 2], [2, 0], [2, 1], [2, 2]],
                    7: [[0, 0], [0, 1], [0, 2], [1, 1], [2, 0], [2, 1], [2, 2]],
                    8: [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]],
                    9: [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]],
                };
                pipLayouts[value].forEach(pos => {
                    const pip = document.createElement('div');
                    pip.className = `pip pip-color-${value}`;
                    pip.style.gridColumn = pos[1] + 1;
                    pip.style.gridRow = pos[0] + 1;
                    pipContainer.appendChild(pip);
                });
            }
            return pipContainer;
        };

        dominoEl.appendChild(createPips(dominoData.v1, 'left'));
        dominoEl.appendChild(document.createElement('div')).className = 'divider';
        dominoEl.appendChild(createPips(dominoData.v2, 'right'));

        return dominoEl;
    }

    // Updates the scoreboard display
    function updateScoreboard() {
        scoreboard.innerHTML = '';
        const playerOrder = localGameState.playerOrder;
        const players = localGameState.players;
        playerOrder.forEach(pid => {
            const player = players[pid];
            const scoreItem = document.createElement('div');
            scoreItem.className = `text-center p-2 rounded ${pid === currentPlayerId ? 'bg-yellow-700' : 'bg-gray-700'} ${localGameState.playerOrder[localGameState.currentPlayerIndex] === pid ? 'border-2 border-yellow-300' : ''}`;
            scoreItem.innerHTML = `
                <p class="text-sm font-bold">${player.name}</p>
                <p class="text-lg">${player.score}</p>
            `;
            scoreboard.appendChild(scoreItem);
        });
    }

    // Calculates scores at the end of a round
    function calculateRoundScores() {
        const players = localGameState.players;
        const roundResults = [];
        let winnerId = null;
        let minHandValue = Infinity;

        // Calculate hand values
        for (const playerId in players) {
            const handValue = players[playerId].hand.reduce((sum, domino) => sum + domino.v1 + domino.v2, 0);
            roundResults.push({ playerId, name: players[playerId].name, handValue });
            if (handValue < minHandValue) {
                minHandValue = handValue;
                winnerId = playerId;
            } else if (handValue === minHandValue) {
                // Tie for lowest hand, no winner for this round, or split points
                winnerId = null; // Indicate a tie
            }
        }

        // Handle win/tie for round
        if (winnerId) {
            const winnerName = players[winnerId].name;
            const pointsToAward = roundResults
                .filter(r => r.playerId !== winnerId)
                .reduce((sum, r) => sum + r.handValue, 0);
            
            // Update winner's score in localGameState
            players[winnerId].score += pointsToAward;
            
            roundEndTitle.textContent = 'Round Over!';
            roundWinnerMessage.textContent = `${winnerName} won the round and scored ${pointsToAward} points!`;
        } else {
            roundEndTitle.textContent = 'Round Over - Tie!';
            roundWinnerMessage.textContent = 'No clear winner this round, points are split or no points awarded.';
        }

        // Display round results
        roundResultsList.innerHTML = '';
        roundResults.sort((a, b) => a.handValue - b.handValue).forEach(r => {
            const p = document.createElement('p');
            p.className = `text-md ${r.playerId === winnerId ? 'winner' : ''}`;
            p.textContent = `${r.name}: ${r.handValue} pips left`;
            roundResultsList.appendChild(p);
        });

        // Update Firestore with new scores and game status
        const updatedPlayers = {};
        for (const playerId in players) {
            updatedPlayers[playerId] = { ...players[playerId], hand: [] }; // Clear hands for next round
        }
        
        updateDoc(doc(db, "games", currentGameId), {
            players: updatedPlayers,
            gameStatus: 'round-over',
            actionStatus: winnerId ? `${players[winnerId].name} won the round.` : 'Round ended in a tie.',
            // The actual score update is done in the winnerId block
        });

        roundEndScreen.classList.remove('hidden');
    }

    // Ends the current game
    function endGame() {
        const players = localGameState.players;
        let finalWinner = null;
        let maxScore = -1;

        finalScoreList.innerHTML = '';
        const sortedPlayers = Object.values(players).sort((a, b) => b.score - a.score);

        sortedPlayers.forEach(player => {
            const p = document.createElement('p');
            p.textContent = `${player.name}: ${player.score} points`;
            finalScoreList.appendChild(p);

            if (player.score > maxScore) {
                maxScore = player.score;
                finalWinner = player;
            } else if (player.score === maxScore && finalWinner) {
                // If there's a tie for the highest score
                finalWinner = null; // Indicate a tie
            }
        });

        if (finalWinner) {
            finalWinnerMessage.textContent = `${finalWinner.name} is the overall winner!`;
        } else {
            finalWinnerMessage.textContent = 'The game ended in a tie!';
        }

        gameOverScreen.classList.remove('hidden');
    }

    // Checks if a move is valid
    function isValidMove(domino, targetSide, boardDominos) {
        if (boardDominos.length === 0) {
            // First move, any domino is valid if targetSide is 'center'
            return true;
        }

        const boardEnds = getBoardEnds(boardDominos);
        let valid = false;

        // Check if connecting to an existing end
        for (const end of boardEnds) {
            if (end.value === domino.v1 && targetSide === end.side) {
                valid = true;
                break;
            }
            if (end.value === domino.v2 && targetSide === end.side) {
                valid = true;
                break;
            }
        }
        return valid;
    }

    // Gets the open ends of the domino chain on the board
    function getBoardEnds(boardDominos) {
        if (boardDominos.length === 0) return [];
        if (boardDominos.length === 1) {
            const firstDomino = boardDominos[0];
            return [
                { dominoId: firstDomino.id, value: firstDomino.v1, side: 'left' },
                { dominoId: firstDomino.id, value: firstDomino.v2, side: 'right' }
            ];
        }

        // This is a simplified approach. A real game would need a graph-like structure
        // to track connections properly, especially with spinners.
        // For now, we'll assume a linear chain for simplicity, and the spinner will open new branches.

        const ends = [];
        const connections = {}; // Map of domino ID to connected domino IDs

        boardDominos.forEach(d => {
            connections[d.id] = new Set();
        });

        // Build connections (simplified for linear chain)
        for (let i = 0; i < boardDominos.length; i++) {
            for (let j = i + 1; j < boardDominos.length; j++) {
                const d1 = boardDominos[i];
                const d2 = boardDominos[j];

                // Check for value matches (simplified, doesn't account for specific ends)
                if (d1.v1 === d2.v1 || d1.v1 === d2.v2 || d1.v2 === d2.v1 || d1.v2 === d2.v2) {
                    // This is a very basic connection check.
                    // A proper implementation would need to consider positions and rotations.
                    // For now, we'll just assume the first and last dominoes by array order are the ends.
                }
            }
        }

        // Find the "true" ends of the chain. This is complex for a branching board.
        // For a basic linear game, it's the first and last dominoes added.
        // For a spinner game, it's all "open" ends.
        // Given the current structure, we'll assume the first domino is the spinner and it opens 4 directions.
        // And subsequent dominoes extend from these branches.
        // This requires a more robust board state representation.

        // For now, let's just return all values on the "edges" of the board.
        // This is a placeholder and needs real game logic.
        // A better approach would be to store 'connection points' on the board.

        // If it's the very first domino (the spinner)
        if (boardDominos.length === 1) {
            const spinner = boardDominos[0];
            if (spinner.isSpinner) {
                // Spinner opens 4 sides
                return [
                    { dominoId: spinner.id, value: spinner.v1, side: 'top' },
                    { dominoId: spinner.id, value: spinner.v1, side: 'bottom' },
                    { dominoId: spinner.id, value: spinner.v1, side: 'left' },
                    { dominoId: spinner.id, value: spinner.v1, side: 'right' }
                ];
            } else {
                return [
                    { dominoId: spinner.id, value: spinner.v1, side: 'left' },
                    { dominoId: spinner.id, value: spinner.v2, side: 'right' }
                ];
            }
        }

        // For subsequent moves, we need to find the actual open ends.
        // This is highly dependent on how `placeDomino` defines `side` and `isSpinner`.
        // A common way is to maintain a list of active "endpoints" on the board.
        const currentEnds = [];
        boardDominos.forEach(d => {
            // This is a simplified representation. In a real game, each domino would have
            // its connected sides tracked.
            if (d.isSpinner) {
                // A spinner has 4 open ends initially, and then branches extend.
                // This requires a more sophisticated data structure than a flat array.
                // For simplicity, let's assume a spinner always opens up all its values
                // as potential connection points.
                currentEnds.push({ dominoId: d.id, value: d.v1, side: 'any' });
                currentEnds.push({ dominoId: d.id, value: d.v2, side: 'any' });
            } else {
                // For regular dominoes, we need to know which side is connected and which is open.
                // This 'side' property on the domino object itself is crucial.
                // Example: if a domino is placed connecting its v1 to another domino, then its v2 is open.
                // The `side` property in `boardDominos` should reflect its open end.
                // e.g., { ..., openEndValue: 5, openEndSide: 'right' }
                // Since the provided `placeDomino` doesn't explicitly track this,
                // this `getBoardEnds` function is currently a placeholder.
                // We'd need to infer or explicitly store the open ends.
                currentEnds.push({ dominoId: d.id, value: d.v1, side: 'left' }); // Placeholder
                currentEnds.push({ dominoId: d.id, value: d.v2, side: 'right' }); // Placeholder
            }
        });

        // Filter out connected ends. This is the hard part without a proper graph.
        // For demonstration, let's just return all values present on the board.
        // This will allow any matching domino to be placed anywhere, which is not correct.
        // A proper solution requires knowing which dominoes are at the *actual* ends of the chain(s).
        return currentEnds;
    }


    // Logic to place a domino on the board
    async function placeDomino(dominoId, value1, value2, x, y, rotation, targetSide, isSpinner = false) {
        const gameRef = doc(db, "games", currentGameId);
        const currentPlayer = localGameState.players[currentPlayerId];

        try {
            await runTransaction(db, async (transaction) => {
                const gameDoc = await transaction.get(gameRef);
                if (!gameDoc.exists()) {
                    throw "Game does not exist!";
                }
                const currentData = gameDoc.data();
                const currentPlayers = { ...currentData.players };
                const currentBoardDominos = [...currentData.boardDominos];
                const currentMoveHistory = [...currentData.moveHistory];
                const currentBoneyard = [...currentData.boneyard];

                // Find the domino in the current player's hand
                const dominoIndexInHand = currentPlayers[currentPlayerId].hand.findIndex(d => d.id === dominoId);
                if (dominoIndexInHand === -1) {
                    throw "Domino not found in your hand.";
                }
                const dominoToPlace = currentPlayers[currentPlayerId].hand[dominoIndexInHand];

                // Validate move (simplified for now, needs proper game logic)
                const boardEnds = getBoardEnds(currentBoardDominos);
                let validPlacement = false;
                let actualRotation = rotation;
                let actualV1 = value1;
                let actualV2 = value2;

                if (currentBoardDominos.length === 0) {
                    // First domino played, it's always valid
                    validPlacement = true;
                    // The first domino is always the spinner for the round
                    isSpinner = true;
                } else {
                    // Check if the domino can connect to any open end on the board
                    for (const end of boardEnds) {
                        if (end.value === dominoToPlace.v1) {
                            validPlacement = true;
                            // If v1 matches, v2 is the new open end
                            actualV1 = dominoToPlace.v1;
                            actualV2 = dominoToPlace.v2;
                            break;
                        } else if (end.value === dominoToPlace.v2) {
                            validPlacement = true;
                            // If v2 matches, v1 is the new open end, so flip the domino visually
                            actualV1 = dominoToPlace.v2; // Display v2 first
                            actualV2 = dominoToPlace.v1; // Display v1 second
                            // Adjust rotation if it's a horizontal domino being flipped vertically
                            if (rotation === 0 || rotation === 180) { // Horizontal
                                actualRotation = rotation; // No change in visual orientation
                            } else { // Vertical
                                actualRotation = rotation; // No change in visual orientation
                            }
                            break;
                        }
                    }
                }

                if (!validPlacement) {
                    throw "Invalid move. Domino does not connect to any open end on the board.";
                }

                // Remove domino from hand
                currentPlayers[currentPlayerId].hand.splice(dominoIndexInHand, 1);

                // Add domino to boardDominos
                const newBoardDomino = {
                    id: dominoId,
                    v1: actualV1,
                    v2: actualV2,
                    x: x,
                    y: y,
                    rotation: actualRotation,
                    isSpinner: isSpinner,
                    side: targetSide // Store the side it was placed on, if applicable
                };
                currentBoardDominos.push(newBoardDomino);

                // Record the move
                currentMoveHistory.push({
                    type: 'placement',
                    domino: dominoToPlace,
                    playerId: currentPlayerId,
                    boardPosition: { x, y, rotation, targetSide, isSpinner }
                });

                // Update turn state
                let nextTurnState = 'WAITING';
                let nextPlayerIndex = currentData.currentPlayerIndex;
                let actionStatus = `${currentPlayer.name} played ${dominoToPlace.v1}-${dominoToPlace.v2}.`;

                // If player's hand is empty, round ends
                if (currentPlayers[currentPlayerId].hand.length === 0) {
                    transaction.update(gameRef, {
                        players: currentPlayers,
                        boardDominos: currentBoardDominos,
                        moveHistory: currentMoveHistory,
                        gameStatus: 'round-over',
                        actionStatus: `${currentPlayer.name} ran out of dominoes!`,
                    });
                    return; // Exit transaction early, round end will be handled by listener
                }

                // If a domino was played, the player can end their turn
                nextTurnState = 'PLAYING'; // Player has played, can now end turn

                transaction.update(gameRef, {
                    players: currentPlayers,
                    boardDominos: currentBoardDominos,
                    moveHistory: currentMoveHistory,
                    turnState: nextTurnState,
                    actionStatus: actionStatus,
                    mustDrawToStart: false, // Reset drawing status
                    lastDrawnDominoId: null, // Reset last drawn domino
                });
            });
        } catch (e) {
            console.error("Error placing domino: ", e);
            showMessage(`Error placing domino: ${e}`);
        }
    }

    // Allows a player to draw a domino from the boneyard
    async function drawFromBoneyard() {
        if (localGameState.playerOrder[localGameState.currentPlayerIndex] !== currentPlayerId) {
            showMessage("It's not your turn to draw.");
            return;
        }
        if (localGameState.boneyard.length === 0) {
            showMessage("Boneyard is empty!");
            return;
        }

        const gameRef = doc(db, "games", currentGameId);

        try {
            await runTransaction(db, async (transaction) => {
                const gameDoc = await transaction.get(gameRef);
                if (!gameDoc.exists()) {
                    throw "Game does not exist!";
                }
                const currentData = gameDoc.data();
                const currentPlayers = { ...currentData.players };
                const currentBoneyard = [...currentData.boneyard];
                const currentMoveHistory = [...currentData.moveHistory];

                if (currentBoneyard.length === 0) {
                    throw "Boneyard is empty!";
                }

                const drawnDomino = currentBoneyard.shift(); // Take one from the boneyard
                currentPlayers[currentPlayerId].hand.push(drawnDomino); // Add to player's hand

                // Record the draw move
                currentMoveHistory.push({
                    type: 'draw',
                    domino: drawnDomino,
                    playerId: currentPlayerId
                });

                // If the player drew because they couldn't play, their turn might end if they still can't play
                // For now, assume drawing allows them to try to play again.
                // If they draw all dominoes and still can't play, they must pass.
                let nextTurnState = 'PLAYING'; // After drawing, player must try to play
                let actionStatus = `${currentPlayers[currentPlayerId].name} drew a domino.`;

                transaction.update(gameRef, {
                    players: currentPlayers,
                    boneyard: currentBoneyard,
                    moveHistory: currentMoveHistory,
                    turnState: nextTurnState,
                    lastDrawnDominoId: drawnDomino.id,
                    actionStatus: actionStatus
                });
            });
        } catch (e) {
            console.error("Error drawing from boneyard: ", e);
            showMessage(`Error drawing from boneyard: ${e}`);
        }
    }

    // Ends the current player's turn
    async function endTurn() {
        if (localGameState.playerOrder[localGameState.currentPlayerIndex] !== currentPlayerId) {
            showMessage("It's not your turn to end.");
            return;
        }

        const gameRef = doc(db, "games", currentGameId);
        const currentPlayer = localGameState.players[currentPlayerId];

        try {
            await runTransaction(db, async (transaction) => {
                const gameDoc = await transaction.get(gameRef);
                if (!gameDoc.exists()) {
                    throw "Game does not exist!";
                }
                const currentData = gameDoc.data();
                let nextPlayerIndex = (currentData.currentPlayerIndex + 1) % currentData.playerOrder.length;
                let actionStatus = `${currentPlayer.name} ended their turn.`;

                // Check if the player has made a valid move or drawn.
                // If they haven't played and haven't drawn, they must draw or pass.
                // This logic needs to be more robust based on actual game rules.
                // For now, if they click "End Turn", it just goes to the next player.

                transaction.update(gameRef, {
                    currentPlayerIndex: nextPlayerIndex,
                    turnState: 'PLAYING', // Next player's turn starts as PLAYING
                    mustDrawToStart: false,
                    lastDrawnDominoId: null,
                    actionStatus: actionStatus
                });
            });
        } catch (e) {
            console.error("Error ending turn: ", e);
            showMessage(`Error ending turn: ${e}`);
        }
    }

    // Undoes the last move made by the current player
    async function undoMove() {
        if (localGameState.playerOrder[localGameState.currentPlayerIndex] !== currentPlayerId) {
            showMessage("You can only undo your own moves on your turn.");
            return;
        }

        const gameRef = doc(db, "games", currentGameId);

        try {
            await runTransaction(db, async (transaction) => {
                const gameDoc = await transaction.get(gameRef);
                if (!gameDoc.exists()) {
                    throw "Game does not exist!";
                }
                const currentData = gameDoc.data();
                const currentPlayers = { ...currentData.players };
                let currentBoardDominos = [...currentData.boardDominos];
                let currentBoneyard = [...currentData.boneyard];
                const currentMoveHistory = [...currentData.moveHistory];

                const lastMove = currentMoveHistory.pop(); // Get the last move

                if (!lastMove || lastMove.playerId !== currentPlayerId) {
                    throw "No recent move to undo or not your move.";
                }

                if (lastMove.type === 'placement') {
                    // Remove domino from board and return to hand
                    currentBoardDominos = currentBoardDominos.filter(d => d.id !== lastMove.domino.id);
                    currentPlayers[currentPlayerId].hand.push(lastMove.domino);
                    showMessage("Last domino placement undone.");
                } else if (lastMove.type === 'draw') {
                    // Remove domino from hand and return to boneyard
                    const drawnDominoIndex = currentPlayers[currentPlayerId].hand.findIndex(d => d.id === lastMove.domino.id);
                    if (drawnDominoIndex !== -1) {
                        currentPlayers[currentPlayerId].hand.splice(drawnDominoIndex, 1);
                        currentBoneyard.unshift(lastMove.domino); // Add back to top of boneyard
                        showMessage("Last draw undone.");
                    }
                } else if (lastMove.type === 'initial_placement') {
                    throw "Cannot undo the initial starting domino placement.";
                }

                transaction.update(gameRef, {
                    players: currentPlayers,
                    boardDominos: currentBoardDominos,
                    boneyard: currentBoneyard,
                    moveHistory: currentMoveHistory,
                    actionStatus: `${currentPlayers[currentPlayerId].name} undid their last move.`
                });
            });
        } catch (e) {
            console.error("Error undoing move: ", e);
            showMessage(`Error undoing move: ${e}`);
        }
    }

    // --- UI and Interaction Logic ---

    // Applies the current theme (for future theme customization)
    function applyTheme(theme) {
        // This is a placeholder for theme logic.
        // You would change CSS variables or add/remove classes here.
        console.log(`Applying theme: ${theme}`);
    }

    // Updates the transform of the game board for panning and zooming
    function updateBoardTransform() {
        gameBoardElement.style.transform = `translate(${boardPosition.x}px, ${boardPosition.y}px) scale(${zoomLevel})`;
        updateMinimap();
    }

    // Updates the minimap to show the current viewport
    function updateMinimap() {
        const boardWidth = BOARD_SIZE;
        const boardHeight = BOARD_SIZE;
        const minimapWidth = minimapContainer.offsetWidth;
        const minimapHeight = minimapContainer.offsetHeight;

        // Calculate the scale from board to minimap
        const scaleX = minimapWidth / boardWidth;
        const scaleY = minimapHeight / boardHeight;

        // Calculate viewport dimensions in minimap coordinates
        const viewportWidth = worldElement.offsetWidth / zoomLevel;
        const viewportHeight = worldElement.offsetHeight / zoomLevel;

        // Calculate viewport position in minimap coordinates
        const viewportX = -boardPosition.x / zoomLevel;
        const viewportY = -boardPosition.y / zoomLevel;

        minimapViewport.style.width = `${viewportWidth * scaleX}px`;
        minimapViewport.style.height = `${viewportHeight * scaleY}px`;
        minimapViewport.style.left = `${viewportX * scaleX}px`;
        minimapViewport.style.top = `${viewportY * scaleY}px`;

        // Update domino dots on minimap
        const existingDots = minimapContainer.querySelectorAll('.minimap-dot');
        existingDots.forEach(dot => dot.remove());

        localGameState.boardDominos.forEach(domino => {
            const dot = document.createElement('div');
            dot.className = 'minimap-dot';
            dot.style.left = `${(domino.x + DOMINO_WIDTH / 2) * scaleX - 3}px`; // -3 for half dot width/height
            dot.style.top = `${(domino.y + DOMINO_HEIGHT / 2) * scaleY - 3}px`;
            dot.title = `${domino.v1}-${domino.v2}`;
            dot.addEventListener('click', () => snapToDomino(domino.id));
            minimapContainer.appendChild(dot);
        });
    }

    // Snaps the board view to center on a specific domino
    function snapToDomino(dominoId) {
        const domino = localGameState.boardDominos.find(d => d.id === dominoId);
        if (domino) {
            const worldRect = worldElement.getBoundingClientRect();
            const targetX = -(domino.x + DOMINO_WIDTH / 2) * zoomLevel + worldRect.width / 2;
            const targetY = -(domino.y + DOMINO_HEIGHT / 2) * zoomLevel + worldRect.height / 2;

            boardPosition.x = targetX;
            boardPosition.y = targetY;
            updateBoardTransform();
        }
    }

    // Displays the round end screen
    function displayRoundEndScreen() {
        roundEndScreen.classList.remove('hidden');
        calculateRoundScores(); // This will update Firestore and then UI via listener
    }

    // Displays the game over screen
    function displayGameOverScreen() {
        gameOverScreen.classList.remove('hidden');
        endGame(); // This will calculate and display final scores
    }

    // --- Event Handlers for Board Interaction (Pan & Zoom) ---
    worldElement.addEventListener('mousedown', worldMouseDown);
    worldElement.addEventListener('mousemove', worldMouseMove);
    worldElement.addEventListener('mouseup', worldMouseUp);
    worldElement.addEventListener('mouseleave', worldMouseUp); // End pan if mouse leaves world
    worldElement.addEventListener('wheel', worldWheel, { passive: false });

    // Touch events for panning and zooming
    worldElement.addEventListener('touchstart', worldTouchStart, { passive: false });
    worldElement.addEventListener('touchmove', worldTouchMove, { passive: false });
    worldElement.addEventListener('touchend', worldTouchEnd);

    function worldMouseDown(e) {
        if (isDraggingDomino) return; // Don't pan if a domino is being dragged
        isPanning = true;
        worldElement.classList.add('panning');
        panStart = { x: e.clientX - boardPosition.x, y: e.clientY - boardPosition.y };
    }

    function worldMouseMove(e) {
        if (!isPanning) return;
        boardPosition.x = e.clientX - panStart.x;
        boardPosition.y = e.clientY - panStart.y;
        updateBoardTransform();
    }

    function worldMouseUp() {
        isPanning = false;
        worldElement.classList.remove('panning');
    }

    function worldWheel(e) {
        e.preventDefault(); // Prevent page scrolling
        const scaleFactor = 1.1;
        const oldZoom = zoomLevel;

        if (e.deltaY < 0) {
            zoomLevel *= scaleFactor; // Zoom in
        } else {
            zoomLevel /= scaleFactor; // Zoom out
        }

        zoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel));

        // Adjust board position to zoom towards the mouse cursor
        const mouseX = e.clientX - worldElement.getBoundingClientRect().left;
        const mouseY = e.clientY - worldElement.getBoundingClientRect().top;

        boardPosition.x = mouseX - (mouseX - boardPosition.x) * (zoomLevel / oldZoom);
        boardPosition.y = mouseY - (mouseY - boardPosition.y) * (zoomLevel / oldZoom);

        updateBoardTransform();
    }

    // Touch events for world panning and zooming
    function worldTouchStart(e) {
        if (e.touches.length === 1) {
            e.preventDefault(); // Prevent scrolling
            if (isDraggingDomino) return;
            isPanning = true;
            worldElement.classList.add('panning');
            panStart = { x: e.touches[0].clientX - boardPosition.x, y: e.touches[0].clientY - boardPosition.y };
            initialPinchDistance = null; // Reset pinch
        } else if (e.touches.length === 2) {
            e.preventDefault(); // Prevent scrolling
            isPanning = false; // Disable single-touch pan
            initialPinchDistance = getPinchDistance(e.touches);
        }
    }

    function worldTouchMove(e) {
        e.preventDefault(); // Prevent scrolling
        if (e.touches.length === 1 && isPanning) {
            boardPosition.x = e.touches[0].clientX - panStart.x;
            boardPosition.y = e.touches[0].clientY - panStart.y;
            updateBoardTransform();
        } else if (e.touches.length === 2 && initialPinchDistance) {
            const currentPinchDistance = getPinchDistance(e.touches);
            const scaleFactor = currentPinchDistance / initialPinchDistance;
            const oldZoom = zoomLevel;

            zoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, oldZoom * scaleFactor));

            // Adjust board position to zoom towards the center of the pinch
            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - worldElement.getBoundingClientRect().left;
            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - worldElement.getBoundingClientRect().top;

            boardPosition.x = centerX - (centerX - boardPosition.x) * (zoomLevel / oldZoom);
            boardPosition.y = centerY - (centerY - boardPosition.y) * (zoomLevel / oldZoom);

            updateBoardTransform();
            initialPinchDistance = currentPinchDistance; // Update for next move
        }
    }

    function worldTouchEnd() {
        isPanning = false;
        worldElement.classList.remove('panning');
        initialPinchDistance = null;
    }

    function getPinchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // --- Domino Drag & Drop ---
    function dominoMouseDown(e, dominoData, dominoElement) {
        e.preventDefault(); // Prevent default browser drag behavior
        if (localGameState.playerOrder[localGameState.currentPlayerIndex] !== currentPlayerId) {
            showMessage("It's not your turn!");
            return;
        }
        if (localGameState.turnState === 'DRAWING') {
            showMessage("You must draw a domino first, or end your turn if boneyard is empty.");
            return;
        }

        isDraggingDomino = true;
        wasDragged = false;
        draggedDominoData = dominoData;
        originalHandElement = dominoElement;

        // Calculate offset from mouse to domino's top-left corner
        const rect = dominoElement.getBoundingClientRect();
        dominoOffsetX = e.clientX - rect.left;
        dominoOffsetY = e.clientY - rect.top;

        startDominoDrag(e, dominoData, dominoElement);

        window.addEventListener('mousemove', dragDomino);
        window.addEventListener('mouseup', endDominoDrag);
    }

    function dominoTouchStart(e, dominoData, dominoElement) {
        e.preventDefault(); // Prevent scrolling
        if (e.touches.length !== 1) return; // Only single touch drag
        if (localGameState.playerOrder[localGameState.currentPlayerIndex] !== currentPlayerId) {
            showMessage("It's not your turn!");
            return;
        }
        if (localGameState.turnState === 'DRAWING') {
            showMessage("You must draw a domino first, or end your turn if boneyard is empty.");
            return;
        }

        isDraggingDomino = true;
        wasDragged = false;
        draggedDominoData = dominoData;
        originalHandElement = dominoElement;

        const rect = dominoElement.getBoundingClientRect();
        dominoOffsetX = e.touches[0].clientX - rect.left;
        dominoOffsetY = e.touches[0].clientY - rect.top;

        startDominoDrag(e, dominoData, dominoElement);

        window.addEventListener('touchmove', dragDomino, { passive: false });
        window.addEventListener('touchend', endDominoDrag);
    }

    function startDominoDrag(e, dominoData, dominoElement) {
        // Create a clone for dragging
        activeDominoElement = createDominoElement(dominoData);
        activeDominoElement.classList.add('dragging');
        activeDominoElement.style.position = 'fixed'; // Position relative to viewport
        activeDominoElement.style.zIndex = '3000'; // High z-index
        activeDominoElement.style.pointerEvents = 'none'; // Allow events to pass through to elements below
        activeDominoElement.style.boxShadow = '0 10px 20px rgba(0,0,0,0.4), inset 0 0 5px rgba(0,0,0,0.3)'; // Add shadow

        document.body.appendChild(activeDominoElement);

        // Hide original domino in hand
        originalHandElement.style.opacity = '0';
        originalHandElement.style.pointerEvents = 'none';

        dragLabel.textContent = `${dominoData.v1}-${dominoData.v2}`;
        dragLabel.classList.remove('hidden');

        // Initial position
        const clientX = e.clientX || e.touches[0].clientX;
        const clientY = e.clientY || e.touches[0].clientY;
        activeDominoElement.style.left = `${clientX - dominoOffsetX}px`;
        activeDominoElement.style.top = `${clientY - dominoOffsetY}px`;
        dragLabel.style.left = `${clientX}px`;
        dragLabel.style.top = `${clientY}px`;
    }

    function dragDomino(e) {
        if (!isDraggingDomino || !activeDominoElement) return;
        wasDragged = true; // Mark as dragged

        const clientX = e.clientX || e.touches[0].clientX;
        const clientY = e.clientY || e.touches[0].clientY;

        activeDominoElement.style.left = `${clientX - dominoOffsetX}px`;
        activeDominoElement.style.top = `${clientY - dominoOffsetY}px`;
        dragLabel.style.left = `${clientX}px`;
        dragLabel.style.top = `${clientY}px`;
    }

    async function endDominoDrag(e) {
        if (!isDraggingDomino) return;

        window.removeEventListener('mousemove', dragDomino);
        window.removeEventListener('mouseup', endDominoDrag);
        window.removeEventListener('touchmove', dragDomino);
        window.removeEventListener('touchend', endDominoDrag);

        isDraggingDomino = false;
        dragLabel.classList.add('hidden');

        if (activeDominoElement) {
            activeDominoElement.remove();
            activeDominoElement = null;
        }

        if (originalHandElement) {
            originalHandElement.style.opacity = '1';
            originalHandElement.style.pointerEvents = 'auto';
            originalHandElement = null;
        }

        if (!wasDragged) {
            // If it was just a click, not a drag, maybe select/deselect the domino
            // For now, we only care about actual drags to the board
            return;
        }

        // Determine drop target (game board)
        const worldRect = worldElement.getBoundingClientRect();
        const dropX = e.clientX || e.changedTouches[0].clientX;
        const dropY = e.clientY || e.changedTouches[0].clientY;

        // Convert drop coordinates to game board coordinates
        const boardX = (dropX - worldRect.left - boardPosition.x) / zoomLevel;
        const boardY = (dropY - worldRect.top - boardPosition.y) / zoomLevel;

        // Check if dropped on the game board area
        if (boardX >= 0 && boardX <= BOARD_SIZE && boardY >= 0 && boardY <= BOARD_SIZE) {
            // For simplicity, let's just place it at the dropped location for now
            // In a real game, you'd snap to valid connection points
            const snappedX = boardX - DOMINO_WIDTH / 2; // Center domino on drop point
            const snappedY = boardY - DOMINO_HEIGHT / 2;

            // Placeholder for rotation and side. You'd determine this based on drop zone.
            const rotation = 0; // Assume 0 rotation for now
            const targetSide = 'any'; // Placeholder

            await placeDomino(draggedDominoData.id, draggedDominoData.v1, draggedDominoData.v2, snappedX, snappedY, rotation, targetSide, draggedDominoData.isDouble);
        } else {
            showMessage("Domino dropped outside the game board.");
        }
        draggedDominoData = null;
        wasDragged = false;
    }

    // --- Boneyard Interaction ---
    boneyardPileElement.addEventListener('click', async () => {
        if (localGameState.playerOrder[localGameState.currentPlayerIndex] !== currentPlayerId) {
            showMessage("It's not your turn to draw.");
            return;
        }
        if (localGameState.turnState !== 'DRAWING') {
            showMessage("You can only draw if you can't make a move.");
            return;
        }
        await drawFromBoneyard();
    });

    // --- Button Event Listeners ---
    endTurnButton.addEventListener('click', endTurn);
    undoButton.addEventListener('click', undoMove);
    continueRoundButton.addEventListener('click', async () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            roundEndScreen.classList.add('hidden');
            await startRound();
        } else {
            showMessage("Only the host can start the next round.");
        }
    });

    // --- Theme Switcher ---
    themeSwitcher.addEventListener('change', async (e) => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            await updateDoc(doc(db, "games", currentGameId), {
                currentTheme: e.target.value
            });
        } else {
            showMessage("Only the host can change the theme.");
            themeSwitcher.value = localGameState.currentTheme; // Revert to current theme
        }
    });

    // Initial Firebase setup
    initializeFirebase();
</script>
</body>
</html>
