<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
    <title>Spinner after Dinner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet"/>
    <style>
        /* General Body and Layout Styles */
        html, body {
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
        }
        body {
            font-family: 'Inter', sans-serif;
            user-select: none;
            -webkit-user-select: none; /* Safari */
            background-color: #3a2a21; /* Wood color */
            background-image: linear-gradient(rgba(0,0,0,0.2) 0 0.1em, transparent 0.1em 100%),
                              linear-gradient(90deg, rgba(0,0,0,0.2) 0 0.1em, transparent 0.1em 100%);
            background-size: 3em 3em;
        }
        
        /* Accessibility class */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Game World and Board Styles */
        #world {
            position: relative;
            overflow: hidden;
            cursor: grab;
            width: 100%;
            height: 100%;
            background-color: #004d25;
            background-image: radial-gradient(rgba(255, 255, 255, 0.03) 15%, transparent 0);
            background-size: 5px 5px;
            border-radius: 9999px; /* Make it a circle/oval */
            box-shadow: 0 0 0 15px #6b4f4f, 0 0 0 20px #4a3c31, inset 0 0 25px rgba(0,0,0,0.6);
            transition: background 0.5s ease;
        }
        #world::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border-radius: 9999px;
            background: radial-gradient(circle at center, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0) 60%);
            pointer-events: none;
        }
        #world.panning {
            cursor: grabbing;
        }
        #game-board {
            position: absolute;
            width: 4000px;
            height: 4000px;
            transform-origin: top left;
            will-change: transform; /* Performance hint for the browser */
        }
        #starting-area {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 44px;
            height: 84px;
            border: 2px dashed rgba(255, 255, 255, 0.4);
            border-radius: 8px;
        }

        /* Domino Styles */
        .domino {
            width: 80px;
            height: 40px;
            border: 1px solid #1a1a1a;
            background-color: #f5f5dc; /* Ivory */
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-radius: 6px;
            cursor: grab;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.3);
            transform-origin: center center;
            color: #1a1a1a;
            transition: box-shadow 0.25s ease, border 0.25s ease; /* Modified for selection glow */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on iOS */
        }
        .domino-on-board {
            position: absolute;
            transform-origin: center;
            /* SMOOTH SNAP: Added transition for smooth rotation snapping */
            transition: transform 0.2s cubic-bezier(.25,.8,.25,1);
        }
        .domino.domino-back {
            background-color: #f5f5dc;
            border: 1px solid #1a1a1a;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            position: relative;
        }
        .domino.domino-back::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 10%;
            height: 80%;
            width: 2px;
            background-color: rgba(0,0,0,0.1);
            transform: translateX(-50%);
        }
        .domino.dragging {
            cursor: grabbing;
            transition: none !important;
            z-index: 3000 !important;
            position: fixed !important;
            top: 0;
            left: 0;
            opacity: 0.95;
            pointer-events: none;
            transform-origin: center center;  
            will-change: transform;
            backface-visibility: hidden;
        }

        /* Style for selected dominoes for moving branch */
        .domino.selected-for-branch {
            box-shadow: 0 0 15px 5px #0ea5e9, inset 0 0 5px #0ea5e9; /* sky-500 */
            border: 2px solid #38bdf8; /* sky-400 */
        }
        .domino.anchor-domino {
             box-shadow: 0 0 15px 5px #f59e0b, inset 0 0 5px #f59e0b; /* amber-500 */
            border: 2px solid #fbbf24; /* amber-400 */
        }
        
        /* Mini Domino Styles for Opponent Hands */
        .mini-domino {
            width: 40px;
            height: 20px;
            border-radius: 3px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            cursor: default !important;
        }
        .mini-domino.domino-back::after {
            width: 1px;
        }

        /* Pip and Spinner Styles */
        .pip-container {
            flex: 1; /* Changed from width: 100% to allow proper sharing of space */
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
            pointer-events: none;
            min-width: 0; /* Allows shrinking past content size if absolutely necessary */
        }
        .divider {
            width: 2px; /* A bit thicker */
            height: 80%; /* A bit longer */
            background-color: #333; /* Darker base color */
            pointer-events: none;
            border-radius: 2px;
            /* Create a 3D groove effect with shadows */
            box-shadow: inset 0.5px 0.5px 1px rgba(0,0,0,0.7), /* Dark inner shadow for the groove */
                         0.5px 0.5px 1px rgba(255,255,255,0.4); /* Light outer highlight */
            flex-shrink: 0; /* CRITICAL FIX: Prevents the divider from being squashed to 0px */
        }
        .spinner-icon {
            width: 24px;
            height: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            line-height: 1.1;
        }
        .spinner-icon svg {
            width: 100%;
            height: 100%;
        }

        /* UI Components */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* NEW: Style for active tool button */
        .tool-button.active {
            background-color: #0ea5e9; /* sky-500 */
            box-shadow: 0 0 10px #0ea5e9;
        }

        #boneyard-pile {
            border: 2px dashed #a0aec0;
            height: 60px;
            width: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            position: relative;
            border-radius: 8px;
            background-color: rgba(0,0,0,0.2);
        }
        #boneyard-pile:hover {
            background-color: rgba(255,255,255,0.1);
        }
        #boneyard-stack {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .boneyard-domino-display {
            width: 80px;
            height: 40px;
            border: 1px solid #a0aec0;
            background-color: #f7f7f7;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #boneyard-count {
            position: absolute;
            z-index: 10;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.6);
            padding: 2px 10px;
            border-radius: 12px;
            text-shadow: 0 0 5px #000;
        }
        #boneyard-message {
            position: absolute;
            z-index: 11;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 3px #000;
            pointer-events: none;
        }
        @keyframes flash-border {
            0%, 100% { border-color: #a0aec0; box-shadow: none; }
            50% { border-color: #FFD700; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        }
        .flashing-border {
            animation: flash-border 1.5s infinite;
        }
        #boneyard-pile.can-draw {
            animation: flash-border 1.5s infinite;
        }
        #minimap-container {
            position: absolute;
            top: 25px; /* Adjusted for table border */
            right: 25px; /* Adjusted for table border */
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            z-index: 2000;
            cursor: pointer;
            pointer-events: auto !important; /* FIX: Ensure minimap is always clickable */
        }
        #minimap-viewport {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }
        .minimap-dot {
            position: absolute;
            width: 8px;
            height: 4px;
            background-color: white;
            border-radius: 1px;
            pointer-events: auto;
            cursor: pointer;
            border: 1px solid white;
            box-shadow: 0 0 3px rgba(255,255,255,0.4); /* Reduced glow */
            transform-origin: center;
        }
        .player-hand-section {
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            transition: all 0.3s ease;
            background-color: rgba(0,0,0,0.3);
        }
        .player-hand-content {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: center;
        }
        #setup-screen, #round-end-screen, #loading-screen, #game-over-screen, #message-modal, #round-start-screen, #pass-device-screen, #boneyard-picker-modal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }
        #round-end-screen, #game-over-screen, #pass-device-screen {
            z-index: 10001 !important; /* Ensure it's on top */
        }
        #setup-screen > div {
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        .hidden {
            display: none !important;
        }
        #final-score-display, #round-end-content, #message-modal-content, #round-start-content, #pass-device-content {
            background-color: rgba(31, 41, 55, 0.9);
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .winner {
            color: #FFD700;
            font-weight: bold;
        }

        /* --- Boneyard Picker Rework --- */
        #boneyard-picker-modal {
            /* ... existing styles are fine ... */
            transition: opacity 0.35s ease-in-out, transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #boneyard-picker-modal.hidden {
            transform: scale(0.5) rotate(-30deg);
            opacity: 0;
            pointer-events: none;
        }
        #boneyard-picker-wrapper {
            background-color: #5C3D2E; /* A darker wood color */
            background-image: linear-gradient(90deg, rgba(0,0,0,0.15) 50%, transparent 50%),
                              linear-gradient(rgba(0,0,0,0.15) 50%, transparent 50%);
            background-size: 50px 50px;
            border: 4px solid #4a3c31;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            /* NEW: Switched to a responsive grid layout */
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 1rem;
            padding: 1rem;
            align-content: start; /* Align items to the top */
        }

        /* REMOVED: tile-cascade-in animation is gone */

        .boneyard-picker-domino, .boneyard-picker-blank-spot {
            /* NEW: Center items within their grid cell */
            justify-self: center;
        }

        .boneyard-picker-domino {
            transition: transform 0.2s ease-out;
            transform: rotate(var(--rotation, 0deg));
        }
        .boneyard-picker-domino:hover {
            transform: rotate(var(--rotation, 0deg)) scale(1.1);
            z-index: 10;
        }
        .boneyard-picker-blank-spot {
            width: 80px;
            height: 40px;
            background-color: rgba(0,0,0,0.2);
            border: 1px dashed rgba(255,255,255,0.2);
            border-radius: 6px;
        }

        /* --- LAYOUT STYLES --- */
        #game-container {
            height: 100%;
            width: 100%;
        }
        #game-layout {
            display: grid;
            grid-template-columns: 250px 1fr;
            grid-template-rows: auto 1fr;
            height: 100%;
            width: 100%;
            padding-left: calc(1rem + env(safe-area-inset-left));
            padding-right: calc(1rem + env(safe-area-inset-right));
            padding-top: calc(1rem + env(safe-area-inset-top));
            padding-bottom: calc(1rem + env(safe-area-inset-bottom));
            gap: 1rem;
            box-sizing: border-box;
        }
        #game-info { 
            grid-column: 1 / -1;
            grid-row: 1 / 2;  
        }
        #left-panel {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-height: 0; /* Crucial for flexbox children scrolling */
        }
        /* LAYOUT FIX: Ensure player hands container can grow and scroll */
        #player-hands-container {
            flex: 1 1 auto; /* Allow growing and shrinking */
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #boneyard-container, #detailed-scoreboard-container {
            flex-shrink: 0; /* Prevent these from shrinking */
        }
        #main-game-area {
            grid-column: 2 / 3;
            grid-row: 2 / 3;
            position: relative;
            display: grid;
            place-items: center;
            min-height: 0;
        }
        #main-game-area > * {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
        }
        #world-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #boneyard-buttons {
            flex-direction: row;
            flex-wrap: wrap; /* Allow buttons to wrap */
        }
        
        #game-log {
            background-color: rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 8px;
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #d1d5db;
            min-width: 150px;
        }

        /* --- ANIMATIONS & EFFECTS --- */
        @keyframes pending-glow {
            0%, 100% { box-shadow: 0 0 10px 2px rgba(74, 222, 128, 0.7); } /* green-400 */
            50% { box-shadow: 0 0 20px 5px rgba(74, 222, 128, 1); }
        }
        .pending-validation-glow {
            animation: pending-glow 1.5s infinite;
        }
        
        /* NEW: Wiggle animation for actionable buttons */
        @keyframes wiggle {
            0%, 100% { transform: rotate(-3deg) scale(1.05); }
            50% { transform: rotate(3deg) scale(1.05); }
        }
        .action-needed {
            animation: wiggle 0.4s ease-in-out infinite;
            box-shadow: 0 0 15px 5px #f59e0b; /* amber-500 */
        }


        /* NEW: Winner Animations */
        @keyframes winner-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        @keyframes winner-shake {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-1.5deg); }
            75% { transform: rotate(1.5deg); }
        }
        @keyframes winner-flash {
            0%, 100% { text-shadow: 0 0 8px #FFD700; }
            50% { text-shadow: 0 0 20px #FFFFFF, 0 0 8px #FFD700; }
        }
        .winner-animation {
            animation: winner-pulse 1.2s ease-in-out infinite, 
                       winner-shake 0.4s ease-in-out infinite,
                       winner-flash 1.5s linear infinite;
        }

        @keyframes thud {
            from { transform: scale(1.1); }
            to { transform: scale(1); }
        }
        .thud-animation {
            animation: thud 0.2s ease-out;
        }

        /* --- DETAILED SCOREBOARD --- */
        #detailed-scoreboard-container {
            background-color: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            flex-shrink: 1;
            min-height: 100px;
            overflow-y: auto;
        }
        #detailed-scoreboard-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        #detailed-scoreboard-table th, #detailed-scoreboard-table td {
            padding: 4px 6px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        #detailed-scoreboard-table th {
            background-color: rgba(0,0,0,0.4);
            font-weight: bold;
        }
        #detailed-scoreboard-table .total-row td {
            font-weight: bold;
            background-color: rgba(31, 41, 55, 0.5); /* bg-gray-800 */
        }
        
        /* --- LOCAL PLAYER LIST --- */
        #local-player-list-item {
             display: flex;
             justify-content: space-between;
             align-items: center;
             background-color: #374151; /* bg-gray-700 */
             padding: 4px 8px;
             border-radius: 4px;
        }
        #local-player-list-item button {
             background-color: #ef4444; /* bg-red-500 */
             color: white;
             border: none;
             border-radius: 50%;
             width: 20px;
             height: 20px;
             font-weight: bold;
             line-height: 1;
             cursor: pointer;
        }

        /* --- REWORKED: ROTATION HANDLES --- */
        .rotation-handle {
            position: absolute;
            width: 40px; /* Increased from 24px for easier touch */
            height: 40px; /* Increased from 24px for easier touch */
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid white;
            border-radius: 50%;
            z-index: 3000;
            cursor: grabbing;
            transform: translate(-50%, -50%);
            backdrop-filter: blur(2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            pointer-events: all; /* Make them clickable */
        }
        .rotation-handle:hover {
            background-color: rgba(255, 255, 255, 0.5);
        }


        @media (max-width: 1024px) {
            #game-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }
            #game-info { grid-row: 1 / 2; }
            #left-panel {
                grid-column: 1 / -1;
                grid-row: 2 / 3;
                flex-direction: row;
                overflow-x: auto;
                padding-bottom: 1rem;
            }
            #player-hands-container {
                flex-direction: row;
                flex-grow: 0;
            }
            .player-hand-section {
                flex-shrink: 0;
                width: 180px;
            }
            #boneyard-container {
                flex-shrink: 0;
            }
            #main-game-area {
                grid-column: 1 / -1;
                grid-row: 3 / 4;
            }
            #detailed-scoreboard-container {
                display: none; /* Hide detailed scoreboard on small screens for now */
            }
        }
    </style>
</head>
<body class="text-white">

<div id="rotation-handles-container" class="absolute top-0 left-0 w-full h-full pointer-events-none z-40"></div>

<svg width="0" height="0" style="position:absolute;z-index:-1;">
    <defs>
        <radialGradient id="pipGradient-0" cx="50%" cy="50%" r="65%" fx="30%" fy="30%"><stop offset="0%" stop-color="#FFFFFF"/><stop offset="100%" stop-color="#E0E0E0"/></radialGradient>
        <radialGradient id="pipGradient-1" cx="50%" cy="50%" r="65%" fx="30%" fy="30%"><stop offset="0%" stop-color="#FFD700"/><stop offset="100%" stop-color="#DAA520"/></radialGradient>
        <radialGradient id="pipGradient-2" cx="50%" cy="50%" r="65%" fx="30%" fy="30%"><stop offset="0%" stop-color="#FF3B30"/><stop offset="100%" stop-color="#E12D22"/></radialGradient>
        <radialGradient id="pipGradient-3" cx="50%" cy="50%" r="65%" fx="30%" fy="30%"><stop offset="0%" stop-color="#9A2A2A"/><stop offset="100%" stop-color="#800000"/></radialGradient>
        <radialGradient id="pipGradient-4" cx="50%" cy="50%" r="65%" fx="30%" fy="30%"><stop offset="0%" stop-color="#5899E2"/><stop offset="100%" stop-color="#4169E1"/></radialGradient>
        <radialGradient id="pipGradient-5" cx="50%" cy="50%" r="65%" fx="30%" fy="30%"><stop offset="0%" stop-color="#228B22"/><stop offset="100%" stop-color="#1E7E1E"/></radialGradient>
        <radialGradient id="pipGradient-6" cx="50%" cy="50%" r="65%" fx="30%" fy="30%"><stop offset="0%" stop-color="#444444"/><stop offset="100%" stop-color="#000000"/></radialGradient>
        <radialGradient id="pipGradient-7" cx="50%" cy="50%" r="65%" fx="30%" fy="30%"><stop offset="0%" stop-color="#A0522D"/><stop offset="100%" stop-color="#8B4513"/></radialGradient>
        <radialGradient id="pipGradient-8" cx="50%" cy="50%" r="65%" fx="30%" fy="30%"><stop offset="0%" stop-color="#9B59B6"/><stop offset="100%" stop-color="#8E44AD"/></radialGradient>
        <radialGradient id="pipGradient-9" cx="50%" cy="50%" r="65%" fx="30%" fy="30%"><stop offset="0%" stop-color="#8492A6"/><stop offset="100%" stop-color="#64748B"/></radialGradient>
    </defs>
</svg>

<div id="message-modal" class="hidden">
    <div id="message-modal-content" class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm">
        <p id="message-text" class="text-lg mb-4"></p>
        <div id="message-buttons" class="flex gap-4">
            <button id="message-ok-button" class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-2 px-3 rounded transition-colors">OK</button>
            <button id="message-cancel-button" class="w-full bg-gray-600 hover:bg-gray-700 font-bold py-2 px-3 rounded transition-colors hidden">Cancel</button>
        </div>
    </div>
</div>

<div id="boneyard-picker-modal" class="hidden">
    <div class="bg-gray-800 p-6 rounded-lg shadow-xl w-[90vw] max-w-4xl max-h-[90vh] flex flex-col">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-2xl font-bold">Choose a Domino from the Boneyard</h2>
            <button id="boneyard-picker-close-button" class="text-gray-400 hover:text-white text-3xl">&times;</button>
        </div>
        <div id="boneyard-picker-wrapper" class="flex-grow overflow-auto bg-gray-900 rounded-lg p-2">
            </div>
        <p class="text-center text-gray-400 mt-2 text-sm">Click a domino to add it to your hand.</p>
    </div>
</div>

<div id="loading-screen" class="flex items-center justify-center">
    <div class="text-center">
        <h1 class="text-3xl font-bold">Connecting to Game Service...</h1>
        <p id="auth-status">Initializing...</p>
    </div>
</div>

<div id="round-start-screen" class="hidden">
    <div id="round-start-content" class="w-full max-w-md">
        <h2 class="text-3xl font-bold text-center mb-4">Starting Round <span id="round-start-number"></span></h2>
        <p class="text-xl text-center mb-6">
            <span id="round-starter-name" class="text-yellow-300 font-bold"></span> starts the round!
        </p>
        <p id="round-start-wait-message" class="text-gray-400 mb-6">Waiting for them to start the round...</p>
        <button id="confirm-round-start-button" class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors hidden">
            Start Round
        </button>
    </div>
</div>

<div id="pass-device-screen" class="hidden">
    <div id="pass-device-content" class="text-center">
        <h2 class="text-3xl font-bold mb-4">Pass the Device to...</h2>
        <p id="next-player-name-pass" class="text-5xl font-bold text-yellow-300 mb-8"></p>
        <button id="confirm-turn-button" class="w-full bg-green-600 hover:bg-green-700 font-bold py-4 px-6 rounded transition-colors text-xl">Show My Hand & Start Turn</button>
    </div>
</div>

<div class="hidden" id="setup-screen">
    <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-white w-full max-w-md">
        <h1 class="text-3xl font-bold text-center mb-6">Spinner after Dinner</h1>
        
        <div id="lobby-view">
            <div class="mb-4">
                <label for="player-name" class="block mb-2">Your Name:</label>
                <input class="w-full p-2 rounded bg-gray-700 text-white" id="player-name" placeholder="Enter your name" type="text"/>
            </div>
            
            <div id="create-game-flow">
                <label class="block mb-2">Game Mode:</label>
                <div class="flex gap-4 mb-6">
                    <button class="w-full bg-gray-600 font-bold py-3 px-4 rounded transition-colors" id="mode-online-button" disabled>Create Online Game</button>
                    <button class="w-full bg-gray-600 font-bold py-3 px-4 rounded transition-colors" id="mode-hybrid-button" disabled>Create Hybrid Game</button>
                </div>
            </div>

            <div id="join-game-flow">
                <div class="text-center my-4">OR</div>
                <div class="mb-4">
                    <label for="join-game-id" class="block mb-2">Join Existing Game:</label>
                    <input class="w-full p-2 rounded bg-gray-700 text-white" id="join-game-id" placeholder="Enter Game ID" type="text"/>
                </div>
                <button class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 px-4 rounded transition-colors" disabled id="join-game-button">Find Game</button>
            </div>

            <div id="local-player-setup-view" class="hidden">
                <p class="text-center text-gray-400 mb-4">You (the host) are Player 1. Add other local players below.</p>
                <div class="mb-4">
                    <label for="local-player-name-input" class="block mb-2">Add Local Player:</label>
                    <div class="flex gap-2">
                        <input class="w-full p-2 rounded bg-gray-700 text-white" id="local-player-name-input" placeholder="Enter local player's name" type="text"/>
                        <button class="bg-blue-600 hover:bg-blue-700 font-bold py-2 px-4 rounded transition-colors" id="add-local-player-button">Add</button>
                    </div>
                </div>
                <div id="local-player-list" class="space-y-2 mb-6"></div>
                <button class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors" disabled id="create-hybrid-game-button">Create Hybrid Game</button>
                 <div class="text-center my-4"></div>
                 <button class="w-full bg-gray-500 hover:bg-gray-600 font-bold py-3 px-4 rounded transition-colors" id="back-to-mode-selection-button">Back</button>
            </div>

            <div id="join-type-selection-view" class="hidden">
                <h2 class="text-2xl font-bold text-center mb-4">How are you joining?</h2>
                <p class="text-center text-gray-400 mb-6">Joining game: <span id="join-type-game-id-display"></span></p>
                <div class="flex flex-col gap-4">
                    <button id="join-as-single-player-button" class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 px-4 rounded transition-colors">Join as Single Player</button>
                    <button id="join-as-group-button" class="w-full bg-purple-600 hover:bg-purple-700 font-bold py-3 px-4 rounded transition-colors">Join as a Local Group</button>
                    <button id="back-to-lobby-button" class="w-full bg-gray-500 hover:bg-gray-600 font-bold py-3 px-4 rounded transition-colors mt-4">Back</button>
                </div>
            </div>

            <div id="join-group-setup-view" class="hidden">
                <h2 class="text-2xl font-bold text-center mb-4">Joining Game: <span id="joining-game-id-display"></span></h2>
                <p class="text-center text-gray-400 mb-4">You are Player 1 for your group. Add other local players from your device below.</p>
                 <div class="mb-4">
                    <label for="joiner-local-player-name-input" class="block mb-2">Add Local Player:</label>
                    <div class="flex gap-2">
                        <input class="w-full p-2 rounded bg-gray-700 text-white" id="joiner-local-player-name-input" placeholder="Enter local player's name" type="text"/>
                        <button class="bg-blue-600 hover:bg-blue-700 font-bold py-2 px-4 rounded transition-colors" id="add-joiner-local-player-button">Add</button>
                    </div>
                </div>
                <div id="joiner-local-player-list" class="space-y-2 mb-6"></div>
                <button class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors" id="confirm-join-group-button">Join Game with Group</button>
            </div>

        </div>

        <div class="hidden text-center" id="waiting-room-view">
            <h2 class="text-2xl font-bold mb-4">Waiting Room</h2>
            <p class="mb-2">Share this Game ID with others:</p>
            <div class="bg-gray-900 p-3 rounded-lg mb-4 flex items-center justify-center">
                <span class="text-2xl font-mono text-yellow-300" id="game-id-display"></span>
                <button class="ml-4 bg-gray-600 hover:bg-gray-500 text-sm py-1 px-2 rounded" id="copy-game-id">Copy</button>
            </div>
            <p class="mb-2 font-bold">Players Joined:</p>
            <div class="space-y-2 mb-6" id="player-list"></div>
            <p class="mb-4 text-gray-400" id="waiting-message">Waiting for more players...</p>
            <button class="w-full bg-green-600 hover:bg-green-700 font-bold py-3 px-4 rounded transition-colors" disabled id="start-game-button">Start Game</button>
        </div>
    </div>
</div>

<div class="hidden" id="round-end-screen">
    <div class="w-full max-w-md" id="round-end-content">
        <h2 class="text-3xl font-bold text-center mb-4" id="round-end-title">Round Over!</h2>
        <p class="text-xl text-yellow-300 mb-4" id="round-winner-message"></p>
        <div class="mb-6" id="round-results-list"></div>
        <button class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded transition-colors" id="continue-round-button">Continue</button>
    </div>
</div>

<div class="hidden" id="game-over-screen">
    <div class="w-full max-w-3xl" id="final-score-display">
        <h2 class="text-4xl font-bold text-center mb-4 text-yellow-300">Game Over!</h2>
        <p class="text-xl mb-6" id="final-winner-message"></p>
        <div class="space-y-2 text-lg mb-8" id="final-score-list"></div>
        <button class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded transition-colors" id="main-menu-button-final">Main Menu</button>
    </div>
</div>

<div class="hidden" id="game-container">
    <div id="game-layout">
        <div class="bg-gray-900 bg-opacity-70 p-2 rounded-lg shadow-lg flex justify-between items-center flex-wrap gap-4" id="game-info">
            <div class="flex items-center gap-4">
                <button class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition-colors" id="main-menu-button">New Game / Exit</button>
                <div>
                    <h2 class="font-bold text-lg">Current Turn: <span id="current-player"></span></h2>
                    <p class="text-sm text-yellow-300" id="game-status">Loading...</p>
                </div>
            </div>
            
            <div class="flex items-center gap-4 flex-grow justify-center">
                 <div id="game-log" class="flex-grow"></div>
                <div class="text-center px-4">
                    <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Your Hand Pips</h3>
                    <p id="hand-value-display" class="text-2xl font-bold text-yellow-300">0</p>
                </div>
                <div class="text-center px-4">
                    <h3 id="round-indicator-label" class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Round</h3>
                    <p id="round-indicator" class="text-2xl font-bold text-white">0</p>
                </div>
            </div>

            <div class="flex items-center gap-4">
                <button class="bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-2 px-4 rounded transition-colors" id="re-deal-button">Next Round</button>
                <label for="theme-switcher" class="sr-only">Theme</label>
                <select class="bg-gray-700 text-white rounded p-2" id="theme-switcher">
                    <option value="classic">Classic</option>
                    <option value="dr_edell">Dr. Edell</option>
                    <option value="austin">Austin</option>
                    <option value="rose">Rose</option>
                    <option value="anna">Anna</option>
                    <option value="kate">Kate</option>
                </select>
                <div class="text-right flex gap-4" id="scoreboard"></div>
            </div>
        </div>
        
        <div id="left-panel">
            <div id="player-hands-container">
                </div>
            <div id="boneyard-container">
                <h2 class="text-xl font-semibold mb-3 text-center">Boneyard</h2>
                <div id="boneyard-pile" title="Click to view and pick a domino">
                    <div id="boneyard-stack"></div>
                    <span id="boneyard-count">0</span>
                </div>
                <div class="mt-2 flex items-center justify-center gap-2" id="boneyard-buttons">
                    <button class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors" id="end-turn-button">End Turn</button>
                    <button class="bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-2 px-3 rounded transition-colors hidden" id="undo-draw-button">Undo Draw</button>
                      <button class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-3 rounded transition-colors hidden" id="undo-move-button">Undo Move</button>
                    <button class="tool-button bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-3 rounded transition-colors" id="move-branch-button">Move Branch</button>
                    <button class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded transition-colors" id="validate-move-button">Validate</button>
                    <button class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-3 rounded transition-colors" id="challenge-move-button">Challenge</button>
                </div>
            </div>
            <div id="detailed-scoreboard-container">
                <h3 class="text-lg font-semibold text-center mb-2">Score History</h3>
                <div id="detailed-scoreboard-content"></div>
            </div>
        </div>
        
        <div id="main-game-area">
            <div id="world-wrapper">
                <div id="world">
                    <div id="game-board">
                        <div id="starting-area"></div>
                    </div>
                </div>
            </div>
            <div id="minimap-container">
                <div id="minimap-viewport"></div>
            </div>
            <div id="zoom-controls" class="absolute bottom-4 right-4 z-10 flex flex-col gap-2">
                <button id="zoom-in-button" class="w-10 h-10 bg-gray-900 bg-opacity-70 rounded-full text-white text-2xl font-bold flex items-center justify-center shadow-lg hover:bg-opacity-90 transition-all">+</button>
                <button id="zoom-out-button" class="w-10 h-10 bg-gray-900 bg-opacity-70 rounded-full text-white text-2xl font-bold flex items-center justify-center shadow-lg hover:bg-opacity-90 transition-all">-</button>
            </div>
        </div>
    </div>
</div>
<script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, serverTimestamp, runTransaction, writeBatch, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

    // --- DOM Elements ---
    const dom = {
        loadingScreen: document.getElementById('loading-screen'),
        authStatus: document.getElementById('auth-status'),
        setupScreen: document.getElementById('setup-screen'),
        gameContainer: document.getElementById('game-container'),
        lobbyView: document.getElementById('lobby-view'),
        waitingRoomView: document.getElementById('waiting-room-view'),
        joinGameButton: document.getElementById('join-game-button'),
        startGameButton: document.getElementById('start-game-button'),
        reDealButton: document.getElementById('re-deal-button'),
        playerNameInput: document.getElementById('player-name'),
        joinGameIdInput: document.getElementById('join-game-id'),
        gameIdDisplay: document.getElementById('game-id-display'),
        copyGameIdButton: document.getElementById('copy-game-id'),
        playerList: document.getElementById('player-list'),
        waitingMessage: document.getElementById('waiting-message'),
        worldElement: document.getElementById('world'),
        gameBoardElement: document.getElementById('game-board'),
        boneyardPileElement: document.getElementById('boneyard-pile'),
        boneyardStack: document.getElementById('boneyard-stack'),
        boneyardContainer: document.getElementById('boneyard-container'),
        boneyardCountElement: document.getElementById('boneyard-count'),
        currentPlayerElement: document.getElementById('current-player'),
        endTurnButton: document.getElementById('end-turn-button'),
        gameStatusElement: document.getElementById('game-status'),
        playerHandsContainer: document.getElementById('player-hands-container'),
        scoreboard: document.getElementById('scoreboard'),
        themeSwitcher: document.getElementById('theme-switcher'),
        roundEndScreen: document.getElementById('round-end-screen'),
        roundEndTitle: document.getElementById('round-end-title'),
        roundWinnerMessage: document.getElementById('round-winner-message'),
        roundResultsList: document.getElementById('round-results-list'),
        continueRoundButton: document.getElementById('continue-round-button'),
        minimapContainer: document.getElementById('minimap-container'),
        minimapViewport: document.getElementById('minimap-viewport'),
        gameOverScreen: document.getElementById('game-over-screen'),
        finalWinnerMessage: document.getElementById('final-winner-message'),
        finalScoreList: document.getElementById('final-score-list'),
        mainMenuButton: document.getElementById('main-menu-button'),
        mainMenuButtonFinal: document.getElementById('main-menu-button-final'),
        messageModal: document.getElementById('message-modal'),
        messageText: document.getElementById('message-text'),
        messageOkButton: document.getElementById('message-ok-button'),
        messageCancelButton: document.getElementById('message-cancel-button'),
        gameLog: document.getElementById('game-log'),
        handValueDisplay: document.getElementById('hand-value-display'),
        validateMoveButton: document.getElementById('validate-move-button'),
        challengeMoveButton: document.getElementById('challenge-move-button'),
        detailedScoreboardContent: document.getElementById('detailed-scoreboard-content'),
        zoomInButton: document.getElementById('zoom-in-button'),
        zoomOutButton: document.getElementById('zoom-out-button'),
        roundIndicator: document.getElementById('round-indicator'),
        roundIndicatorLabel: document.getElementById('round-indicator-label'),
        rotationHandlesContainer: document.getElementById('rotation-handles-container'),
        
        // MODIFIED: Lobby DOM Elements
        createGameFlow: document.getElementById('create-game-flow'),
        joinGameFlow: document.getElementById('join-game-flow'),
        modeOnlineButton: document.getElementById('mode-online-button'),
        modeHybridButton: document.getElementById('mode-hybrid-button'),
        localPlayerSetupView: document.getElementById('local-player-setup-view'),
        localPlayerNameInput: document.getElementById('local-player-name-input'),
        addLocalPlayerButton: document.getElementById('add-local-player-button'),
        localPlayerList: document.getElementById('local-player-list'),
        createHybridGameButton: document.getElementById('create-hybrid-game-button'),
        backToModeSelectionButton: document.getElementById('back-to-mode-selection-button'),

        // NEW: Joiner Group Setup DOM Elements
        joinTypeSelectionView: document.getElementById('join-type-selection-view'),
        joinTypeGameIdDisplay: document.getElementById('join-type-game-id-display'),
        joinAsSinglePlayerButton: document.getElementById('join-as-single-player-button'),
        joinAsGroupButton: document.getElementById('join-as-group-button'),
        backToLobbyButton: document.getElementById('back-to-lobby-button'),
        joinGroupSetupView: document.getElementById('join-group-setup-view'),
        joiningGameIdDisplay: document.getElementById('joining-game-id-display'),
        joinerLocalPlayerNameInput: document.getElementById('joiner-local-player-name-input'),
        addJoinerLocalPlayerButton: document.getElementById('add-joiner-local-player-button'),
        joinerLocalPlayerList: document.getElementById('joiner-local-player-list'),
        confirmJoinGroupButton: document.getElementById('confirm-join-group-button'),
        
        // NEW: Round Start Screen Elements
        roundStartScreen: document.getElementById('round-start-screen'),
        roundStartNumber: document.getElementById('round-start-number'),
        roundStarterName: document.getElementById('round-starter-name'),
        roundStartWaitMessage: document.getElementById('round-start-wait-message'),
        confirmRoundStartButton: document.getElementById('confirm-round-start-button'),

        // Pass Device Screen Elements
        passDeviceScreen: document.getElementById('pass-device-screen'),
        nextPlayerNamePass: document.getElementById('next-player-name-pass'),
        confirmTurnButton: document.getElementById('confirm-turn-button'),

        // NEW: Move Branch buttons
        moveBranchButton: document.getElementById('move-branch-button'),
        undoDrawButton: document.getElementById('undo-draw-button'),
        // CHANGE: Add Undo Move Button to DOM elements
        undoMoveButton: document.getElementById('undo-move-button'),

        // NEW: Boneyard Picker elements
        boneyardPickerModal: document.getElementById('boneyard-picker-modal'),
        boneyardPickerWrapper: document.getElementById('boneyard-picker-wrapper'),
        boneyardPickerCloseButton: document.getElementById('boneyard-picker-close-button'),
    };
    
    // --- Firebase & Game State ---
    let db, auth, analytics;
    let currentGameId = null;
    let currentPlayerId = null;
    let localGameState = {};
    let unsubscribeGameListener = null;
    let localPlayers = []; // For host
    let joinerLocalPlayers = []; // NEW: For joiner

    const PLAYER_COLORS = ['#E6194B', '#4363d8', '#3cb44b', '#ffe119', '#911eb4', '#f58231', '#42d4f4', '#f032e6'];
    const SPINNER_VALUE = -1;
    const BOARD_SIZE = 4000;
    const DOMINO_WIDTH = 80;
    const DOMINO_HEIGHT = 40;
    // NEW: Proximity check threshold
    const PLACEMENT_PROXIMITY_THRESHOLD = DOMINO_WIDTH * 1.2;
    
    // --- Interaction State ---
    let isDraggingDomino = false;
    let wasDragged = false;
    let dragStartPos = { x: 0, y: 0 };
    let dragStartTime = 0;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let boardPosition = { x: 0, y: 0 };
    let zoomLevel = 1.0;
    const MIN_ZOOM = 0.3;
    const MAX_ZOOM = 3.0;
    let activeDominoElement = null;
    let draggedDominoData = null;
    let originalDominoElement = null;
    let longPressTimer = null; // For radial menu on touch
    let isRotating = false;
    
    // --- REWORKED: Branch Moving State (No Physics) ---
    let moveBranchMode = false;
    let selectedBranch = {
        anchor: null, // The domino object that is the pivot point
        dominos: [], // Array of all domino objects in the branch
        originalPositions: new Map(), // Map of dominoId -> {x, y, rotation}
        isDraggingBranch: false,
    };
    
    // --- Firebase Initialization ---
    async function initializeFirebase() {
        try {
            const firebaseConfig = {
                apiKey: "AIzaSyCTmUo5UpQW77xhOkI_3XELSISo6WHyqLs",
                authDomain: "spinner-live.firebaseapp.com",
                projectId: "spinner-live",
                storageBucket: "spinner-live.appspot.com",
                messagingSenderId: "878930500451",
                appId: "1:878930500451:web:e281c28d5c29218044d156",
                measurementId: "G-BPHD3B8WDT"
            };
            const app = initializeApp(firebaseConfig);

            db = getFirestore(app);
            auth = getAuth(app);
            analytics = getAnalytics(app);

            dom.authStatus.textContent = 'Authenticating...';

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentPlayerId = user.uid;
                    enableLobby();
                } else {
                    await signInAnonymously(auth);
                }
            });
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            dom.authStatus.textContent = "Error: Could not connect. Please refresh.";
            showMessage(`Firebase Error: ${error.message}`);
        }
    }
    
    // FIX: Modified showMessage to reset modal buttons to default
    function showMessage(message, options = {}) {
        dom.messageText.textContent = message;
        
        // Reset buttons
        dom.messageOkButton.textContent = 'OK';
        dom.messageOkButton.className = 'w-full bg-blue-600 hover:bg-blue-700 font-bold py-2 px-3 rounded transition-colors';
        dom.messageOkButton.onclick = () => dom.messageModal.classList.add('hidden');
        dom.messageCancelButton.classList.add('hidden');
        dom.messageCancelButton.textContent = 'Cancel';
        dom.messageCancelButton.className = 'w-full bg-gray-600 hover:bg-gray-700 font-bold py-2 px-3 rounded transition-colors';
        dom.messageCancelButton.onclick = null;
        
        // Apply options
        if (options.confirmText) {
            dom.messageOkButton.textContent = options.confirmText;
        }
        if (options.onConfirm) {
            dom.messageOkButton.onclick = () => {
                dom.messageModal.classList.add('hidden');
                options.onConfirm();
            };
        }
        if (options.confirmClass) {
            dom.messageOkButton.className = `w-full ${options.confirmClass} font-bold py-2 px-3 rounded transition-colors`;
        }
        if (options.showCancel) {
            dom.messageCancelButton.classList.remove('hidden');
            if (options.cancelText) {
                 dom.messageCancelButton.textContent = options.cancelText;
            }
             if (options.cancelClass) {
                dom.messageCancelButton.className = `w-full ${options.cancelClass} font-bold py-2 px-3 rounded transition-colors`;
            }
            dom.messageCancelButton.onclick = () => {
                dom.messageModal.classList.add('hidden');
                if(options.onCancel) {
                      options.onCancel();
                }
            }
        }

        dom.messageModal.classList.remove('hidden');
    }

    dom.messageOkButton.addEventListener('click', () => {
        dom.messageModal.classList.add('hidden');
    });
    
    function enableLobby() {
        dom.authStatus.textContent = 'Ready to Play!';
        dom.loadingScreen.classList.add('hidden');
        dom.setupScreen.classList.remove('hidden');
        dom.joinGameButton.disabled = false;
        dom.modeOnlineButton.disabled = false;
        dom.modeHybridButton.disabled = false;
    }

    // --- Lobby and Game Setup --- (No major changes in this section)
    function showMainLobbyView() {
        dom.createGameFlow.classList.remove('hidden');
        dom.joinGameFlow.classList.remove('hidden');
        dom.localPlayerSetupView.classList.add('hidden');
        dom.joinGroupSetupView.classList.add('hidden');
        dom.joinTypeSelectionView.classList.add('hidden');
    }

    function showHostHybridSetup() {
        dom.createGameFlow.classList.add('hidden');
        dom.joinGameFlow.classList.add('hidden');
        dom.localPlayerSetupView.classList.remove('hidden');
        updateLocalPlayerList();
    }
    
    function addLocalPlayer() {
        const name = dom.localPlayerNameInput.value.trim();
        if (name && localPlayers.length < 7) {
            localPlayers.push({ name });
            dom.localPlayerNameInput.value = '';
            updateLocalPlayerList();
        } else if (localPlayers.length >= 7) {
            showMessage("You can have a maximum of 8 players total (including you).");
        }
    }

    function removeLocalPlayer(index) {
        localPlayers.splice(index, 1);
        updateLocalPlayerList();
    }

    function updateLocalPlayerList() {
        dom.localPlayerList.innerHTML = '';
        if (localPlayers.length > 0) {
            localPlayers.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = "flex justify-between items-center bg-gray-700 p-2 rounded";
                item.innerHTML = `<span>${player.name}</span><button data-index="${index}" class="bg-red-500 text-white w-6 h-6 rounded-full flex items-center justify-center font-bold">&times;</button>`;
                item.querySelector('button').addEventListener('click', () => removeLocalPlayer(index));
                dom.localPlayerList.appendChild(item);
            });
        } else {
             dom.localPlayerList.innerHTML = '<p class="text-gray-500 text-center text-sm">No local players added yet.</p>';
        }
        dom.createHybridGameButton.disabled = localPlayers.length === 0;
    }

    function addJoinerLocalPlayer() {
        const name = dom.joinerLocalPlayerNameInput.value.trim();
        if (name && joinerLocalPlayers.length < 7) {
            joinerLocalPlayers.push({ name });
            dom.joinerLocalPlayerNameInput.value = '';
            updateJoinerLocalPlayerList();
        } else if (joinerLocalPlayers.length >= 7) {
            showMessage("You can have a maximum of 8 players total in your group (including you).");
        }
    }

    function removeJoinerLocalPlayer(index) {
        joinerLocalPlayers.splice(index, 1);
        updateJoinerLocalPlayerList();
    }

    function updateJoinerLocalPlayerList() {
        dom.joinerLocalPlayerList.innerHTML = '';
        if (joinerLocalPlayers.length > 0) {
            joinerLocalPlayers.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = "flex justify-between items-center bg-gray-700 p-2 rounded";
                item.innerHTML = `<span>${player.name}</span><button data-index="${index}" class="bg-red-500 text-white w-6 h-6 rounded-full flex items-center justify-center font-bold">&times;</button>`;
                item.querySelector('button').addEventListener('click', () => removeJoinerLocalPlayer(index));
                dom.joinerLocalPlayerList.appendChild(item);
            });
        } else {
             dom.joinerLocalPlayerList.innerHTML = '<p class="text-gray-500 text-center text-sm">No other local players added yet.</p>';
        }
    }

    const handleCreateOnlineGame = async () => {
        if (!currentPlayerId) return;
        const playerName = dom.playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;
        
        const players = {
            [currentPlayerId]: { id: currentPlayerId, controller: currentPlayerId, name: playerName, score: 0, hand: [], isHost: true }
        };
        const playerOrder = [currentPlayerId];
        
        await createGameInFirestore(players, playerOrder);
    };
    
    const handleCreateHybridGame = async () => {
        if (!currentPlayerId) return;
        const hostName = dom.playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;

        const players = {
            [currentPlayerId]: { id: currentPlayerId, controller: currentPlayerId, name: hostName, score: 0, hand: [], isHost: true }
        };
        const playerOrder = [currentPlayerId];

        localPlayers.forEach((p, i) => {
            const localId = `local_${Date.now()}_${i}`;
            players[localId] = { id: localId, controller: currentPlayerId, name: p.name, score: 0, hand: [], isHost: false };
            playerOrder.push(localId);
        });

        await createGameInFirestore(players, playerOrder);
    };

    async function createGameInFirestore(players, playerOrder) {
        const tempGameRef = doc(collection(db, 'games'));
        const gameId = tempGameRef.id.substring(0, 6).toUpperCase();
        const gameRef = doc(db, "games", gameId);

        playerOrder.forEach((pid, index) => {
            players[pid].color = PLAYER_COLORS[index % PLAYER_COLORS.length];
        });

        const initialGameState = {
            players, playerOrder, gameStatus: 'waiting', boardDominos: [], boneyard: [],
            boneyardLayout: [],
            currentPlayerIndex: 0, roundNumber: 0, currentStartingDouble: 9, turnState: 'WAITING',
            hasDrawn: false, scoreHistory: [], mustDrawToStart: false, lastPlayedDominoId: null,
            lastDrawnDominoId: null, passCount: 0, moveHistory: [], log: [], currentTheme: 'classic',
            createdAt: serverTimestamp(), turnConfirmationPending: false,
            undoRequestedThisTurn: false,
            undoRequest: { requestingPlayerId: null, type: null, approvals: [], status: 'none' } 
        };

        await setDoc(gameRef, initialGameState);
        await joinGame(gameId);
    }

    const handleFindGame = async () => {
        const gameId = dom.joinGameIdInput.value.trim().toUpperCase();
        if (!gameId) {
            showMessage("Please enter a Game ID.");
            return;
        }

        const gameRef = doc(db, "games", gameId);
        const gameSnap = await getDoc(gameRef);

        if (!gameSnap.exists()) {
            showMessage("Game not found. Please check the ID.");
            return;
        }
        
        dom.createGameFlow.classList.add('hidden');
        dom.joinGameFlow.classList.add('hidden');
        dom.joinTypeSelectionView.classList.remove('hidden');
        dom.joinTypeGameIdDisplay.textContent = gameId;
    };

    const handleJoinAsSinglePlayer = async () => {
        const gameId = dom.joinTypeGameIdDisplay.textContent;
        const playerName = dom.playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;
        const gameRef = doc(db, "games", gameId);

        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw new Error("Game not found.");
                const gameData = gameSnap.data();

                if (Object.keys(gameData.players).length >= 8) {
                    throw new Error("This game is full.");
                }

                const playerCount = gameData.playerOrder.length;
                const newPlayerColor = PLAYER_COLORS[playerCount % PLAYER_COLORS.length];
                const newPlayer = { id: currentPlayerId, controller: currentPlayerId, name: playerName, score: 0, hand: [], isHost: false, color: newPlayerColor };
                
                transaction.update(gameRef, {
                    [`players.${currentPlayerId}`]: newPlayer,
                    playerOrder: [...gameData.playerOrder, currentPlayerId]
                });
            });
            await joinGame(gameId);
        } catch (error) {
            console.error("Error joining as single player:", error);
            showMessage(error.message);
            showMainLobbyView();
        }
    };

    const handleShowJoinAsGroup = () => {
        const gameId = dom.joinTypeGameIdDisplay.textContent;
        dom.joinTypeSelectionView.classList.add('hidden');
        dom.joinGroupSetupView.classList.remove('hidden');
        dom.joiningGameIdDisplay.textContent = gameId;
        updateJoinerLocalPlayerList();
    };

    const handleConfirmJoinGroup = async () => {
        if (!currentPlayerId) return;
        const gameId = dom.joiningGameIdDisplay.textContent;
        const playerName = dom.playerNameInput.value.trim() || `Player ${currentPlayerId.substring(0, 4)}`;

        const gameRef = doc(db, "games", gameId);
        
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw new Error("Game not found.");
                
                const gameData = gameSnap.data();
                let playerCount = gameData.playerOrder.length;
                const updates = {};
                const newPlayerIds = [];

                const mainPlayerColor = PLAYER_COLORS[playerCount % PLAYER_COLORS.length];
                playerCount++;
                updates[`players.${currentPlayerId}`] = { id: currentPlayerId, controller: currentPlayerId, name: playerName, score: 0, hand: [], isHost: false, color: mainPlayerColor };
                newPlayerIds.push(currentPlayerId);

                joinerLocalPlayers.forEach((p, i) => {
                    const localId = `local_${Date.now()}_${i}`;
                    const localPlayerColor = PLAYER_COLORS[playerCount % PLAYER_COLORS.length];
                    playerCount++;
                    updates[`players.${localId}`] = { id: localId, controller: currentPlayerId, name: p.name, score: 0, hand: [], isHost: false, color: localPlayerColor };
                    newPlayerIds.push(localId);
                });

                if (Object.keys(gameData.players).length + newPlayerIds.length > 8) {
                    throw new Error("This would exceed the maximum of 8 players.");
                }

                updates.playerOrder = [...gameData.playerOrder, ...newPlayerIds];

                transaction.update(gameRef, updates);
            });

            await joinGame(gameId);

        } catch (error) {
            console.error("Error joining game with group:", error);
            showMessage(error.message);
            showMainLobbyView();
        }
    };


    dom.modeOnlineButton.addEventListener('click', handleCreateOnlineGame);
    dom.modeHybridButton.addEventListener('click', showHostHybridSetup);
    dom.backToModeSelectionButton.addEventListener('click', showMainLobbyView);
    dom.addLocalPlayerButton.addEventListener('click', addLocalPlayer);
    dom.localPlayerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addLocalPlayer(); });
    dom.createHybridGameButton.addEventListener('click', handleCreateHybridGame);
    
    dom.joinGameButton.addEventListener('click', handleFindGame);
    dom.joinAsSinglePlayerButton.addEventListener('click', handleJoinAsSinglePlayer);
    dom.joinAsGroupButton.addEventListener('click', handleShowJoinAsGroup);
    dom.backToLobbyButton.addEventListener('click', showMainLobbyView);

    dom.addJoinerLocalPlayerButton.addEventListener('click', addJoinerLocalPlayer);
    dom.joinerLocalPlayerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addJoinerLocalPlayer(); });
    dom.confirmJoinGroupButton.addEventListener('click', handleConfirmJoinGroup);


    async function joinGame(gameId) {
        currentGameId = gameId;
        
        if (unsubscribeGameListener) unsubscribeGameListener();
        unsubscribeGameListener = onSnapshot(doc(db, "games", currentGameId), (doc) => {
            if (doc.exists()) {
                handleGameStateUpdate(doc.data());
            } else {
                showMessage("The game has ended or was deleted.");
                leaveGame();
            }
        });
    }

    function leaveGame() {
        window.location.reload();
    }
    dom.mainMenuButton.addEventListener('click', leaveGame);
    dom.mainMenuButtonFinal.addEventListener('click', leaveGame);

    dom.copyGameIdButton.addEventListener('click', () => {
        const copyText = currentGameId;
        // Use modern clipboard API if available, with a fallback
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(copyText).then(() => {
                dom.copyGameIdButton.textContent = 'Copied!';
                setTimeout(() => { dom.copyGameIdButton.textContent = 'Copy'; }, 2000);
            });
        } else {
            // Fallback for insecure contexts or older browsers
            const textArea = document.createElement("textarea");
            textArea.value = copyText;
            textArea.style.position = "absolute";
            textArea.style.left = "-9999px";
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                dom.copyGameIdButton.textContent = 'Copied!';
            } catch (err) {
                console.error('Fallback copy failed', err);
                dom.copyGameIdButton.textContent = 'Failed!';
            }
            document.body.removeChild(textArea);
            setTimeout(() => { dom.copyGameIdButton.textContent = 'Copy'; }, 2000);
        }
    });

    dom.startGameButton.addEventListener('click', () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            startRound();
        }
    });
    
    dom.reDealButton.addEventListener('click', () => {
        if (localGameState.players[currentPlayerId]?.isHost) {
            startRound();
        }
    });

    // --- Main Game State Handler ---
    function handleGameStateUpdate(gameState) {
        const oldStatus = localGameState.gameStatus;
        const oldTheme = localGameState.currentTheme;
        const oldUndoStatus = localGameState.undoRequest?.status;
        const oldTurnState = localGameState.turnState;

        const newTheme = gameState.currentTheme;
        localGameState = gameState; 

        if (!gameState.players || !gameState.playerOrder || gameState.playerOrder.length === 0) {
            return;
        }
        
        // If validation just started, focus on the domino
        if (oldTurnState !== 'PENDING_VALIDATION' && gameState.turnState === 'PENDING_VALIDATION') {
            const dominoToValidate = gameState.boardDominos.find(d => d.dominoData.id === gameState.lastPlayedDominoId);
            if (dominoToValidate) {
                focusOnDomino(dominoToValidate);
            }
        }

        // --- UNDO VALIDATION: Handle incoming undo requests ---
        handleUndoRequest(gameState, oldUndoStatus);

        // --- If the theme changed, clear the board to force a full re-render of dominoes ---
        if (oldTheme !== newTheme) {
            dom.gameBoardElement.innerHTML = '<div id="starting-area"></div>';
        }

        const currentTurnPlayer = gameState.players[gameState.playerOrder[gameState.currentPlayerIndex]];
        if (gameState.turnConfirmationPending && currentTurnPlayer && currentTurnPlayer.controller === currentPlayerId) {
            dom.loadingScreen.classList.add('hidden');
            dom.setupScreen.classList.add('hidden');
            dom.gameContainer.classList.add('hidden');
            dom.roundStartScreen.classList.add('hidden');
            showPassDeviceScreen(currentTurnPlayer.name);
            return;
        }

        if (gameState.gameStatus === 'round-starting') {
            dom.loadingScreen.classList.add('hidden');
            dom.setupScreen.classList.add('hidden');
            dom.gameContainer.classList.add('hidden');
            dom.passDeviceScreen.classList.add('hidden');
            showRoundStartScreen(gameState);
            return;
        }

        if (gameState.gameStatus === 'waiting') {
            dom.loadingScreen.classList.add('hidden');
            dom.gameContainer.classList.add('hidden');
            dom.passDeviceScreen.classList.add('hidden');
            dom.roundStartScreen.classList.add('hidden');
            dom.setupScreen.classList.remove('hidden');
            dom.lobbyView.classList.add('hidden');
            dom.waitingRoomView.classList.remove('hidden');
            updateWaitingRoomUI(gameState);
            return;
        }

        if (['in-progress', 'round-over', 'finished'].includes(gameState.gameStatus)) {
            dom.loadingScreen.classList.add('hidden');
            dom.setupScreen.classList.add('hidden');
            dom.passDeviceScreen.classList.add('hidden'); 
            dom.roundStartScreen.classList.add('hidden');
            dom.gameContainer.classList.remove('hidden');
            
            // Center board at the start of every round.
            if (oldStatus !== 'in-progress' && gameState.gameStatus === 'in-progress') {
                requestAnimationFrame(() => {
                    requestAnimationFrame(centerBoardOnStart);
                });
            }

            renderGameUI(gameState);

            if (gameState.gameStatus === 'round-over') {
                displayRoundEndScreen(gameState);
            } else {
                dom.roundEndScreen.classList.add('hidden');
            }

            if (gameState.gameStatus === 'finished') {
                showFinalScores(gameState);
            } else {
                dom.gameOverScreen.classList.add('hidden');
            }
            return;
        }
    }

    function updateWaitingRoomUI(gameState) {
        dom.gameIdDisplay.textContent = currentGameId;
        const playerIds = gameState.playerOrder;
        const playerCount = playerIds.length;
        const isHost = gameState.players[currentPlayerId]?.isHost;
        dom.playerList.innerHTML = '';
        playerIds.forEach(pid => {
            const p = document.createElement('p');
            p.textContent = `${gameState.players[pid].name} ${gameState.players[pid].isHost ? '(Host)' : ''}`;
            dom.playerList.appendChild(p);
        });
        const canStart = isHost && playerCount >= 2 && playerCount <= 8;
        dom.startGameButton.disabled = !canStart;
        dom.reDealButton.classList.add('hidden');
        if (isHost) {
            if (playerCount < 2) dom.waitingMessage.textContent = "Need at least 2 players to start.";
            else if (playerCount > 8) dom.waitingMessage.textContent = "Cannot start with more than 8 players.";
            else dom.waitingMessage.textContent = "You're the host. Start the game when ready!";
        } else {
            dom.waitingMessage.textContent = "Waiting for the host to start the game...";
        }
    }
    
    function showPassDeviceScreen(nextPlayerName) {
        dom.nextPlayerNamePass.textContent = nextPlayerName;
        dom.passDeviceScreen.classList.remove('hidden');
    }

    dom.confirmTurnButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        await updateDoc(gameRef, { turnConfirmationPending: false });
    });
    
    function showRoundStartScreen(gameState) {
        const { roundNumber, roundStartInfo } = gameState;
        const starter = gameState.players[roundStartInfo.starterId];
        dom.roundEndScreen.classList.add('hidden');
        dom.roundStartNumber.textContent = roundNumber;
        dom.roundStarterName.textContent = starter.name;
        const isLocalPlayerStarting = starter.controller === currentPlayerId && starter.id !== currentPlayerId;
        if (starter.controller === currentPlayerId) {
            dom.confirmRoundStartButton.classList.remove('hidden');
            dom.roundStartWaitMessage.classList.add('hidden');
            if (isLocalPlayerStarting) {
                dom.confirmRoundStartButton.textContent = `Ready to Pass to ${starter.name}`;
                dom.roundStartWaitMessage.textContent = `When ready, confirm to pass the device to ${starter.name}.`;
                dom.roundStartWaitMessage.classList.remove('hidden');
            } else {
                dom.confirmRoundStartButton.textContent = 'Start Round';
            }
        } else {
            dom.confirmRoundStartButton.classList.add('hidden');
            dom.roundStartWaitMessage.textContent = `Waiting for ${localGameState.players[starter.controller].name} to start the round...`;
            dom.roundStartWaitMessage.classList.remove('hidden');
        }
        dom.roundStartScreen.classList.remove('hidden');
    }

    dom.confirmRoundStartButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        const { roundStartInfo, players, roundNumber } = localGameState;
        const starter = players[roundStartInfo.starterId];
        const needsConfirmation = starter.controller === currentPlayerId && starter.id !== currentPlayerId;
        await updateDoc(gameRef, {
            gameStatus: 'in-progress',
            currentPlayerIndex: roundStartInfo.starterIndex,
            roundStartInfo: null,
            turnConfirmationPending: needsConfirmation,
            log: [...(localGameState.log || []), `Round ${roundNumber} started. ${starter.name} to play.`]
        });
    });

    // --- Core Game Logic ---
    function generateDeck() {
        const deck = [];
        for (let i = 0; i <= 9; i++) {
            for (let j = i; j <= 9; j++) deck.push({ top: i, bottom: j, id: `d-${i}-${j}` });
        }
        for (let i = 0; i <= 9; i++) deck.push({ top: SPINNER_VALUE, bottom: i, id: `s-${i}` });
        deck.push({ top: SPINNER_VALUE, bottom: SPINNER_VALUE, id: 'd-s-s' });
        return deck;
    }

    function shuffle(deck) {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    }
    
    async function startRound() {
        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw new Error("Game not found.");
                const currentData = gameSnap.data();
                if (!['waiting', 'in-progress', 'round-over'].includes(currentData.gameStatus)) {
                    throw new Error("Invalid state for starting a new round.");
                }
                const playerIds = currentData.playerOrder;
                const deck = generateDeck();
                shuffle(deck);
                const dominoesPerPlayer = 7;
                const updatedPlayers = JSON.parse(JSON.stringify(currentData.players));
                playerIds.forEach(pid => {
                    updatedPlayers[pid].hand = deck.splice(0, dominoesPerPlayer);
                });

                const boneyard = deck;
                const boneyardLayout = [];
                boneyard.forEach(dominoData => {
                    const randRotation = Math.random() * 30 - 15; 
                    boneyardLayout.push({
                        id: dominoData.id,
                        rotation: randRotation
                    });
                });

                const newRoundNumber = currentData.roundNumber + 1;
                // Calculates 9 for Round 1, 8 for Round 2, etc.
                const newStartingDouble = 9 - ((newRoundNumber - 1) % 10);
                
                let starterIndex;
                let mustDraw = false;
                
                // 1. Check if anyone was dealt the specific Double or Double Spinner
                const tileStarterIndex = findRoundStarter(updatedPlayers, playerIds, newStartingDouble);
                
                if (tileStarterIndex !== -1) {
                    // Someone has the required tile! They start and play immediately.
                    starterIndex = tileStarterIndex;
                    mustDraw = false;
                } else {
                    // 2. NO ONE has the required tile. 
                    // We must pick a starter who is forced to DRAW to find it.
                    
                    if (newRoundNumber === 1) {
                        // Round 1 Fallback: Player with highest pip count starts
                        let highestScore = -1;
                        let highestScoreIndex = -1;
                        for (let i = 0; i < playerIds.length; i++) {
                            const pid = playerIds[i];
                            const handValue = calculateHandValue(updatedPlayers[pid].hand);
                            if (handValue > highestScore) {
                                highestScore = handValue;
                                highestScoreIndex = i;
                            }
                        }
                        starterIndex = highestScoreIndex;
                    } else {
                        // Round 2+ Fallback: Previous winner starts
                        const previousWinnerId = currentData.roundEndInfo?.winnerId;
                        const previousWinnerIndex = playerIds.indexOf(previousWinnerId);
                        
                        if (previousWinnerId && previousWinnerIndex !== -1) {
                            starterIndex = previousWinnerIndex;
                        } else {
                             starterIndex = 0; // Fallback if data is missing
                        }
                    }
                    
                    // CRITICAL: Since no one has the starting tile, the starter MUST draw.
                    mustDraw = true; 
                }

                const starterId = playerIds[starterIndex];
                const newRoundState = {
                    gameStatus: 'round-starting',
                    players: updatedPlayers,
                    boneyard: boneyard,
                    boneyardLayout: boneyardLayout,
                    boardDominos: [],
                    roundNumber: newRoundNumber,
                    currentStartingDouble: newStartingDouble,
                    mustDrawToStart: mustDraw, // Applies the rule here
                    turnState: 'WAITING',
                    hasDrawn: false,
                    lastPlayedDominoId: null,
                    lastDrawnDominoId: null,
                    passCount: 0,
                    moveHistory: [],
                    log: [],
                    roundEndInfo: null,
                    turnConfirmationPending: false,
                    undoRequestedThisTurn: false,
                    undoRequest: { requestingPlayerId: null, type: null, approvals: [], status: 'none' },
                    roundStartInfo: {
                        starterId: starterId,
                        starterIndex: starterIndex,
                    }
                };
                transaction.update(gameRef, newRoundState);
            });
        } catch (error) {
            console.error("Failed to start next round:", error);
            showMessage("Could not start the next round. Someone may have already started it.");
            if (dom.roundEndScreen && !dom.roundEndScreen.classList.contains('hidden')) {
                dom.continueRoundButton.disabled = false;
                dom.continueRoundButton.textContent = "Start Next Round";
            }
        }
    }
    
    function findRoundStarter(players, playerOrder, requiredDoubleValue) {
        const hasSpecificDouble = (hand, val) => hand.some(d => d.top === val && d.bottom === val);
        const hasDoubleSpinner = (hand) => hand.some(d => d.top === SPINNER_VALUE && d.bottom === SPINNER_VALUE);
        for (let i = 0; i < playerOrder.length; i++) {
            const pid = playerOrder[i];
            if (hasSpecificDouble(players[pid].hand, requiredDoubleValue)) {
                return i;
            }
        }
        for (let i = 0; i < playerOrder.length; i++) {
            const pid = playerOrder[i];
            if (hasDoubleSpinner(players[pid].hand)) {
                return i;
            }
        }
        return -1;
    }
    
    // --- Boneyard Picker Logic ---
    function openBoneyardPicker() {
        const currentTurnPlayer = localGameState.players[localGameState.playerOrder[localGameState.currentPlayerIndex]];
        const isMyDeviceTurn = currentTurnPlayer.controller === currentPlayerId;
        const isMyTurnToDraw = isMyDeviceTurn && localGameState.turnState === 'WAITING' && !localGameState.hasDrawn;

        if (isMyTurnToDraw && localGameState.boneyard.length === 0) {
            endRoundAsBlocked();
            return;
        }

        const canDraw = isMyTurnToDraw && localGameState.boneyard.length > 0
        if (!canDraw) return;
        
        // --- Animation Logic: Set transform origin to the boneyard pile ---
        const pileRect = dom.boneyardPileElement.getBoundingClientRect();
        const originX = pileRect.left + pileRect.width / 2;
        const originY = pileRect.top + pileRect.height / 2;
        dom.boneyardPickerModal.style.transformOrigin = `${originX}px ${originY}px`;
        
        // Make modal visible to trigger CSS animation
        dom.boneyardPickerModal.classList.remove('hidden');
        
        const container = dom.boneyardPickerWrapper;
        container.innerHTML = ''; // Clear previous

        const currentBoneyardIds = new Set(localGameState.boneyard.map(d => d.id));

        if (localGameState.boneyardLayout) {
            // Iterate through the persistent layout to maintain order
            localGameState.boneyardLayout.forEach((layoutData, index) => {
                if (currentBoneyardIds.has(layoutData.id)) {
                    // Domino is still in the boneyard, render it
                    const dominoData = localGameState.boneyard.find(d => d.id === layoutData.id);
                    const dominoElement = createDomino(dominoData, true); // true for back
                    dominoElement.classList.add('boneyard-picker-domino');
                    dominoElement.style.cursor = 'pointer';
                    
                    // Apply the persistent random rotation
                    dominoElement.style.setProperty('--rotation', `${layoutData.rotation}deg`);
                    
                    dominoElement.addEventListener('click', () => selectDominoFromBoneyard(dominoData));
                    container.appendChild(dominoElement);
                } else {
                    // Domino has been picked, render a blank spot placeholder
                    const blankSpot = document.createElement('div');
                    blankSpot.className = 'boneyard-picker-blank-spot';
                    container.appendChild(blankSpot);
                }
            });
        }
    }

    function closeBoneyardPicker() {
        dom.boneyardPickerModal.classList.add('hidden');
    }
    dom.boneyardPickerCloseButton.addEventListener('click', closeBoneyardPicker);

    async function selectDominoFromBoneyard(selectedDomino) {
        closeBoneyardPicker();
        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw "Game does not exist!";
                const gameState = gameSnap.data();
                
                const currentTurnPlayer = gameState.players[gameState.playerOrder[gameState.currentPlayerIndex]];
                const isMyDeviceTurn = currentTurnPlayer.controller === currentPlayerId;
                if (!isMyDeviceTurn || gameState.hasDrawn || gameState.turnState !== 'WAITING' || gameState.boneyard.length === 0) {
                    return; // Condition changed, abort.
                }

                const boneyard = [...gameState.boneyard];
                const dominoIndex = boneyard.findIndex(d => d.id === selectedDomino.id);

                if (dominoIndex === -1) {
                    throw new Error("Chosen domino is no longer in the boneyard.");
                }

                const [drawnDomino] = boneyard.splice(dominoIndex, 1);
                
                const updatedPlayers = { ...gameState.players };
                updatedPlayers[currentTurnPlayer.id].hand.push(drawnDomino);
                
                const newLog = [...(gameState.log || [])];
                newLog.push(`${currentTurnPlayer.name} drew from the boneyard.`);
                if (newLog.length > 5) newLog.shift();
                
                transaction.update(gameRef, {
                    players: updatedPlayers,
                    boneyard: boneyard,
                    hasDrawn: true,
                    lastDrawnDominoId: drawnDomino.id, 
                    mustDrawToStart: false, 
                    log: newLog
                });
            });
        } catch (error) {
            console.error("Error drawing from boneyard:", error);
            showMessage("Could not draw a domino. Please try again.");
        }
    }

    dom.boneyardPileElement.addEventListener('click', openBoneyardPicker);
    dom.boneyardPileElement.addEventListener('touchstart', (e) => { e.preventDefault(); openBoneyardPicker(); });

    async function submitTurnForValidation() {
        dom.endTurnButton.disabled = true;

        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw "Game does not exist!";
                
                const gameState = gameSnap.data();
                const currentTurnPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
                const currentTurnPlayer = gameState.players[currentTurnPlayerId];
                const newLog = [...(gameState.log || [])];
                
                const isPassing = gameState.hasDrawn && gameState.turnState === 'WAITING';

                if (isPassing) {
                    newLog.push(`${currentTurnPlayer.name} passed their turn.`);
                    if (newLog.length > 5) newLog.shift();
                    
                    const newPassCount = (gameState.passCount || 0) + 1;
                    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.playerOrder.length;
                    const nextPlayer = gameState.players[gameState.playerOrder[nextPlayerIndex]];
                    
                    // FIX: Only show pass device screen for local players on the same device
                    const needsConfirmation = currentTurnPlayer.controller === nextPlayer.controller && currentTurnPlayer.id !== nextPlayer.id;

                    transaction.update(gameRef, {
                        currentPlayerIndex: nextPlayerIndex,
                        turnState: 'WAITING',
                        hasDrawn: false,
                        lastDrawnDominoId: null,
                        passCount: newPassCount,
                        log: newLog,
                        turnConfirmationPending: needsConfirmation,
                        undoRequestedThisTurn: false // Reset flag
                    });
                    
                } else if (gameState.turnState === 'PLACED') {
                    // This is for submitting a played tile
                    newLog.push(`${currentTurnPlayer.name} submitted their move for validation.`);
                    if (newLog.length > 5) newLog.shift();

                    const controllerIds = new Set(Object.values(gameState.players).map(p => p.controller));
                    
                    // If single controller (hot-seat), auto-validate and pass turn
                    if (controllerIds.size === 1) {
                        const playerHand = gameState.players[currentTurnPlayerId].hand;
                        if (playerHand.length === 0) {
                            // Player went out, end the round
                            let roundPoints = {};
                            let scoreHistoryEntry = { round: gameState.roundNumber, scores: {} };
                            const updatedPlayers = { ...gameState.players };
                            Object.keys(updatedPlayers).forEach(pid => {
                                const handValue = (pid === currentTurnPlayerId) ? 0 : calculateHandValue(updatedPlayers[pid].hand);
                                updatedPlayers[pid].score += handValue;
                                roundPoints[pid] = handValue;
                                scoreHistoryEntry.scores[pid] = handValue;
                            });
                            
                            const newScoreHistory = [...(gameState.scoreHistory || []), scoreHistoryEntry];
                            const isGameOver = gameState.roundNumber >= 10;
                            
                            transaction.update(gameRef, {
                                players: updatedPlayers,
                                gameStatus: isGameOver ? 'finished' : 'round-over',
                                roundEndInfo: { winnerId: currentTurnPlayerId, points: roundPoints },
                                scoreHistory: newScoreHistory,
                                passCount: 0
                            });
                        } else {
                            // Just pass the turn
                            const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.playerOrder.length;
                            const nextPlayer = gameState.players[gameState.playerOrder[nextPlayerIndex]];
                            const needsConfirmation = currentTurnPlayer.controller === nextPlayer.controller && currentTurnPlayer.id !== nextPlayer.id;
                            
                            transaction.update(gameRef, {
                                currentPlayerIndex: nextPlayerIndex,
                                turnState: 'WAITING',
                                hasDrawn: false,
                                moveHistory: [],
                                lastPlayedDominoId: null,
                                log: newLog,
                                turnConfirmationPending: needsConfirmation,
                                lastDrawnDominoId: null,
                                passCount: 0, // Reset pass count
                                undoRequestedThisTurn: false // Reset flag
                            });
                        }
                    } else {
                        // For multiple controllers, set to pending validation
                        transaction.update(gameRef, {
                            turnState: 'PENDING_VALIDATION',
                            log: newLog,
                            lastDrawnDominoId: null,
                            passCount: 0 // Reset pass count
                        });
                    }
                }
            });
        } catch(error) {
            console.error("Error ending turn:", error);
            showMessage("Could not end turn. Please try again.");
            // The button state will be updated by handleGameStateUpdate on the next snapshot
        }
    }
    dom.endTurnButton.addEventListener('click', submitTurnForValidation);
    
    // NEW: Function to end round if blocked
    async function endRoundAsBlocked() {
        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw "Game does not exist!";
                const gameState = gameSnap.data();

                // Calculate scores
                let roundPoints = {};
                let scoreHistoryEntry = { round: gameState.roundNumber, scores: {} };
                const updatedPlayers = { ...gameState.players };
                
                let lowestScore = Infinity;
                let winnerId = null;

                // Check scores
                Object.keys(updatedPlayers).forEach(pid => {
                    const handValue = calculateHandValue(updatedPlayers[pid].hand);
                    updatedPlayers[pid].score += handValue;
                    roundPoints[pid] = handValue;
                    scoreHistoryEntry.scores[pid] = handValue;

                    if (handValue < lowestScore) {
                        lowestScore = handValue;
                        winnerId = pid;
                    } else if (handValue === lowestScore) {
                        // In case of a tie for lowest score, we can pick the first one found or handle it differently.
                        // Standard practice varies, usually points are still added. We'll stick to first found as winner for simplicity in displaying message.
                        if (!winnerId) winnerId = pid;
                    }
                });

                const newScoreHistory = [...(gameState.scoreHistory || []), scoreHistoryEntry];
                const isGameOver = gameState.roundNumber >= 10; 

                transaction.update(gameRef, {
                    players: updatedPlayers,
                    gameStatus: isGameOver ? 'finished' : 'round-over',
                    roundEndInfo: { winnerId: winnerId, points: roundPoints, reason: 'Round Blocked' },
                    turnState: 'WAITING',
                    hasDrawn: false,
                    scoreHistory: newScoreHistory,
                    undoRequestedThisTurn: false,
                    passCount: 0
                });
            });
        } catch (error) {
            console.error("Error ending blocked round:", error);
            showMessage("Could not end the blocked round.");
        }
    }

    function calculateHandValue(hand) {
        if (!hand) return 0;
        return hand.reduce((total, domino) => {
            const topValue = domino.top === SPINNER_VALUE ? 10 : domino.top;
            const bottomValue = domino.bottom === SPINNER_VALUE ? 10 : domino.bottom;
            return total + topValue + bottomValue;
        }, 0);
    }
    
    dom.continueRoundButton.addEventListener('click', () => {
        dom.continueRoundButton.disabled = true;
        dom.continueRoundButton.textContent = "Starting...";
        startRound();
    });

    // --- UI Rendering ---
    function renderGameUI(gameState) {
        const currentTurnPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
        const currentTurnPlayer = gameState.players[currentTurnPlayerId];
        const isMyDeviceTurn = currentTurnPlayer?.controller === currentPlayerId;
        const isHost = gameState.players[currentPlayerId]?.isHost;
        if (dom.roundIndicatorLabel) {
            dom.roundIndicatorLabel.textContent = "Starting Tile";
        }
        const startingDouble = gameState.currentStartingDouble;
        dom.roundIndicator.innerHTML = `<span class="text-lg">Dbl ${startingDouble}</span> <span class="text-gray-400 text-sm">or Spinner</span>`;
        const canHostRedeal = isHost && gameState.gameStatus !== 'waiting';
        dom.reDealButton.disabled = !canHostRedeal;
        dom.reDealButton.classList.toggle('hidden', !isHost);
        
        // --- Clear old dominoes from the board that are no longer in the state ---
        const currentDominoIds = new Set(gameState.boardDominos.map(d => d.dominoData.id));
        const dominoesInDom = dom.gameBoardElement.querySelectorAll('.domino-on-board');
        dominoesInDom.forEach(dominoElement => {
            if (!currentDominoIds.has(dominoElement.dataset.id)) {
                dominoElement.remove();
            }
        });

        // Create any domino DOM elements that don't exist yet, and ensure all have fresh listeners
        gameState.boardDominos.forEach(domino => {
            const id = domino.dominoData.id;
            let el = dom.gameBoardElement.querySelector(`.domino[data-id="${id}"]`);
            
            if (!el) {
                el = createDomino(domino.dominoData);
                el.classList.add('domino-on-board');
                el.dataset.id = id;
                dom.gameBoardElement.appendChild(el);
            }

            // Only update position from state if it's not being actively rotated by the user
            if (!isRotating || draggedDominoData?.dominoData.id !== id) {
                el.style.left = `${domino.x}px`;
                el.style.top = `${domino.y}px`;
                el.style.transform = `rotate(${domino.rotation}deg)`;
            }
            
            // Re-attach event listeners to ensure the closure has the latest domino data
            const newEl = el.cloneNode(true); // Cloning is an effective way to remove all old listeners
            el.parentNode.replaceChild(newEl, el);
            
            newEl.addEventListener('mousedown', (e) => handleBoardClick(e, domino));
            // CHANGE: Add touchstart event for moving placed tiles on iPad
            newEl.addEventListener('touchstart', (e) => handleBoardTouchStart(e, domino), { passive: false });
            newEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showRotationHandles(e, domino);
            });
            addLongPressListener(newEl, domino);
            
            // Explicitly remove glow class if condition is not met
            if (gameState.turnState === 'PENDING_VALIDATION' && id === gameState.lastPlayedDominoId) {
                newEl.classList.add('pending-validation-glow');
            } else {
                newEl.classList.remove('pending-validation-glow');
            }

            const isSelected = selectedBranch.dominos.some(d => d.dominoData.id === id);
            const isAnchor = selectedBranch.anchor?.dominoData.id === id;

            newEl.classList.toggle('selected-for-branch', isSelected && !isAnchor);
            newEl.classList.toggle('anchor-domino', isAnchor);
        });
        
        updateMinimap(gameState.boardDominos);
        dom.playerHandsContainer.innerHTML = '';
        dom.scoreboard.innerHTML = '';
        renderPlayerHands(gameState);
        renderGameLog(gameState.log);
        renderDetailedScoreboard(gameState);
        gameState.playerOrder.forEach(pid => {
            renderScoreboardEntry(gameState.players[pid], pid);
        });
        const myPlayerData = gameState.players[currentPlayerId];
        if (myPlayerData) {
            dom.handValueDisplay.textContent = calculateHandValue(myPlayerData.hand);
        }
        renderBoneyard(gameState, isMyDeviceTurn);
        dom.currentPlayerElement.textContent = gameState.players[currentTurnPlayerId].name;
        updateStatusAndButtons(gameState, isMyDeviceTurn, currentTurnPlayerId);
        
        // --- Ensure theme dropdown always reflects the current game state ---
        if (dom.themeSwitcher.value !== gameState.currentTheme) {
            dom.themeSwitcher.value = gameState.currentTheme || 'classic';
        }
    }

    function updateStatusAndButtons(gameState, isMyDeviceTurn, currentTurnPlayerId) {
        let statusText = '';
        let canValidate = false;
        let canEndTurn = false;
        
        // Clear wiggle animations before re-evaluating
        dom.validateMoveButton.classList.remove('action-needed');
        dom.challengeMoveButton.classList.remove('action-needed');
        dom.endTurnButton.classList.remove('action-needed');

        // UNDO VALIDATION: Check undo request status
        const undoRequest = gameState.undoRequest || { status: 'none', type: null };
        if (undoRequest.status === 'pending') {
            const requesterName = gameState.players[undoRequest.requestingPlayerId]?.name || 'A player';
            statusText = `${requesterName} has requested an undo.`;
        }

        else if (moveBranchMode) {
            if (!selectedBranch.anchor) {
                statusText = "Move Branch: Select an anchor tile to pivot around.";
            } else {
                statusText = `Move Branch: Select adjacent tiles. Drag any selected tile to rotate.`;
            }
        } else if (isMyDeviceTurn) {
            switch(gameState.turnState) {
                case 'PENDING_VALIDATION':
                    statusText = "Waiting for other players to validate your move...";
                    canEndTurn = false;
                    break;
                case 'PLACED':
                    statusText = "You've played. Adjust your tile or end your turn.";
                    dom.endTurnButton.classList.add('action-needed');
                    canEndTurn = true;
                    break;
                case 'WAITING':
                default:
                    if(gameState.mustDrawToStart) {
                        statusText = "You must draw to start the round.";
                    } else if(gameState.hasDrawn){
                        statusText = "You have drawn. Play a tile or pass your turn.";
                        dom.endTurnButton.classList.add('action-needed');
                        canEndTurn = true;
                    } else if (gameState.boardDominos.length === 0) {
                        statusText = `You must play the Double ${gameState.currentStartingDouble} or Double Spinner.`;
                    } else {
                        statusText = "Your turn. Play a domino or draw from the boneyard.";
                    }
                    break;
            }
        } else { // Not my turn
            if (undoRequest.status !== 'pending') { // Don't overwrite undo message
                statusText = `Waiting for ${gameState.players[currentTurnPlayerId].name}...`;
                if (gameState.turnState === 'PENDING_VALIDATION') {
                    statusText = `Validate ${gameState.players[currentTurnPlayerId].name}'s move.`;
                    canValidate = true;
                }
            }
        }

        if (!isDraggingDomino && !selectedBranch.isDraggingBranch && !isRotating) {
            dom.gameStatusElement.textContent = statusText;
        }

        dom.endTurnButton.disabled = !canEndTurn;

        const canManipulatePlayedTile = isMyDeviceTurn && gameState.turnState === 'PLACED' && gameState.lastPlayedDominoId;
        
        // Undo Draw Logic
        const canRequestUndoDraw = isMyDeviceTurn && gameState.hasDrawn && gameState.turnState === 'WAITING' && undoRequest.status === 'none' && !gameState.undoRequestedThisTurn;
        const isMyDrawUndoPending = undoRequest.status === 'pending' && undoRequest.type === 'draw' && undoRequest.requestingPlayerId === currentTurnPlayerId;
        dom.undoDrawButton.classList.toggle('hidden', !canRequestUndoDraw && !isMyDrawUndoPending);
        dom.undoDrawButton.disabled = false;
        if(isMyDrawUndoPending){
            dom.undoDrawButton.textContent = 'Cancel Undo';
             dom.undoDrawButton.classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'text-black');
             dom.undoDrawButton.classList.add('bg-gray-500', 'hover:bg-gray-600', 'text-white');
        } else {
             dom.undoDrawButton.textContent = 'Undo Draw';
             dom.undoDrawButton.classList.remove('bg-gray-500', 'hover:bg-gray-600', 'text-white');
             dom.undoDrawButton.classList.add('bg-yellow-600', 'hover:bg-yellow-700', 'text-black');
        }

        
        // Undo Move Logic
        const canRequestUndoMove = isMyDeviceTurn && gameState.turnState === 'PLACED' && undoRequest.status === 'none' && !gameState.undoRequestedThisTurn;
        const isMyMoveUndoPending = undoRequest.status === 'pending' && undoRequest.type === 'play' && undoRequest.requestingPlayerId === currentTurnPlayerId;
        dom.undoMoveButton.classList.toggle('hidden', !canRequestUndoMove && !isMyMoveUndoPending);
        dom.undoMoveButton.disabled = false;
        if (isMyMoveUndoPending) {
             dom.undoMoveButton.textContent = 'Cancel Undo';
             dom.undoMoveButton.classList.remove('bg-orange-500', 'hover:bg-orange-600');
             dom.undoMoveButton.classList.add('bg-gray-500', 'hover:bg-gray-600');
        } else {
            dom.undoMoveButton.textContent = 'Undo Move';
            dom.undoMoveButton.classList.remove('bg-gray-500', 'hover:bg-gray-600');
            dom.undoMoveButton.classList.add('bg-orange-500', 'hover:bg-orange-600');
        }


        dom.moveBranchButton.disabled = !canManipulatePlayedTile;

        dom.validateMoveButton.disabled = !canValidate;
        dom.challengeMoveButton.disabled = !canValidate;
        dom.validateMoveButton.classList.toggle('action-needed', canValidate);
        dom.challengeMoveButton.classList.toggle('action-needed', canValidate);

        const canDraw = isMyDeviceTurn && gameState.turnState === 'WAITING' && !gameState.hasDrawn; // Note: removed boneyard length check here to allow triggering blocked state
        dom.boneyardPileElement.style.cursor = canDraw ? 'pointer' : 'not-allowed';
        dom.boneyardPileElement.classList.toggle('can-draw', canDraw && gameState.boneyard.length > 0);
    }

    function renderPlayerHands(gameState) {
        const playerOrder = gameState.playerOrder;
        const currentTurnPlayerId = playerOrder[gameState.currentPlayerIndex];
        const currentTurnPlayer = gameState.players[currentTurnPlayerId];
        const isMyDeviceTurn = currentTurnPlayer?.controller === currentPlayerId;
        const isTurnPendingConfirmation = gameState.turnConfirmationPending;
        const isDeviceControllingMultiple = gameState.playerOrder.filter(pid => gameState.players[pid].controller === currentPlayerId).length > 1;
        playerOrder.forEach(playerId => {
            const playerData = gameState.players[playerId];
            if (!playerData) return;
            const isThisPlayerTheActiveTurn = playerId === currentTurnPlayerId;
            const section = document.createElement('div');
            section.className = 'player-hand-section';
            if (isThisPlayerTheActiveTurn) {
                section.classList.add('flashing-border');
            }
            const title = document.createElement('h3');
            title.className = 'font-bold text-center mb-2 text-sm';
            let nameTag = '';
            if (playerData.controller === currentPlayerId && playerId !== currentPlayerId) {
                nameTag = '(Local)';
            } else if (playerId === currentPlayerId) {
                nameTag = '(You)';
            } else if (playerData.isHost) {
                 nameTag = '(Host)';
            }
            title.textContent = `${playerData.name} ${nameTag} (${playerData.hand.length})`;
            const handDiv = document.createElement('div');
            handDiv.className = 'player-hand-content';
            let showHandFaceUp = false;
            if (isDeviceControllingMultiple) {
                const isControlledByMyDevice = playerData.controller === currentPlayerId;
                if (isControlledByMyDevice && isThisPlayerTheActiveTurn && !isTurnPendingConfirmation) {
                    showHandFaceUp = true;
                }
            } else {
                if (playerId === currentPlayerId) {
                    showHandFaceUp = true;
                }
            }
            if (showHandFaceUp) {
                playerData.hand.forEach(dominoData => {
                    const dominoElement = createDomino(dominoData);
                    dominoElement.dataset.id = dominoData.id;
                    const canDrag = isThisPlayerTheActiveTurn && playerData.controller === currentPlayerId && gameState.turnState === 'WAITING' && !moveBranchMode && !gameState.mustDrawToStart;
                    
                    if (canDrag) {
                        dominoElement.addEventListener('mousedown', (e) => startRegularDominoDrag(e, { dominoData }, 'hand'));
                        dominoElement.addEventListener('touchstart', (e) => startRegularDominoDrag(e, { dominoData }, 'hand'), { passive: false });
                    } else {
                        dominoElement.style.cursor = 'not-allowed';
                    }
                    handDiv.appendChild(dominoElement);
                });
            } else {
                playerData.hand.forEach(() => {
                    const dominoElement = createDomino(null, true, 'mini');
                    handDiv.appendChild(dominoElement);
                });
            }
            section.appendChild(title);
            section.appendChild(handDiv);
            dom.playerHandsContainer.appendChild(section);
        });
    }

    function renderScoreboardEntry(playerData, playerId) {
        if (!playerData) return;
        const scoreEntry = document.createElement('p');
        scoreEntry.textContent = `${playerData.name}: ${playerData.score}`;
        dom.scoreboard.appendChild(scoreEntry);
    }
    
    // CHANGE: Add colored names to game log
    function renderGameLog(log) {
        if (!log) return;
        dom.gameLog.innerHTML = '';
        const players = localGameState.players || {};

        log.forEach(entry => {
            let coloredEntry = entry;
            // Loop through players to find and color their names
            for (const pid in players) {
                const player = players[pid];
                // Use a RegExp to replace the name, ensuring it's a whole word to avoid partial matches
                const nameRegex = new RegExp(`\\b${player.name}\\b`, 'g');
                coloredEntry = coloredEntry.replace(nameRegex, `<span style="color: ${player.color}; font-weight: 600;">${player.name}</span>`);
            }
            const p = document.createElement('p');
            p.innerHTML = coloredEntry; // Use innerHTML to render the span
            dom.gameLog.appendChild(p);
        });
        dom.gameLog.scrollTop = dom.gameLog.scrollHeight;
    }

    function renderBoneyard(gameState, isMyDeviceTurn) {
        dom.boneyardStack.innerHTML = '';
        if (gameState.boneyard.length > 0) {
            const dominoDisplay = document.createElement('div');
            dominoDisplay.className = 'boneyard-domino-display';
            dom.boneyardStack.appendChild(dominoDisplay);
        }
        const existingMessage = document.getElementById('boneyard-message');
        if (existingMessage) existingMessage.remove();
        if (isMyDeviceTurn && gameState.turnState === 'WAITING' && !gameState.hasDrawn && gameState.boneyard.length > 0) {
            const message = document.createElement('div');
            message.id = 'boneyard-message';
            message.textContent = 'Click to Draw';
            dom.boneyardPileElement.appendChild(message);
        }
        dom.boneyardCountElement.textContent = gameState.boneyard.length;
    }
    
    function displayRoundEndScreen(gameState) {
        if (!gameState.roundEndInfo) return;
        if (gameState.gameStatus === 'finished') {
            showFinalScores(gameState);
            return;
        }
        dom.roundEndScreen.classList.remove('hidden');
        const { winnerId, points, reason } = gameState.roundEndInfo;
        dom.roundEndTitle.textContent = `Round ${gameState.roundNumber} Over!`;
        
        if (reason === 'Round Blocked') {
             dom.roundWinnerMessage.textContent = `Round Blocked! ${gameState.players[winnerId].name} wins with the lowest score.`;
        } else {
             dom.roundWinnerMessage.textContent = `${gameState.players[winnerId].name} wins the round!`;
        }

        dom.roundResultsList.innerHTML = '';
        gameState.playerOrder.forEach(pid => {
            const p = document.createElement('p');
            const oldScore = gameState.players[pid].score - (points[pid] || 0);
            p.textContent = `${gameState.players[pid].name}: ${oldScore} + ${points[pid] || 0} points = ${gameState.players[pid].score} Total`;
            if (pid === winnerId) p.classList.add('winner');
            dom.roundResultsList.appendChild(p);
        });
        dom.continueRoundButton.disabled = false;
        dom.continueRoundButton.textContent = "Start Next Round";
    }

    function showFinalScores(gameState) {
        dom.roundEndScreen.classList.add('hidden');
        dom.gameOverScreen.classList.remove('hidden');
        const finalScores = gameState.playerOrder.map(pid => ({
            name: gameState.players[pid].name,
            score: gameState.players[pid].score
        })).sort((a, b) => a.score - b.score);
        const winnerScore = finalScores[0].score;
        const winners = finalScores.filter(p => p.score === winnerScore);
        if (winners.length > 1) {
            dom.finalWinnerMessage.textContent = `It's a tie between ${winners.map(w => w.name).join(' and ')}!`;
        } else {
            dom.finalWinnerMessage.textContent = `${winners[0].name} wins the game!`;
        }
        
        dom.finalWinnerMessage.classList.add('winner-animation');

        dom.finalScoreList.innerHTML = '';

        const { scoreHistory, players, playerOrder } = gameState;
        if (scoreHistory && scoreHistory.length > 0) {
            const table = document.createElement('table');
            table.id = 'detailed-scoreboard-table'; // Reuse existing styles
            table.style.width = '100%';
            table.style.margin = '0 auto';

            const thead = table.createTHead();
            const headerRow = thead.insertRow();
            const roundHeader = document.createElement('th');
            roundHeader.textContent = 'R';
            headerRow.appendChild(roundHeader);
            playerOrder.forEach(pid => {
                const th = document.createElement('th');
                th.textContent = players[pid].name.substring(0, 3);
                headerRow.appendChild(th);
            });

            const tbody = table.createTBody();
            scoreHistory.forEach(roundData => {
                const row = tbody.insertRow();
                row.insertCell().textContent = roundData.round;
                playerOrder.forEach(pid => {
                    row.insertCell().textContent = roundData.scores[pid] ?? '0';
                });
            });

            const tfoot = table.createTFoot();
            const totalRow = tfoot.insertRow();
            totalRow.className = 'total-row';
            totalRow.insertCell().textContent = 'Total';
            playerOrder.forEach(pid => {
                const cell = totalRow.insertCell();
                cell.textContent = players[pid].score;
            });
            dom.finalScoreList.appendChild(table);
        }
    }

    function createDomino(dominoData, isBack = false, size = 'normal') {
        const dominoElement = document.createElement('div');
        dominoElement.className = 'domino';
        if (size === 'mini') {
            dominoElement.classList.add('mini-domino');
        }
        if (isBack) {
            dominoElement.classList.add('domino-back');
            return dominoElement;
        }
        dominoElement.appendChild(createPipContainer(dominoData.top, size));
        dominoElement.appendChild(document.createElement('div')).className = 'divider';
        dominoElement.appendChild(createPipContainer(dominoData.bottom, size));
        return dominoElement;
    }
    
    function createPipContainer(count, size = 'normal') {
        const container = document.createElement('div');
        container.className = 'pip-container';
        if (count === SPINNER_VALUE) {
            const iconContainer = document.createElement('div');
            iconContainer.className = 'spinner-icon';
            const theme = localGameState.currentTheme || 'classic';
            switch (theme) {
                case 'classic':
                    iconContainer.innerHTML = `<svg viewBox="0 0 24 24" class="w-full h-full"><g stroke="#B91C1C" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M 12 12 L 12 4 L 6 4" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(60 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(120 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(180 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(240 12 12)" /><path d="M 12 12 L 12 4 L 6 4" transform="rotate(300 12 12)" /></g></svg>`;
                    break;
                case 'dr_edell': iconContainer.innerHTML = '<div></div><div></div>'; break;
                case 'austin': iconContainer.innerHTML = `<svg viewBox="0 0 24 24" class="w-full h-full"><path fill="#FFDE00" d="M12,2C6.48,2,2,6.48,2,12s4.48,10,10,10s10-4.48,10-10S17.52,2,12,2z"/><path fill="#000000" d="M8.5,10.5c0.83,0,1.5-0.67,1.5-1.5S9.33,7.5,8.5,7.5S7,8.17,7,9S7.67,10.5,8.5,10.5z M15.5,10.5c0.83,0,1.5-0.67,1.5-1.5S16.33,7.5,15.5,7.5S14,8.17,14,9S14.67,10.5,15.5,10.5z"/><path fill="#D9534F" d="M18,14c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S19.1,14,18,14z M6,14c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S7.1,14,6,14z"/><path fill="#000000" d="M12,15c-1.66,0-3-1.34-3-3h1c0,1.1,0.9,2,2,2s2-0.9,2-2h1C15,13.66,13.66,15,12,15z"/></svg>`; break;
                case 'rose': iconContainer.innerHTML = '<div></div><div></div>'; break;
                case 'anna': iconContainer.innerHTML = `<svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="300pt" height="155pt" viewBox="0 0 300 155" preserveAspectRatio="xMidYMid meet"><g transform="translate(0,155) scale(0.1,-0.1)" fill="red" stroke="red"><path d="M599 1217 c-92 -35 -157 -104 -182 -194 -7 -29 -17 -43 -28 -43 -26 0 -69 -39 -69 -64 0 -28 33 -64 65 -72 19 -5 28 -19 45 -68 42 -126 159 -271 285 -351 28 -18 83 -49 122 -69 l73 -36 87 44 c206 103 340 248 402 433 12 34 21 82 21 107 l0 45 45 7 c25 3 61 3 80 0 34 -7 35 -8 35 -52 0 -24 9 -73 21 -107 62 -185 196 -330 402 -433 l87 -44 81 41 c204 102 350 256 404 426 13 39 23 53 41 57 32 8 64 45 64 72 0 25 -43 64 -71 64 -11 0 -19 7 -19 18 0 29 -49 124 -80 153 -16 15 -48 38 -72 51 -87 46 -253 24 -324 -43 l-22 -21 -43 31 c-73 54 -177 74 -259 51 -84 -23 -167 -101 -185 -173 -6 -23 -9 -24 -43 -15 -20 6 -64 7 -97 4 l-60 -6 -24 51 c-73 152 -283 195 -430 88 l-43 -31 -22 21 c-60 56 -211 86 -287 58z m205 -42 c18 -8 38 -21 45 -29 7 -9 17 -13 22 -10 5 3 9 1 9 -4 0 -21 40 -19 71 4 35 26 113 52 177 58 43 5 125 -19 158 -47 25 -20 49 -47 48 -55 0 -10 15 -28 58 -73 31 -32 35 -39 23 -49 -8 -7 -15 -19 -15 -26 0 -8 -3 -14 -7 -14 -5 0 -9 -23 -11 -51 -1 -28 -9 -64 -17 -80 -8 -15 -15 -34 -15 -42 0 -8 -7 -20 -15 -27 -8 -7 -15 -21 -15 -31 0 -11 -3 -19 -8 -19 -4 0 -16 -17 -27 -37 -23 -43 -122 -143 -180 -181 -22 -15 -74 -45 -116 -66 l-77 -39 -58 29 c-33 15 -62 27 -66 26 -5 -1 -8 2 -8 8 0 5 -6 10 -13 10 -8 0 -22 9 -32 20 -10 11 -23 20 -29 20 -7 0 -19 8 -27 18 -8 9 -38 38 -65 63 -43 40 -109 125 -107 139 0 3 -8 16 -18 29 -10 12 -21 38 -25 56 -3 18 -14 42 -25 54 -10 11 -19 25 -19 31 0 5 -6 10 -12 10 -7 0 -21 11 -31 25 -17 24 -17 24 21 54 25 21 42 45 51 75 16 55 75 121 135 150 38 18 59 22 117 18 39 -2 85 -10 103 -17z m1211 -19 c63 -38 95 -45 114 -22 16 19 100 58 111 51 5 -3 11 -2 14 3 5 8 104 8 136 0 44 -11 144 -93 134 -110 -3 -4 -1 -8 4 -8 5 0 15 -19 23 -42 7 -24 31 -60 51 -80 l38 -37 -31 -30 c-17 -17 -35 -31 -40 -31 -5 0 -12 -12 -15 -27 -12 -51 -54 -133 -96 -190 -58 -79 -71 -93 -85 -93 -7 0 -12 -5 -10 -10 1 -6 -11 -18 -27 -28 -16 -9 -40 -26 -53 -37 -50 -43 -162 -100 -193 -99 -18 1 -50 12 -70 25 -8 5 -26 14 -39 19 -99 43 -264 205 -312 308 -44 93 -46 98 -58 177 -7 46 -16 74 -28 83 -15 11 -16 14 -3 22 8 5 17 7 21 5 3 -3 12 7 19 20 7 14 17 25 22 25 4 0 8 6 8 14 0 13 41 60 88 100 26 22 81 32 162 29 44 -1 68 -9 115 -37z"/><path d="M631 1138 c-74 -21 -118 -73 -140 -165 -16 -67 -4 -127 47 -232 56 -114 164 -217 315 -300 l57 -32 48 27 c26 15 56 32 67 38 195 107 340 346 304 501 -16 69 -33 100 -71 128 -82 59 -192 55 -268 -11 -38 -32 -77 -99 -65 -111 3 -3 8 5 12 17 3 12 9 22 13 22 4 0 11 11 14 25 4 14 13 25 21 25 8 0 15 4 15 9 0 18 86 51 134 51 69 0 117 -27 148 -85 51 -95 48 -184 -9 -291 -20 -38 -41 -74 -47 -80 -6 -7 -33 -37 -61 -68 -27 -31 -55 -56 -62 -56 -7 0 -18 -9 -25 -20 -7 -11 -16 -20 -21 -20 -4 0 -31 -16 -61 -36 -50 -33 -92 -41 -112 -21 -4 4 -14 7 -21 7 -8 0 -34 14 -58 30 -24 17 -48 30 -54 30 -6 0 -18 11 -27 25 -9 14 -20 25 -25 25 -36 0 -190 225 -173 252 4 6 3 8 -3 5 -11 -7 -23 45 -23 104 0 70 50 150 116 185 25 13 132 13 154 0 50 -30 95 -75 110 -110 12 -27 19 -34 19 -21 2 51 -76 129 -151 152 -50 15 -70 15 -117 1z"/><path d="M1820 1141 c-89 -27 -126 -69 -150 -168 -34 -147 92 -363 285 -486 130 -82 125 -81 189 -47 154 81 259 180 320 305 64 127 65 234 5 321 -68 99 -214 106 -312 15 -31 -28 -57 -72 -57 -93 1 -7 8 1 17 17 23 44 101 115 126 116 12 0 41 2 63 5 112 15 208 -113 188 -247 -6 -40 -58 -167 -74 -179 -3 -3 -16 -21 -28 -40 -11 -19 -34 -47 -50 -62 -23 -21 -32 -24 -43 -15 -11 10 -11 9 -2 -3 10 -13 -3 -25 -70 -73 -45 -31 -90 -57 -99 -57 -9 0 -19 -4 -23 -9 -6 -10 -158 65 -163 80 -2 5 -8 7 -13 3 -5 -3 -12 2 -15 10 -3 9 -11 16 -18 16 -38 0 -206 231 -192 266 3 8 1 14 -5 14 -6 0 -9 7 -5 15 3 8 1 15 -4 15 -14 0 -12 83 3 132 6 22 30 61 52 85 38 43 43 45 106 50 49 4 73 1 97 -11 42 -22 86 -66 108 -107 9 -19 19 -29 21 -22 14 40 -72 125 -149 148 -56 16 -70 17 -108 6z"/></g></svg>`; break;
                case 'kate': iconContainer.innerHTML = `<svg viewBox="0 0 100 100" class="w-full h-full"><rect x="10" y="25" width="80" height="50" rx="10" ry="10" fill="#F0C68C"/><path d="M 20 25 C 10 15, 10 5, 25 5 L 35 5 L 30 25 Z" fill="#6B4F4F"/><path d="M 80 25 C 90 15, 90 5, 75 5 L 65 5 L 70 25 Z" fill="#6B4F4F"/><circle cx="40" cy="45" r="5" fill="#2D2D2D"/><circle cx="60" cy="45" r="5" fill="#2D2D2D"/><path d="M 50 55 Q 45 60, 50 65 Q 55 60, 50 55 Z" fill="#2D2D2D"/><path d="M 35 70 C 40 65, 60 65, 65 70" stroke="#2D2D2D" stroke-width="3" fill="none"/><path d="M 30 35 Q 40 30, 50 35 Q 60 30, 70 35" stroke="#6B4F4F" stroke-width="2" fill="none"/></svg>`; break;
                default: iconContainer.textContent = 'S';
            }
            container.appendChild(iconContainer);
            return container;
        }
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute('viewBox', '0 0 40 40');
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svg.style.width = '100%';
        svg.style.height = '100%';
        const pipPositions = {
            1: [[20, 20]],
            2: [[10, 30], [30, 10]],
            3: [[10, 30], [20, 20], [30, 10]],
            4: [[10, 10], [30, 10], [10, 30], [30, 30]],
            5: [[10, 10], [30, 10], [20, 20], [10, 30], [30, 30]],
            6: [[10, 10], [20, 10], [30, 10], [10, 30], [20, 30], [30, 30]],
            7: [[10, 10], [20, 10], [30, 10], [20, 20], [10, 30], [20, 30], [30, 30]],
            8: [[10, 10], [20, 10], [30, 10], [10, 20], [30, 20], [10, 30], [20, 30], [30, 30]],
            9: [[10, 10], [20, 10], [30, 10], [10, 20], [20, 20], [30, 20], [10, 30], [20, 30], [30, 30]]
        };
        if (pipPositions[count]) {
            pipPositions[count].forEach(([cx, cy]) => {
                const circle = document.createElementNS(svgNS, "circle");
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', 4.5);
                if (count >= 0 && count <= 9) {
                    circle.setAttribute('fill', `url(#pipGradient-${count})`);
                } else {
                    circle.setAttribute('fill', '#000000'); // Fallback
                }
                svg.appendChild(circle);
            });
        }
        container.appendChild(svg);
        return container;
    }

    // --- Touch, Drag, Drop, and Rotation Logic ---
    function getEventCoords(e) {
        return e.touches?.[0] || e.changedTouches?.[0] || e;
    }

    // CHANGE: Add a separate handler for touchstart on board tiles to prevent default browser actions
    function handleBoardTouchStart(e, domino) {
        e.preventDefault(); // Prevent scrolling/zooming on iPad when interacting with a tile
        handleBoardClick(e, domino);
    }

    function handleBoardClick(e, domino) {
        if (isDraggingDomino || isRotating) return;
        
        // If in branch mode, handle selection/drag
        if (moveBranchMode) {
            const isSelected = selectedBranch.dominos.some(d => d.dominoData.id === domino.dominoData.id);
            if (isSelected && selectedBranch.anchor) {
                startBranchDrag(e, domino);
            } else {
                handleBranchSelection(e, domino);
            }
            return;
        }

        const currentTurnPlayer = localGameState.players[localGameState.playerOrder[localGameState.currentPlayerIndex]];
        const isMyDeviceTurn = currentTurnPlayer.controller === currentPlayerId;
        const canInteractWithTile = isMyDeviceTurn && localGameState.turnState === 'PLACED' && domino.dominoData.id === localGameState.lastPlayedDominoId;

        // If it's the last played tile on your turn...
        if (canInteractWithTile) {
            // A left-click (or tap) will start a drag. A short tap will be handled in endDominoDrag.
            startRegularDominoDrag(e, domino, 'board');
        }
    }

    function startRegularDominoDrag(e, dominoObject, origin) {
        e.stopPropagation();
        if (isDraggingDomino) return;

        const currentTurnPlayer = localGameState.players[localGameState.playerOrder[localGameState.currentPlayerIndex]];
        const isMyDeviceTurn = currentTurnPlayer.controller === currentPlayerId;

        // Check if the tile is allowed to be dragged
        if (origin === 'board') {
            const canMoveTile = isMyDeviceTurn && localGameState.turnState === 'PLACED' && dominoObject.dominoData.id === localGameState.lastPlayedDominoId;
            if (!canMoveTile) {
                return; // Prevent dragging any tile except the last one played on your turn
            }
        } else { // origin === 'hand'
            if (!isMyDeviceTurn || localGameState.turnState !== 'WAITING') {
                showMessage("You can only play a tile when it is your turn to play.");
                return;
            }
            if (localGameState.mustDrawToStart) {
                showMessage("You must draw a tile to start your turn.");
                return;
            }
        }

        originalDominoElement = e.currentTarget;
        draggedDominoData = dominoObject;
        isDraggingDomino = true;
        wasDragged = false;
        dragStartTime = Date.now();
        const coords = getEventCoords(e);
        dragStartPos = { x: coords.clientX, y: coords.clientY };
        activeDominoElement = createDomino(draggedDominoData.dominoData);
        activeDominoElement.classList.add('dragging');
        document.body.appendChild(activeDominoElement);
        originalDominoElement.style.opacity = '0.3';
        const initialLeft = coords.clientX - (DOMINO_WIDTH / 2);
        const initialTop = coords.clientY - (DOMINO_HEIGHT / 2);
        const currentRotation = draggedDominoData.rotation || 0;
        activeDominoElement.style.transform = `translate3d(${initialLeft}px, ${initialTop}px, 0) scale(${zoomLevel}) rotate(${currentRotation}deg)`;
        dom.gameStatusElement.textContent = `Moving a tile...`;
        const moveHandler = (ev) => dragDomino(ev);
        const endHandler = (ev) => endDominoDrag(ev, origin, moveHandler, endHandler);
        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endHandler, { once: true });
        document.addEventListener('touchmove', moveHandler, { passive: false });
        document.addEventListener('touchend', endHandler, { once: true });
    }

    function dragDomino(e) {
        if (!isDraggingDomino || !activeDominoElement) return;
        e.preventDefault();
        const coords = getEventCoords(e);
        if (Math.abs(coords.clientX - dragStartPos.x) > 10 || Math.abs(coords.clientY - dragStartPos.y) > 10) {
            wasDragged = true;
        }

        const newLeft = coords.clientX - (DOMINO_WIDTH / 2);
        const newTop = coords.clientY - (DOMINO_HEIGHT / 2);
        const currentRotation = draggedDominoData.rotation || 0;
        activeDominoElement.style.transform = `translate3d(${newLeft}px, ${newTop}px, 0) scale(${zoomLevel}) rotate(${currentRotation}deg)`;
    }

    // NEW: Check proximity before placing a domino
    function isPlacementValid(newDomino, allDominos) {
        // If the board is empty, the only valid placement is the first move.
        if (allDominos.length === 0) {
            return true; 
        }

        const newCenter = {
            x: newDomino.x + DOMINO_WIDTH / 2,
            y: newDomino.y + DOMINO_HEIGHT / 2
        };

        // Check if it's close to any existing domino
        for (const existingDomino of allDominos) {
            const existingCenter = {
                x: existingDomino.x + DOMINO_WIDTH / 2,
                y: existingDomino.y + DOMINO_HEIGHT / 2
            };
            const dx = newCenter.x - existingCenter.x;
            const dy = newCenter.y - existingCenter.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < PLACEMENT_PROXIMITY_THRESHOLD) {
                return true; // Found a domino nearby
            }
        }
        return false; // No dominoes were close enough
    }

    async function endDominoDrag(e, origin, moveHandler, endHandler) {
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('touchmove', moveHandler);

        if (!isDraggingDomino) return;

        const gameRef = doc(db, "games", currentGameId);
        const dragDuration = Date.now() - dragStartTime;
        const isTap = !wasDragged && dragDuration < 300; 

        try {
            if (isTap && origin === 'board') {
                showRotationHandles(e, draggedDominoData);
            } else if (wasDragged || (isTap && origin === 'hand')) {
                let newX, newY, newRotation;
                
                const coords = getEventCoords(e);
                const worldRect = dom.worldElement.getBoundingClientRect();
                if (origin === 'hand' && (coords.clientX < worldRect.left || coords.clientX > worldRect.right || coords.clientY < worldRect.top || coords.clientY > worldRect.bottom)) {
                    throw new Error("Cancelled drag"); // Just cleanup, don't show message
                }
                const cursorX_onBoard = (coords.clientX - worldRect.left) / zoomLevel + boardPosition.x;
                const cursorY_onBoard = (coords.clientY - worldRect.top) / zoomLevel + boardPosition.y;
                newX = cursorX_onBoard - (DOMINO_WIDTH / 2);
                newY = cursorY_onBoard - (DOMINO_HEIGHT / 2);
                newRotation = draggedDominoData.rotation || 0;
                
                let isValidPlacement = true;
                if (localGameState.boardDominos.length === 0 && origin === 'hand') {
                    const d = draggedDominoData.dominoData;
                    const required = localGameState.currentStartingDouble;
                    const isCorrectDouble = d.top === required && d.bottom === required;
                    const isDoubleSpinner = d.top === SPINNER_VALUE && d.bottom === SPINNER_VALUE;
                    if (!isCorrectDouble && !isDoubleSpinner) {
                        isValidPlacement = false;
                        showMessage(`Must start with Double ${required} or Double Spinner!`);
                    } else {
                        newX = (BOARD_SIZE / 2) - (DOMINO_WIDTH / 2);
                        newY = (BOARD_SIZE / 2) - (DOMINO_HEIGHT / 2);
                        newRotation = 90;
                    }
                } else {
                    // PROXIMITY CHECK: Validate placement for non-first moves, and for repositioning
                    let boardForProximityCheck = localGameState.boardDominos;
                    if (origin === 'board') {
                        boardForProximityCheck = localGameState.boardDominos.filter(d => d.dominoData.id !== draggedDominoData.dominoData.id);
                    }
                    const tempDomino = { x: newX, y: newY };
                    if (boardForProximityCheck.length > 0 && !isPlacementValid(tempDomino, boardForProximityCheck)) {
                        isValidPlacement = false;
                        showMessage("You must place dominoes next to existing ones.");
                    }
                }


                if (isValidPlacement) {
                    await runTransaction(db, async (transaction) => {
                        const gameSnap = await transaction.get(gameRef);
                        if (!gameSnap.exists()) throw "Game does not exist!";
                        const gameState = gameSnap.data();
                        const currentTurnPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
                        const currentTurnPlayer = gameState.players[currentTurnPlayerId];
                        
                        if (origin === 'hand') {
                            const newHand = gameState.players[currentTurnPlayerId].hand.filter(d => d.id !== draggedDominoData.dominoData.id);
                            if (newHand.length === gameState.players[currentTurnPlayerId].hand.length) {
                                throw new Error("Domino to be played not found in player's hand.");
                            }
                            const playedDomino = draggedDominoData.dominoData;
                            const newBoardDominos = [...gameState.boardDominos, { dominoData: playedDomino, x: newX, y: newY, rotation: newRotation, playerId: currentTurnPlayerId }];
                            const newLog = [...(gameState.log || []), `${currentTurnPlayer.name} played a tile.`];
                            if (newLog.length > 5) newLog.shift();
                            const newMoveHistory = [{ type: 'play', dominoId: playedDomino.id }];

                            transaction.update(gameRef, {
                                boardDominos: newBoardDominos,
                                [`players.${currentTurnPlayerId}.hand`]: newHand,
                                turnState: 'PLACED',
                                moveHistory: newMoveHistory,
                                lastPlayedDominoId: playedDomino.id,
                                log: newLog,
                                passCount: 0 // Reset pass count on a successful play
                            });
                        } else { // origin === 'board'
                            const newBoardDominos = gameState.boardDominos.map(d => 
                                (d.dominoData.id === draggedDominoData.dominoData.id) 
                                ? { ...d, x: newX, y: newY, rotation: newRotation } 
                                : d
                            );
                            const newMoveHistory = [...(gameState.moveHistory || []), { type: 'reposition', dominoId: draggedDominoData.dominoData.id, from: { x: draggedDominoData.x, y: draggedDominoData.y, rotation: draggedDominoData.rotation } }];
                            transaction.update(gameRef, { boardDominos: newBoardDominos, moveHistory: newMoveHistory });
                        }
                    });
                }
            }
        } catch (error) {
            if (error.message !== "Cancelled drag") {
                console.error("Error during domino placement transaction:", error);
                showMessage("Error placing domino. Please try again.");
            }
        } finally {
            if (activeDominoElement) activeDominoElement.remove();
            if (originalDominoElement) originalDominoElement.style.opacity = '1';
            activeDominoElement = null;
            originalDominoElement = null;
            draggedDominoData = null;
            isDraggingDomino = false; 
            wasDragged = false;
        }
    }

    // --- Pan and Zoom Logic ---
    function centerBoardOnStart() {
        const worldWidth = dom.worldElement.clientWidth;
        const worldHeight = dom.worldElement.clientHeight;
        zoomLevel = 1.0;
        boardPosition.x = (BOARD_SIZE / 2) - (worldWidth / 2 / zoomLevel);
        boardPosition.y = (BOARD_SIZE / 2) - (worldHeight / 2 / zoomLevel);
        updateBoardTransform();
    }

    function updateBoardTransform() {
        const viewWidth = dom.worldElement.clientWidth / zoomLevel;
        const viewHeight = dom.worldElement.clientHeight / zoomLevel;
        boardPosition.x = Math.max(0, Math.min(boardPosition.x, BOARD_SIZE - viewWidth));
        boardPosition.y = Math.max(0, Math.min(boardPosition.y, BOARD_SIZE - viewHeight));
        dom.gameBoardElement.style.transform = `scale(${zoomLevel}) translate(${-boardPosition.x}px, ${-boardPosition.y}px)`;
        updateMinimap(localGameState.boardDominos || []);
    }
    
    // NEW: Function to pan/zoom to a specific domino
    function focusOnDomino(domino) {
        // Give the UI a moment to render the domino if it's new
        setTimeout(() => {
            const viewWidth = dom.worldElement.clientWidth / zoomLevel;
            const viewHeight = dom.worldElement.clientHeight / zoomLevel;
    
            boardPosition.x = domino.x - (viewWidth / 2) + (DOMINO_WIDTH / 2);
            boardPosition.y = domino.y - (viewHeight / 2) + (DOMINO_HEIGHT / 2);
    
            updateBoardTransform();
        }, 100); // A small delay
    }
    
    function updateMinimap(boardDominos) {
        if (!dom.minimapContainer) return;
        const mapSize = dom.minimapContainer.clientWidth;
        const scale = mapSize / BOARD_SIZE;
        const viewWidth = dom.worldElement.clientWidth / zoomLevel;
        const viewHeight = dom.worldElement.clientHeight / zoomLevel;
        dom.minimapViewport.style.width = `${viewWidth * scale}px`;
        dom.minimapViewport.style.height = `${viewHeight * scale}px`;
        dom.minimapViewport.style.left = `${boardPosition.x * scale}px`;
        dom.minimapViewport.style.top = `${boardPosition.y * scale}px`;
        dom.minimapContainer.querySelectorAll('.minimap-dot').forEach(dot => dot.remove());
        if (!boardDominos) return;
        boardDominos.forEach(domino => {
            const dot = document.createElement('div');
            dot.className = 'minimap-dot';
            dot.style.left = `${(domino.x + DOMINO_WIDTH / 2) * scale}px`;
            dot.style.top = `${(domino.y + DOMINO_HEIGHT / 2) * scale}px`;
            dot.style.transform = `translate(-50%, -50%) rotate(${domino.rotation}deg)`;
            dot.addEventListener('click', (e) => {
                e.stopPropagation();
                boardPosition.x = domino.x - (viewWidth / 2) + (DOMINO_WIDTH / 2);
                boardPosition.y = domino.y - (viewHeight / 2) + (DOMINO_HEIGHT / 2);
                updateBoardTransform();
            });
            dom.minimapContainer.appendChild(dot);
        });
    }
    
    dom.worldElement.addEventListener('mousedown', (e) => {
        if (e.button !== 0 || isDraggingDomino || moveBranchMode) return;
        if (e.target !== dom.worldElement && e.target !== dom.gameBoardElement && e.target.id !== 'world-wrapper') return;
        isPanning = true;
        dom.worldElement.classList.add('panning');
        const coords = getEventCoords(e);
        panStart = { x: coords.clientX, y: coords.clientY };
        const panMove = (ev) => pan(ev);
        const endPanMove = () => endPan(panMove, endPanMove);
        document.addEventListener('mousemove', panMove);
        document.addEventListener('mouseup', endPanMove, { once: true });
    });

    function pan(e) {
        if (!isPanning) return;
        const coords = getEventCoords(e);
        const dx = coords.clientX - panStart.x;
        const dy = coords.clientY - panStart.y;
        boardPosition.x -= dx / zoomLevel;
        boardPosition.y -= dy / zoomLevel;
        panStart = { x: coords.clientX, y: coords.clientY };
        updateBoardTransform();
    }

    function endPan(panMove, endPanMove) {
        isPanning = false;
        dom.worldElement.classList.remove('panning');
        document.removeEventListener('mousemove', panMove);
        document.removeEventListener('mouseup', endPanMove);
    }
    
    dom.worldElement.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1 && !isDraggingDomino && !moveBranchMode) {
             if (e.target !== dom.worldElement && e.target !== dom.gameBoardElement && e.target.id !== 'world-wrapper') return;
             isPanning = true;
             dom.worldElement.classList.add('panning');
             const coords = getEventCoords(e);
             panStart = { x: coords.clientX, y: coords.clientY };
        }
    }, { passive: false });

    dom.worldElement.addEventListener('touchmove', (e) => {
        if (isPanning && e.touches.length === 1) {
            pan(e);
        }
    }, { passive: false });

    dom.worldElement.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) {
            isPanning = false;
            dom.worldElement.classList.remove('panning');
        }
    });

    if (dom.themeSwitcher) {
        dom.themeSwitcher.addEventListener('change', async (e) => {
            if (currentGameId) {
                const gameRef = doc(db, "games", currentGameId);
                await updateDoc(gameRef, { currentTheme: e.target.value });
            }
        });
    }

    // --- Validation & Challenge Logic ---
    dom.validateMoveButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) return;
                const gameState = gameSnap.data();
                if (gameState.turnState !== 'PENDING_VALIDATION') {
                    return; 
                }
                const currentTurnPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
                const playerHand = gameState.players[currentTurnPlayerId].hand;
                if (playerHand.length === 0) {
                    let roundPoints = {};
                    let scoreHistoryEntry = { round: gameState.roundNumber, scores: {} };
                    const updatedPlayers = { ...gameState.players };
                    Object.keys(updatedPlayers).forEach(pid => {
                        const handValue = (pid === currentTurnPlayerId) ? 0 : calculateHandValue(updatedPlayers[pid].hand);
                        updatedPlayers[pid].score += handValue;
                        roundPoints[pid] = handValue;
                        scoreHistoryEntry.scores[pid] = handValue;
                    });
                    const newScoreHistory = [...(gameState.scoreHistory || []), scoreHistoryEntry];
                    const isGameOver = gameState.roundNumber >= 10;
                    transaction.update(gameRef, {
                        players: updatedPlayers,
                        gameStatus: isGameOver ? 'finished' : 'round-over',
                        roundEndInfo: { winnerId: currentTurnPlayerId, points: roundPoints },
                        turnState: 'WAITING',
                        hasDrawn: false,
                        scoreHistory: newScoreHistory,
                        undoRequestedThisTurn: false // Reset flag
                    });
                } else {
                    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.playerOrder.length;
                    const nextPlayerId = gameState.playerOrder[nextPlayerIndex];
                    const nextPlayer = gameState.players[nextPlayerId];
                    const validatorName = gameState.players[currentPlayerId].name;
                    const newLog = [...(gameState.log || []), `${validatorName} validated the move. It's now ${nextPlayer.name}'s turn.`];
                    if (newLog.length > 5) newLog.shift();
                    const needsConfirmation = nextPlayer.controller !== nextPlayer.id; // Correct logic
                    
                    transaction.update(gameRef, {
                        currentPlayerIndex: nextPlayerIndex,
                        turnState: 'WAITING',
                        hasDrawn: false,
                        moveHistory: [],
                        lastPlayedDominoId: null,
                        log: newLog,
                        turnConfirmationPending: needsConfirmation,
                        undoRequestedThisTurn: false // Reset flag
                    });
                }
            });
        } catch(error) {
            console.error("Validation failed:", error);
            showMessage("Could not validate the move. Please try again.");
        }
    });

    dom.challengeMoveButton.addEventListener('click', async () => {
        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) return;
                const gameState = gameSnap.data();
                if (gameState.turnState !== 'PENDING_VALIDATION') {
                    return; // Move already validated or challenged
                }
                const challengerName = gameState.players[currentPlayerId].name;
                const challengedPlayerId = gameState.playerOrder[gameState.currentPlayerIndex];
                const challengedPlayerName = gameState.players[challengedPlayerId].name;
                const newBoardDominos = [...gameState.boardDominos];
                const challengedDominoIndex = newBoardDominos.findIndex(d => d.dominoData.id === gameState.lastPlayedDominoId);
                if (challengedDominoIndex > -1) {
                    const challengedDomino = newBoardDominos.splice(challengedDominoIndex, 1)[0];
                    const updatedPlayers = { ...gameState.players };
                    updatedPlayers[challengedPlayerId].hand.push(challengedDomino.dominoData);
                    const newLog = [...(gameState.log || []), `${challengerName} challenged ${challengedPlayerName}'s move! Tile returned.`];
                    if (newLog.length > 5) newLog.shift();
                    transaction.update(gameRef, {
                        boardDominos: newBoardDominos,
                        players: updatedPlayers,
                        turnState: 'WAITING',
                        hasDrawn: false,
                        lastPlayedDominoId: null,
                        moveHistory: [],
                        log: newLog
                    });
                }
            });
        } catch(error) {
            console.error("Challenge failed:", error);
            showMessage("Could not challenge the move. Please try again.");
        }
    });
    
    // --- Detailed Scoreboard Rendering --- 
    function renderDetailedScoreboard(gameState) {
        const { scoreHistory, players, playerOrder } = gameState;
        if (!scoreHistory || !dom.detailedScoreboardContent) return;
        dom.detailedScoreboardContent.innerHTML = ''; // Clear previous content
        const table = document.createElement('table');
        table.id = 'detailed-scoreboard-table';
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const roundHeader = document.createElement('th');
        roundHeader.textContent = 'R';
        headerRow.appendChild(roundHeader);
        playerOrder.forEach(pid => {
            const th = document.createElement('th');
            th.textContent = players[pid].name.substring(0, 3); // Abbreviate name
            headerRow.appendChild(th);
        });
        const tbody = table.createTBody();
        scoreHistory.forEach(roundData => {
            const row = tbody.insertRow();
            row.insertCell().textContent = roundData.round;
            playerOrder.forEach(pid => {
                row.insertCell().textContent = roundData.scores[pid] ?? '0';
            });
        });
        const tfoot = table.createTFoot();
        const totalRow = tfoot.insertRow();
        totalRow.className = 'total-row';
        const totalCell = totalRow.insertCell();
        totalCell.textContent = 'Total';
        playerOrder.forEach(pid => {
            const cell = totalRow.insertCell();
            cell.textContent = players[pid].score;
        });
        dom.detailedScoreboardContent.appendChild(table);
    }
    
    // --- REWORKED: Branch Moving Logic (No Physics) ---

    dom.moveBranchButton.addEventListener('click', () => {
        moveBranchMode = !moveBranchMode;
        dom.moveBranchButton.classList.toggle('active', moveBranchMode);
        
        // Reset selection when toggling the tool
        selectedBranch.dominos.forEach(d => {
            document.querySelector(`.domino[data-id="${d.dominoData.id}"]`)?.classList.remove('selected-for-branch', 'anchor-domino');
        });
        selectedBranch = { anchor: null, dominos: [], originalPositions: new Map(), isDraggingBranch: false };

        if (moveBranchMode) {
            dom.gameStatusElement.textContent = "Move Branch: Click a tile to be the anchor.";
        } else {
            // Restore normal status message
            if (localGameState && localGameState.playerOrder) {
                const currentTurnPlayerId = localGameState.playerOrder[localGameState.currentPlayerIndex];
                const isMyDeviceTurn = localGameState.players[currentTurnPlayerId]?.controller === currentPlayerId;
                updateStatusAndButtons(localGameState, isMyDeviceTurn, currentTurnPlayerId);
            }
        }
    });

    function handleBranchSelection(e, domino) {
        e.stopPropagation();
        const id = domino.dominoData.id;
        const el = document.querySelector(`.domino[data-id="${id}"]`);
        if (!el) return;

        // 1. No anchor yet, so this becomes the anchor.
        if (!selectedBranch.anchor) {
            selectedBranch.anchor = domino;
            selectedBranch.dominos.push(domino);
            el.classList.add('anchor-domino');
            dom.gameStatusElement.textContent = "Move Branch: Select adjacent tiles to add to the branch.";
            return;
        }

        // 2. Clicked on the anchor again. Clear everything.
        if (id === selectedBranch.anchor.dominoData.id) {
            selectedBranch.dominos.forEach(d => {
                document.querySelector(`.domino[data-id="${d.dominoData.id}"]`)
                        ?.classList.remove('selected-for-branch', 'anchor-domino');
            });
            selectedBranch = { anchor: null, dominos: [], originalPositions: new Map(), isDraggingBranch: false };
            dom.gameStatusElement.textContent = "Move Branch: Select a tile to be the anchor.";
            return;
        }

        const isSelected = selectedBranch.dominos.some(d => d.dominoData.id === id);

        if (isSelected) {
            // 3. Clicked a selected (non-anchor) tile. De-select it.
            selectedBranch.dominos = selectedBranch.dominos.filter(d => d.dominoData.id !== id);
            el.classList.remove('selected-for-branch');
        } else {
            // 4. Clicked a new, unselected tile. Try to add it.
            const isAdjacentToBranch = selectedBranch.dominos.some(branchDomino => checkAdjacency(branchDomino, domino));
            if (isAdjacentToBranch) {
                selectedBranch.dominos.push(domino);
                el.classList.add('selected-for-branch');
            } else {
                showMessage("You can only select tiles that are adjacent to the existing branch.");
            }
        }
    }

    function checkAdjacency(dominoA, dominoB) {
        const centerAx = dominoA.x + DOMINO_WIDTH / 2;
        const centerAy = dominoA.y + DOMINO_HEIGHT / 2;
        const centerBx = dominoB.x + DOMINO_WIDTH / 2;
        const centerBy = dominoB.y + DOMINO_HEIGHT / 2;

        const dx = centerAx - centerBx;
        const dy = centerAy - centerBy;
        const distance = Math.sqrt(dx * dx + dy * dy);

        return distance < (DOMINO_WIDTH * 1.1);
    }

    function startBranchDrag(e, dominoObject) {
        if (!moveBranchMode || !selectedBranch.anchor || !selectedBranch.dominos.some(d => d.dominoData.id === dominoObject.dominoData.id)) return;
        
        isDraggingDomino = true; 
        selectedBranch.isDraggingBranch = true;
        draggedDominoData = dominoObject;

        const coords = getEventCoords(e);
        dragStartPos = { x: coords.clientX, y: coords.clientY };
        
        selectedBranch.originalPositions.clear();
        selectedBranch.dominos.forEach(dom => {
            selectedBranch.originalPositions.set(dom.dominoData.id, { x: dom.x, y: dom.y, rotation: dom.rotation });
        });

        const moveHandler = (ev) => dragBranch(ev);
        const endHandler = (ev) => endBranchDrag(ev, moveHandler, endHandler);

        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endHandler, { once: true });
        document.addEventListener('touchmove', moveHandler, { passive: false });
        document.addEventListener('touchend', endHandler, { once: true });
    }

    function dragBranch(e) {
        if (!selectedBranch.isDraggingBranch) return;
        e.preventDefault();

        const coords = getEventCoords(e);
        const anchorScreenPos = worldToScreen(selectedBranch.anchor.x + DOMINO_WIDTH / 2, selectedBranch.anchor.y + DOMINO_HEIGHT / 2);

        const initialAngle = Math.atan2(dragStartPos.y - anchorScreenPos.y, dragStartPos.x - anchorScreenPos.x);
        const currentAngle = Math.atan2(coords.clientY - anchorScreenPos.y, coords.clientX - anchorScreenPos.x);
        const angleDelta = currentAngle - initialAngle;

        selectedBranch.dominos.forEach(domino => {
            if (domino.dominoData.id === selectedBranch.anchor.dominoData.id) return;

            const el = document.querySelector(`.domino[data-id="${domino.dominoData.id}"]`);
            if (!el) return;

            const originalPos = selectedBranch.originalPositions.get(domino.dominoData.id);
            const anchorCenter = { x: selectedBranch.anchor.x + DOMINO_WIDTH/2, y: selectedBranch.anchor.y + DOMINO_HEIGHT/2 };
            
            const ox = (originalPos.x + DOMINO_WIDTH/2) - anchorCenter.x;
            const oy = (originalPos.y + DOMINO_HEIGHT/2) - anchorCenter.y;
            
            const rotatedX = ox * Math.cos(angleDelta) - oy * Math.sin(angleDelta);
            const rotatedY = ox * Math.sin(angleDelta) + oy * Math.cos(angleDelta);
            
            const newCenterX = anchorCenter.x + rotatedX;
            const newCenterY = anchorCenter.y + rotatedY;

            const newRotation = originalPos.rotation + (angleDelta * 180 / Math.PI);

            el.style.left = `${newCenterX - DOMINO_WIDTH/2}px`;
            el.style.top = `${newCenterY - DOMINO_HEIGHT/2}px`;
            el.style.transform = `rotate(${newRotation}deg)`;
        });
    }

    async function endBranchDrag(e, moveHandler, endHandler) {
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', endHandler);
        document.removeEventListener('touchmove', moveHandler);
        document.removeEventListener('touchend', endHandler);

        if (!selectedBranch.isDraggingBranch) return;

        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw new Error("Game not found");
                
                const newBoardDominos = [...gameSnap.data().boardDominos];
                const newMoveHistory = [...(gameSnap.data().moveHistory || [])];

                const originalBranchState = [];
                selectedBranch.dominos.forEach(domino => {
                    const original = selectedBranch.originalPositions.get(domino.dominoData.id);
                    if (original) {
                        originalBranchState.push({ dominoId: domino.dominoData.id, ...original });
                    }
                });
                newMoveHistory.push({ type: 'branch_move', from: originalBranchState });

                selectedBranch.dominos.forEach(domino => {
                    if (domino.dominoData.id === selectedBranch.anchor.dominoData.id) return;
                    const el = dom.gameBoardElement.querySelector(`.domino[data-id="${domino.dominoData.id}"]`);
                    if (!el) return;

                    const boardIndex = newBoardDominos.findIndex(d => d.dominoData.id === domino.dominoData.id);
                    if (boardIndex > -1) {
                        const newX = parseFloat(el.style.left);
                        const newY = parseFloat(el.style.top);
                        
                        const transform = el.style.transform;
                        const rotationMatch = transform.match(/rotate\(([^)]+)deg\)/);
                        const newRotation = rotationMatch ? parseFloat(rotationMatch[1]) : 0;
                        
                        newBoardDominos[boardIndex].x = newX;
                        newBoardDominos[boardIndex].y = newY;
                        newBoardDominos[boardIndex].rotation = newRotation;
                    }
                });
                transaction.update(gameRef, { boardDominos: newBoardDominos, moveHistory: newMoveHistory });
            });
        } catch (error) {
            console.error("Error saving moved branch:", error);
            showMessage("Could not save branch position. The change may be reverted.");
            handleGameStateUpdate(localGameState);
        }
        
        isDraggingDomino = false;
        selectedBranch.isDraggingBranch = false;
        selectedBranch.originalPositions.clear();
    }
    
    // Helper functions for coordinate conversion
    function screenToWorld(screenX, screenY) {
        const worldRect = dom.worldElement.getBoundingClientRect();
        const x = (screenX - worldRect.left) / zoomLevel + boardPosition.x;
        const y = (screenY - worldRect.top) / zoomLevel + boardPosition.y;
        return { x, y };
    }

    function worldToScreen(worldX, worldY) {
        const worldRect = dom.worldElement.getBoundingClientRect();
        const x = (worldX - boardPosition.x) * zoomLevel + worldRect.left;
        const y = (worldY - boardPosition.y) * zoomLevel + worldRect.top;
        return { x, y };
    }

    dom.zoomInButton.addEventListener('click', () => zoomWithControls(0.2));
    dom.zoomOutButton.addEventListener('click', () => zoomWithControls(-0.2));

    function handleZoom(delta, clientX, clientY) {
        const rect = dom.worldElement.getBoundingClientRect();
        const mouseX = clientX - rect.left;
        const mouseY = clientY - rect.top;
        const worldX_before = (mouseX / zoomLevel) + boardPosition.x;
        const worldY_before = (mouseY / zoomLevel) + boardPosition.y;
        const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel * (1 + delta)));
        boardPosition.x = worldX_before - (mouseX / newZoom);
        boardPosition.y = worldY_before - (mouseY / newZoom);
        zoomLevel = newZoom;
        updateBoardTransform();
    }

    function zoomWithControls(delta) {
        const rect = dom.worldElement.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        handleZoom(delta, centerX, centerY);
    }
    
    // --- REWORKED: Rotation Handles Logic ---
    function addLongPressListener(element, domino) {
        let touchStartPos = { x: 0, y: 0 };
        
        element.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1 || isDraggingDomino || wasDragged) return;
            const coords = getEventCoords(e);
            touchStartPos = { x: coords.clientX, y: coords.clientY };
            
            longPressTimer = setTimeout(() => {
                showRotationHandles(e, domino);
                longPressTimer = null;
            }, 500); // 500ms for a long press
        }, { passive: true });

        element.addEventListener('touchmove', (e) => {
            if (longPressTimer) {
                const coords = getEventCoords(e);
                if (Math.abs(coords.clientX - touchStartPos.x) > 10 || Math.abs(coords.clientY - touchStartPos.y) > 10) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }
        });

        const cancelLongPress = () => {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        element.addEventListener('touchend', cancelLongPress);
        element.addEventListener('touchcancel', cancelLongPress);
    }

    function showRotationHandles(e, domino) {
        if (moveBranchMode || isRotating) return;
        const currentTurnPlayer = localGameState.players[localGameState.playerOrder[localGameState.currentPlayerIndex]];
        const isMyDeviceTurn = currentTurnPlayer.controller === currentPlayerId;
        if (!isMyDeviceTurn || localGameState.turnState !== 'PLACED' || domino.dominoData.id !== localGameState.lastPlayedDominoId) {
            return;
        }
        hideRotationHandles(); // Hide any existing handles
        
        const dominoEl = dom.gameBoardElement.querySelector(`.domino[data-id="${domino.dominoData.id}"]`);
        if (!dominoEl) return;
        
        const rect = dominoEl.getBoundingClientRect();
        const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        const angle = domino.rotation * (Math.PI / 180);
        const radius = DOMINO_WIDTH * zoomLevel / 2 * 1.0;

        const handle1 = document.createElement('div');
        handle1.className = 'rotation-handle';
        handle1.id = 'rotation-handle-1';
        const handle2 = document.createElement('div');
        handle2.className = 'rotation-handle';
        handle2.id = 'rotation-handle-2';

        const handle1Angle = angle - Math.PI / 2;
        const handle2Angle = angle + Math.PI / 2;

        handle1.style.left = `${center.x + radius * Math.cos(handle1Angle)}px`;
        handle1.style.top = `${center.y + radius * Math.sin(handle1Angle)}px`;
        handle2.style.left = `${center.x + radius * Math.cos(handle2Angle)}px`;
        handle2.style.top = `${center.y + radius * Math.sin(handle2Angle)}px`;


        dom.rotationHandlesContainer.appendChild(handle1);
        dom.rotationHandlesContainer.appendChild(handle2);

        const startDrag = (startEvent) => startRotationDrag(startEvent, domino);
        handle1.addEventListener('mousedown', startDrag);
        handle1.addEventListener('touchstart', startDrag, { passive: false });
        handle2.addEventListener('mousedown', startDrag);
        handle2.addEventListener('touchstart', startDrag, { passive: false });

        setTimeout(() => {
             document.addEventListener('click', hideRotationHandles, { once: true });
             document.addEventListener('contextmenu', hideRotationHandles, { once: true });
        },0);
    }
    
    function hideRotationHandles(e) {
        if (e && (e.target.classList.contains('rotation-handle') || e.target.classList.contains('domino-on-board'))) return;
        dom.rotationHandlesContainer.innerHTML = '';
        document.removeEventListener('click', hideRotationHandles);
        document.removeEventListener('contextmenu', hideRotationHandles);
    }

    function startRotationDrag(e, domino) {
        e.stopPropagation();
        e.preventDefault();
        isRotating = true;
        draggedDominoData = domino; 
        
        const dominoEl = dom.gameBoardElement.querySelector(`.domino[data-id="${domino.dominoData.id}"]`);
        if (!dominoEl) return;
        
        const rect = dominoEl.getBoundingClientRect();
        const pivot = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        
        const handle1 = document.getElementById('rotation-handle-1');
        const handle2 = document.getElementById('rotation-handle-2');

        const startAngleRad = Math.atan2(getEventCoords(e).clientY - pivot.y, getEventCoords(e).clientX - pivot.x);
        const startDominoRotation = domino.rotation || 0;

        const dragRotateHandler = (moveEvent) => {
            moveEvent.preventDefault();
            const coords = getEventCoords(moveEvent);
            const currentAngleRad = Math.atan2(coords.clientY - pivot.y, coords.clientX - pivot.x);
            const angleDeltaRad = currentAngleRad - startAngleRad;
            let newAngleDeg = startDominoRotation + (angleDeltaRad * 180 / Math.PI);
            
            // SMOOTH SNAP: Remove transition during drag for responsiveness
            dominoEl.style.transition = 'none';
            dominoEl.style.transform = `rotate(${newAngleDeg}deg)`;

            // ROTATION HANDLES: Update positions of BOTH handles so they move with the rotation
            const radius = DOMINO_WIDTH * zoomLevel / 2 * 1.0;
            
            const handle1Angle = newAngleDeg * (Math.PI / 180) - Math.PI / 2;
            const handle2Angle = handle1Angle + Math.PI;

            if(handle1) {
                handle1.style.left = `${pivot.x + radius * Math.cos(handle1Angle)}px`;
                handle1.style.top = `${pivot.y + radius * Math.sin(handle1Angle)}px`;
            }
            if(handle2) {
                handle2.style.left = `${pivot.x + radius * Math.cos(handle2Angle)}px`;
                handle2.style.top = `${pivot.y + radius * Math.sin(handle2Angle)}px`;
            }
        };

        const endRotateHandler = () => {
            document.removeEventListener('mousemove', dragRotateHandler);
            document.removeEventListener('touchmove', dragRotateHandler);
            
            const transform = dominoEl.style.transform;
            const rotationMatch = transform.match(/rotate\(([^)]+)deg\)/);
            const finalRotation = rotationMatch ? parseFloat(rotationMatch[1]) : domino.rotation;

            // SMOOTH SNAP: Calculate snapped angle and apply it
            const snappedAngle = Math.round(finalRotation / 45) * 45;
            dominoEl.style.transition = 'transform 0.2s cubic-bezier(.25,.8,.25,1)'; // Re-apply transition for the snap
            dominoEl.style.transform = `rotate(${snappedAngle}deg)`;

            rotateDominoToAngle(domino, snappedAngle);
            isRotating = false;
            draggedDominoData = null;
            // FIX: Explicitly hide handles again on completion to be safe.
            hideRotationHandles();
            document.removeEventListener('mouseup', endRotateHandler);
            document.removeEventListener('touchend', endRotateHandler);
        };
        
        document.addEventListener('mousemove', dragRotateHandler);
        document.addEventListener('touchmove', dragRotateHandler, { passive: false });
        document.addEventListener('mouseup', endRotateHandler, { once: true });
        document.addEventListener('touchend', endRotateHandler, { once: true });
    }

    async function rotateDominoToAngle(domino, angle) {
        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) return;
                const gameState = gameSnap.data();
                const newBoardDominos = [...gameState.boardDominos];
                const boardIndex = newBoardDominos.findIndex(d => d.dominoData.id === domino.dominoData.id);
                if (boardIndex > -1) {
                    const oldRotation = newBoardDominos[boardIndex].rotation;
                    newBoardDominos[boardIndex].rotation = angle;
                    const newMoveHistory = [...(gameState.moveHistory || []), { type: 'rotate', dominoId: domino.dominoData.id, from: oldRotation }];
                    transaction.update(gameRef, { 
                        boardDominos: newBoardDominos,
                        moveHistory: newMoveHistory
                    });
                }
            });
        } catch (error) {
            console.error("Error rotating domino:", error);
            showMessage("Could not rotate domino.");
        }
    }

    // --- UNDO VALIDATION: New and Modified Undo Logic ---
    async function requestUndo(type) {
        const gameRef = doc(db, "games", currentGameId);

        if (localGameState.undoRequestedThisTurn) {
            showMessage("You can only request one undo per turn.");
            return;
        }

        const currentTurnPlayerId = localGameState.playerOrder[localGameState.currentPlayerIndex];
        const newLog = [...(localGameState.log || []), `${localGameState.players[currentTurnPlayerId].name} requested an undo.`];
        if (newLog.length > 5) newLog.shift();

        await updateDoc(gameRef, {
            undoRequestedThisTurn: true,
            undoRequest: {
                requestingPlayerId: currentTurnPlayerId,
                type: type,
                approvals: [],
                status: 'pending'
            },
            log: newLog
        });
    }

    async function cancelUndoRequest() {
        const gameRef = doc(db, "games", currentGameId);
        const newLog = [...(localGameState.log || [])];
        newLog.pop(); // Remove the "requested an undo" message
        await updateDoc(gameRef, {
            undoRequest: { requestingPlayerId: null, type: null, approvals: [], status: 'none' },
            undoRequestedThisTurn: false, // Allow another request if cancelled
            log: newLog
        });
    }


    async function approveUndo() {
        const gameRef = doc(db, "games", currentGameId);
        await updateDoc(gameRef, {
            'undoRequest.approvals': arrayUnion(currentPlayerId)
        });
    }

    async function denyUndo() {
        const gameRef = doc(db, "games", currentGameId);
        const denierName = localGameState.players[currentPlayerId].name;
        const newLog = [...(localGameState.log || []), `${denierName} denied the undo request.`];
        if (newLog.length > 5) newLog.shift();
        await updateDoc(gameRef, {
            'undoRequest.status': 'denied',
            log: newLog
        });
    }

    function handleUndoRequest(gameState, oldUndoStatus) {
        const undoRequest = gameState.undoRequest;
        if (!undoRequest || undoRequest.status === 'none') return;

        const amITheRequester = undoRequest.requestingPlayerId === currentPlayerId;
        const amITheHost = gameState.players[currentPlayerId]?.isHost;
        
        // --- Show modal to players who need to vote ---
        if (undoRequest.status === 'pending' && !amITheRequester) {
            const alreadyVoted = undoRequest.approvals.includes(currentPlayerId);
            const isModalVisible = !dom.messageModal.classList.contains('hidden');
            if (!alreadyVoted && !isModalVisible) { // Only show if not already voted and modal isn't open for something else
                const requesterName = gameState.players[undoRequest.requestingPlayerId]?.name || 'A player';
                showMessage(`${requesterName} wants to undo their last ${undoRequest.type}.`, {
                    confirmText: "Approve",
                    confirmClass: "bg-green-600 hover:bg-green-700 action-needed",
                    onConfirm: approveUndo,
                    showCancel: true,
                    cancelText: "Deny",
                    cancelClass: "bg-red-600 hover:bg-red-600",
                    onCancel: denyUndo
                });
            }
        }

        // --- Host executes the approved undo ---
        const requiredApprovals = 1; 

        if (amITheHost && undoRequest.status === 'pending' && undoRequest.approvals.length >= requiredApprovals) {
            const gameRef = doc(db, "games", currentGameId);
            updateDoc(gameRef, { 'undoRequest.status': 'approved' }).then(() => {
                if (undoRequest.type === 'play') {
                    executeUndoMove();
                } else if (undoRequest.type === 'draw') {
                    executeUndoDraw();
                }
            });
        }
        
        if (oldUndoStatus === 'pending' && undoRequest.status === 'denied') {
            if (amITheRequester) {
                showMessage("Your undo request was denied.");
            }
            // The host is responsible for cleaning up the 'denied' state after a delay
            if (amITheHost) {
                setTimeout(() => {
                    const gameRef = doc(db, "games", currentGameId);
                    // Reset the state so the player can continue their turn
                    updateDoc(gameRef, {
                        undoRequest: { requestingPlayerId: null, type: null, approvals: [], status: 'none' }
                    });
                }, 1500); // 1.5s delay to allow clients to see the "denied" message
            }
        }
    }

    async function executeUndoMove() {
        const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw new Error("Game does not exist!");
                const gameState = gameSnap.data();

                const lastPlayedId = gameState.lastPlayedDominoId;
                const turnPlayerId = gameState.undoRequest.requestingPlayerId;
                if (!lastPlayedId || !turnPlayerId) return;

                const newBoardDominos = [...gameState.boardDominos];
                const playedDominoIndex = newBoardDominos.findIndex(d => d.dominoData.id === lastPlayedId);
                if (playedDominoIndex === -1) return;

                const [undoneDominoObject] = newBoardDominos.splice(playedDominoIndex, 1);
                const updatedPlayers = { ...gameState.players };
                updatedPlayers[turnPlayerId].hand.push(undoneDominoObject.dominoData);

                const newLog = [...(gameState.log || []), `The undo was approved. ${updatedPlayers[turnPlayerId].name}'s turn is reset.`];
                if (newLog.length > 5) newLog.shift();

                transaction.update(gameRef, {
                    players: updatedPlayers,
                    boardDominos: newBoardDominos,
                    turnState: 'WAITING',
                    lastPlayedDominoId: null,
                    moveHistory: [],
                    log: newLog,
                    undoRequest: { requestingPlayerId: null, type: null, approvals: [], status: 'none' }
                });
            });
        } catch (error) {
            console.error("Error executing move undo:", error);
            showMessage("Could not perform the undo action.");
        }
    }
    
    async function executeUndoDraw() {
         const gameRef = doc(db, "games", currentGameId);
        try {
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw "Game does not exist!";
                const gameState = gameSnap.data();
                
                const turnPlayerId = gameState.undoRequest.requestingPlayerId;
                const lastDrawnId = gameState.lastDrawnDominoId;
                const currentTurnPlayer = gameState.players[turnPlayerId];

                if (!lastDrawnId || !currentTurnPlayer) return;

                const hand = [...currentTurnPlayer.hand];
                const drawnDominoIndex = hand.findIndex(d => d.id === lastDrawnId);
                if (drawnDominoIndex === -1) return; 

                const [undoneDomino] = hand.splice(drawnDominoIndex, 1);
                const newBoneyard = [...gameState.boneyard, undoneDomino];
                
                const updatedPlayers = { ...gameState.players };
                updatedPlayers[turnPlayerId].hand = hand;

                const newLog = [...(gameState.log || []), `The draw undo was approved for ${currentTurnPlayer.name}.`];
                if (newLog.length > 5) newLog.shift();
                
                transaction.update(gameRef, {
                    players: updatedPlayers,
                    boneyard: newBoneyard,
                    hasDrawn: false,
                    lastDrawnDominoId: null,
                    log: newLog,
                    undoRequest: { requestingPlayerId: null, type: null, approvals: [], status: 'none' }
                });
            });
        } catch (error) {
            console.error("Error executing draw undo:", error);
        }
    }


    dom.undoMoveButton.addEventListener('click', () => {
        const { undoRequest } = localGameState;
        if (undoRequest?.status === 'pending' && undoRequest.type === 'play') {
            cancelUndoRequest();
        } else {
            requestUndo('play');
        }
    });

    dom.undoDrawButton.addEventListener('click', () => {
        const { undoRequest } = localGameState;
        if (undoRequest?.status === 'pending' && undoRequest.type === 'draw') {
            cancelUndoRequest();
        } else {
            requestUndo('draw');
        }
    });


    // --- Initial Load ---
    window.onload = initializeFirebase;
</script>
</body>
</html>
